\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{hyperref}
\hypersetup{
            pdftitle={Outstanding User Interfaces with Shiny},
            pdfauthor={David Granjon},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{booktabs}
\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Outstanding User Interfaces with Shiny}
\author{David Granjon}
\date{2020-05-29}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{prerequisites}{%
\chapter*{Prerequisites}\label{prerequisites}}
\addcontentsline{toc}{chapter}{Prerequisites}

\begin{itemize}
\tightlist
\item
  Be familiar with \href{https://mastering-shiny.org}{Shiny}
\item
  Basic knowledge in HTML and JavaScript is a plus but not mandatory
\end{itemize}

\hypertarget{disclaimer}{%
\section*{Disclaimer}\label{disclaimer}}
\addcontentsline{toc}{section}{Disclaimer}

This book is not an HTML/Javascript/CSS course! Instead, it provides a \emph{survival kit} to be able to customize Shiny. I am sure however that readers will want to explore more about these topics.

\hypertarget{is-this-book-for-me}{%
\section*{Is this book for me?}\label{is-this-book-for-me}}
\addcontentsline{toc}{section}{Is this book for me?}

You should read this book if you answer yes to the following questions:

\begin{itemize}
\tightlist
\item
  Do you want to know how to develop outstanding shiny apps?
\item
  Have you ever wondered how to develop new input widgets?
\end{itemize}

\hypertarget{related-content}{%
\section*{Related content}\label{related-content}}
\addcontentsline{toc}{section}{Related content}

See the \href{https://rstudio.cloud}{RStudio Cloud} dedicated project.
This book will serve as a reference for the e-Rum2020 \href{https://2020.erum.io/program/workshops/}{workshop} about ``Advanced User Interfaces for Shiny Developers'', provided by \href{https://www.novartis.com}{Novartis}. The detailed agenda is available \href{https://github.com/Novartis/Advanced-User-Interfaces-for-Shiny-Developers}{here}.

\hypertarget{acknowledgements}{%
\section*{Acknowledgements}\label{acknowledgements}}
\addcontentsline{toc}{section}{Acknowledgements}

\begin{itemize}
\tightlist
\item
  I am very grateful to Douglas Robinson for proof reading the book and fixing many typos it contained.
\item
  A special thanks to my friends John and Victor for contributing to RinteRface. By contribution, I am not meaning only code contribution but also support in any form.
\item
  Thanks to the eRum organizers to give me the opportunity to present this work at the virtual \href{https://2020.erum.io}{e-Rum2020} conference
\item
  RinteRace and this book won't exist without the amazing R community. Thanks for their valuable feedbacks.
\end{itemize}

\hypertarget{packages}{%
\section*{Packages}\label{packages}}
\addcontentsline{toc}{section}{Packages}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{library}\NormalTok{(shinydashboard)}
\KeywordTok{library}\NormalTok{(cascadess)}
\KeywordTok{library}\NormalTok{(htmltools)}
\KeywordTok{library}\NormalTok{(purrr)}
\KeywordTok{library}\NormalTok{(magrittr)}
\KeywordTok{library}\NormalTok{(ggplot2)}
\KeywordTok{library}\NormalTok{(thematic)}
\KeywordTok{library}\NormalTok{(fresh)}
\KeywordTok{library}\NormalTok{(testthat)}
\KeywordTok{library}\NormalTok{(jstools)}
\KeywordTok{library}\NormalTok{(scales)}
\KeywordTok{library}\NormalTok{(dplyr)}
\KeywordTok{library}\NormalTok{(apexcharter)}
\end{Highlighting}
\end{Shaded}

\hypertarget{intro}{%
\chapter{Introduction}\label{intro}}

There are various Shiny focused resources introducing \href{https://shiny.rstudio.com/tutorial/}{basic} as well as advanced topics such as \href{https://shiny.rstudio.com/articles/\#modules}{modules} and \href{https://js4shiny.com}{Javascript/R} interactions, however, handling advanced user interfaces design was never an emphasis. Clients often desire custom templates, yet this generally exceeds core features of Shiny (not out of the box).

Generally, R App developers lack a significant background in web development and often find this requirement overwhelming. It was this sentiment that motivated writing this book, namely to provide readers the necessary knowledge to extend Shiny's layout, input widgets and output elements. This project officially started at the end of 2018 but was stopped when Joe Cheng revealed the upcoming \href{https://mastering-shiny.org}{Mastering Shiny Book}. Fortunately, the later, does not cover a lot about the customization of Shiny user interfaces. Besides, this book may constitute a good complement to the work in progress \href{https://engineering-shiny.org}{Engineering Production-Grade Shiny Apps} by the ThinkR team, where the link between Shiny and CSS/JavaScript is covered.

This book is organized into five parts.

\begin{itemize}
\tightlist
\item
  We first go through the basics of HTML, JavaScript and jQuery
\item
  Part 2 contains chapters dedicated to the partially hidden features of Shiny, yet so fun. We dedicate an entire chapter to describe how inputs work in detail and how to add new inputs to the system
\item
  In part 3, we dive into the \texttt{\{htmltools\}} package, providing functions to create and manipulate shiny tags as well as manage dependencies
\item
  Part 4 focuses on the development of a new template for Shiny by demonstrating examples from the \texttt{\{tablerDash\}}, \texttt{\{bs4Dash}\} and \texttt{\{shinyMobile\}} packages. These, and more may be explored further as part of the RinteRface project.
\item
  Part 5 present some tools of the R community, like \texttt{\{fresh\}}, to beautify apps with only few lines of code
\end{itemize}

\hypertarget{preliminary-exercices}{%
\section*{Preliminary exercices}\label{preliminary-exercices}}
\addcontentsline{toc}{section}{Preliminary exercices}

Before starting with technical details, we propose to play a little game. Among all the images shown, what are the ones corresponding to shiny apps? Images are numbered from A to F (left to right, top to bottom).

\includegraphics[width=0.5\linewidth]{images/intro/deminR} \includegraphics[width=0.5\linewidth]{images/intro/shinyMons}

\includegraphics[width=0.5\linewidth]{images/intro/nifty} \includegraphics[width=0.5\linewidth]{images/intro/virtual_patient}

\includegraphics[width=0.5\linewidth]{images/intro/covid-tracker} \includegraphics[width=0.5\linewidth]{images/intro/tabler}

\hypertarget{part-survival-kit}{%
\part*{Survival Kit}\label{part-survival-kit}}
\addcontentsline{toc}{part}{Survival Kit}

This part will give you basis in HTML, JavaScript to get started\ldots{}

\hypertarget{survival-kit-html}{%
\chapter{HTML}\label{survival-kit-html}}

This chapter provides a short introduction to the HTML language. As a quick example, open up RStudio and perform the following:

\begin{itemize}
\tightlist
\item
  Load shiny with \texttt{library(shiny)}
\item
  Execute \texttt{p("Hello\ World")}
\end{itemize}

Notice the output format is an example of an HTML tag!

\hypertarget{html-basics}{%
\section{HTML Basics}\label{html-basics}}

HTML (Hypertext Markup Language) is derived from SGML (Standard Generalized markup Language). An HTML file contains tags that may be divided into 2 catagories:

\begin{itemize}
\tightlist
\item
  paired-tags: the text is inserted between the opening and the closing tag
\item
  closing-tags
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{<!-- paired-tags -->}
\KeywordTok{<p></p>}
\KeywordTok{<div></div>}

\CommentTok{<!-- self-closing tags -->}
\KeywordTok{<iframe/>}
\KeywordTok{<img/>}
\KeywordTok{<input/>}
\KeywordTok{<br/>}
\end{Highlighting}
\end{Shaded}

Tags may be divided into 3 categories, based on their role:

\begin{itemize}
\tightlist
\item
  structure tags: they consitute the skeleton of the HTML page (\texttt{\textless{}title\textgreater{}\textless{}/title\textgreater{}}, \texttt{\textless{}head\textgreater{}\textless{}/head\textgreater{}}, \texttt{\textless{}body\textgreater{}\textless{}/body\textgreater{}})
\item
  control tags: script, inputs and buttons (and more). Their role is to include external ressources, provide interactivity with the user
\item
  formatting tags: to control the size, font of the wrapped text
\end{itemize}

Finally, we distinguish block and inline elements:

\begin{itemize}
\tightlist
\item
  block elements may contain other tags and take the full width (block or inline). \texttt{\textless{}div\textgreater{}\textless{}/div\textgreater{}} is the most commonly used block element. All elements of a block are printed on top of each others
\item
  inline elements (for instance \texttt{\textless{}span\textgreater{}\textless{}/span\textgreater{}}, \texttt{\textless{}a\textgreater{}\textless{}/a\textgreater{}}) are printed on the same line. They can not contain block tags but may contain other nested inline tags. In practice, we often see \texttt{\textless{}a\textgreater{}\textless{}span\textgreater{}\textless{}/span\textgreater{}\textless{}/a\textgreater{}}
\item
  inline-block elements allow to insert block element in an inline
\end{itemize}

Consider the following example. This is clearly a bad use of HTML conventions since an inline tag can not host block elements.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<span>}
  \KeywordTok{<div><p>}\NormalTok{Hello World}\KeywordTok{</p></div>}
  \KeywordTok{<div></div>}
\KeywordTok{</span>}
\end{Highlighting}
\end{Shaded}

Importantly, \texttt{\textless{}div\textgreater{}} and \texttt{\textless{}span\textgreater{}} don't have any semantic meaning, contrary to \texttt{\textless{}header\textgreater{}} and \texttt{\textless{}footer\textgreater{}}, which allow to structure the HTML page.

\hypertarget{tag-attributes}{%
\section{Tag attributes}\label{tag-attributes}}

Attributes are text elements allowing to specify some properties of the tag. For instance for a link tag (\texttt{\textless{}a\textgreater{}\textless{}/a\textgreater{}}), we actually expect more than just the tag itself: a target url and how to open the new page \ldots{} In all previous examples, tags don't have any attributes. Yet, there exist a large range of attributes and we will only see 2 of them for now (the reason is that these are the most commonly used in CSS and JavaScript):

\begin{itemize}
\tightlist
\item
  class: may be shared between multiple tags
\item
  id: each must be unique
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"awesome-item"}\OtherTok{ id=}\StringTok{"myitem"}\KeywordTok{></div>}
\CommentTok{<!-- the class awesome-item may be applied to multiple tags -->}
\KeywordTok{<span}\OtherTok{ class=}\StringTok{"awesome-item"}\KeywordTok{></span>}
\end{Highlighting}
\end{Shaded}

Both attributes are widely used by CSS and JavaScript (see Chapter \ref{survival-kit-javascript} with the jQuery selectors) to apply a custom style to a web page. Class attributes apply to multiple elements, however the id attribute is restricted to only one item.

Interestingly, there exists another attribute category, know as non-standard attributes like \texttt{data-toggle}. We will see them later in the book (see Chapter \ref{custom-templates-skeleton}).

\hypertarget{html-page-skeleton}{%
\section{HTML page: skeleton}\label{html-page-skeleton}}

An HTML page is a collection of tags which will be interpreted by the web browser step by step. The simplest HTML page may be defined as follows:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
  \CommentTok{<!-- head content here -->}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
  \CommentTok{<!-- body content here -->}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{\textless{}html\textgreater{}} is the may wrapper
\item
  \texttt{\textless{}head\textgreater{}} and \texttt{\textless{}body\textgreater{}} are the 2 main children

  \begin{itemize}
  \tightlist
  \item
    \texttt{\textless{}head\textgreater{}} contains dependencies like styles and JavaScript files (but not only),
  \item
    \texttt{\textless{}body\textgreater{}} contains the page content and it is displayed on the screen. We will see later that JavaScript files are often added just before the end of the \texttt{\textless{}body\textgreater{}}.
  \end{itemize}
\end{itemize}

Only the body content is displayed on the screen!

Let's write the famous Hello World in HTML:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
  \CommentTok{<!-- head content here -->}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
  \KeywordTok{<p>}\NormalTok{Hello World}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

In order to preview this page in a web browser, you need to save the above snippet to a script \texttt{hello-world.html} and double-click on it. It will open with your default web browser.

\hypertarget{about-the-document-object-model-dom}{%
\section{About the Document Object Model (DOM)}\label{about-the-document-object-model-dom}}

The DOM stands for ``Document Object Model'' and is a convenient representation of the html document. There actually exists multiple DOM types, namely DOM-XML and DOM-HTML but we will only focus on the latter. If we consider the last example (Hello World), the associated DOM tree may be inspected in Figure \ref{fig:html-dom}.

\hypertarget{visualizing-the-dom-the-html-inspector}{%
\subsection{Visualizing the DOM: the HTML inspector}\label{visualizing-the-dom-the-html-inspector}}

Below, we introduce a tool that will facilitate our exploration of beautiful shiny user interfaces. In this section, we restrict the description to the first panel of the HTML inspector \footnote{As shown in Figure \ref{fig:html-dom}, the inspector also has tools to debug JavaScript code, inspect files, run performances audit, \ldots{} We will describe some of these later in the book.}. This feature is available in all web browser, however for demonstration purposes, we will only focus on Chrome.

\begin{itemize}
\tightlist
\item
  Open the hello-world.html example in a web browser (google chrome here)
\item
  Right-click to open the HTML inspector (developer tools must be enabled if it is not the case)
\end{itemize}

The HTML inspector is a convenient tool to explore the structure of the current HTML page. On the left-hand side, the DOM tree is displayed where we clearly see that \texttt{\textless{}html\textgreater{}} is the parent of \texttt{\textless{}head\textgreater{}} and \texttt{\textless{}body\textgreater{}}. \texttt{\textless{}body\textgreater{}} has also 1 child, that is \texttt{\textless{}p\textgreater{}}. We may preview any style (CSS) associated to the selected element on the right panel as well as Event Listeners (JavaScript), which will be discussed that in the next chapter.

\begin{figure}
\includegraphics[width=21.5in]{images/survival-kit/dom} \caption{Inspection of the DOM in the Hello World example}\label{fig:html-dom}
\end{figure}

\hypertarget{preliminary-introduction-to-css-and-javascript}{%
\section{Preliminary introduction to CSS and JavaScript}\label{preliminary-introduction-to-css-and-javascript}}

To introduce this section, I propose to look at the very first website, early in the 90's (August 1991 exactly). From an esthetic point of view (see Figure \ref{fig:www-first}), this is far from what we can observe today as shown in Figure \ref{fig:www-rinterface}.

\begin{figure}
\includegraphics[width=33in]{images/survival-kit/www-first} \caption{World wide web website}\label{fig:www-first}
\end{figure}

\begin{figure}
\includegraphics[width=32.78in]{images/survival-kit/www-rinterface} \caption{RinteRface website: https://rinterface.com}\label{fig:www-rinterface}
\end{figure}

How can we explain that difference? One of the main reason is the absence of CSS (Cascading Style Sheet) since the first CSS release only appeared in December 1996, that is 5 years later than the first web site publication. CSS allows to deeply customize the appearance of any web page by changing colors, fonts, margins and much more. We acknowledge, the role of JavaScript cannot be demonstrated through the previous example. Yet its impact is as important as CSS, so that it is now impossible to dissociate HTML, CSS and JavaScript.

\hypertarget{html-and-css}{%
\subsection{HTML and CSS}\label{html-and-css}}

CSS (Cascading Style Sheets) changes the style of HTML tags by targeting specific classes or ids. For instance, if we want all p tags to have red color we will use:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \{}
  \KeywordTok{color}\NormalTok{: }\DecValTok{red}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To include CSS in an HTML page, we use the \texttt{\textless{}style\textgreater{}} tag as follows:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
    \KeywordTok{<style}\OtherTok{ type=}\StringTok{"text/css"}\KeywordTok{>}
\NormalTok{      p \{}
        \KeywordTok{color}\NormalTok{: }\DecValTok{red}\NormalTok{;}
\NormalTok{      \}}
    \KeywordTok{</style>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
  \KeywordTok{<p>}\NormalTok{Hello World}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

You may update the hello-world.html script and run it in your web-browser to see the difference. The example may be slight, but shows how we may control the look and feel of the display. In a development context, we will see later that css files may so big that it is better to include them in external files.

\hypertarget{html-and-javascript}{%
\subsection{HTML and JavaScript}\label{html-and-javascript}}

You will see how quickly/seamlessly you may add awesome features to your shiny app.

Let's consider the following example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
    \KeywordTok{<style}\OtherTok{ type=}\StringTok{"text/css"}\KeywordTok{>}
\NormalTok{      p \{}
        \KeywordTok{color}\NormalTok{: }\DecValTok{red}\NormalTok{;}
\NormalTok{      \}}
    \KeywordTok{</style>}
    \KeywordTok{<script}\OtherTok{ language=}\StringTok{"javascript"}\KeywordTok{>}
      \CommentTok{// displays an alert }
      \AttributeTok{alert}\NormalTok{(}\StringTok{'Click on the Hello World text!'}\NormalTok{)}\OperatorTok{;}
      \CommentTok{// change text color}
      \KeywordTok{function} \AttributeTok{changeColor}\NormalTok{(color)}\OperatorTok{\{}
        \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{'hello'}\NormalTok{).}\VariableTok{style}\NormalTok{.}\AttributeTok{color} \OperatorTok{=} \StringTok{"green"}\OperatorTok{;}
      \OperatorTok{\}}
    \KeywordTok{</script>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \CommentTok{<!-- onclick attributes applies the JavaScript function changeColor define above -->}
    \KeywordTok{<p}\OtherTok{ id=}\StringTok{"hello"}\OtherTok{ onclick=}\StringTok{"changeColor('green')"}\KeywordTok{>}\NormalTok{Hello World}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

In few lines of code, you can change the color of the text. This is only the beginning!

Let's move to the next chapter to discover JavaScript!

\hypertarget{survival-kit-javascript}{%
\chapter{JavaScript}\label{survival-kit-javascript}}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

JavaScript (JS) was created in 1995 by Brendan Eich and is also known as ECMAScript (ES). Interestingly, you might have heard about ActionScript, which is no more than an implementation of ES by Adobe Systems. Nowadays, JavaScript is the centerpiece of web development across all websites.

Here is a quick example. If you have a personal blog, you probably know Hugo or Jekyll. These tools allow one to rapidly develop a professionnal looking (or at least not too ugly) blog in just a few minutes. This allows bloggers to focus on the content, which is really the point! Now, if you open the HTML inspector introduced in Chapter \ref{survival-kit-html}, click on the elements tab, which may open by default, and uncollapse the \texttt{\textless{}head\textgreater{}} tag, you see that a lot of scripts are included, as shown in Figure \ref{fig:scripts-list}. Similarly for the \texttt{\textless{}body\textgreater{}} tag.

\begin{figure}
\includegraphics[width=34.86in]{images/survival-kit/scripts-list} \caption{A website is full of JavaScript}\label{fig:scripts-list}
\end{figure}

There are 2 ways to include scripts:

\begin{itemize}
\tightlist
\item
  Use the \texttt{\textless{}script\textgreater{}} tag with the JS code inside
\item
  Add the \texttt{onclick} attribute to a button to trigger JS as soon as it is clicked (This is similar to event listeners, see below)
\item
  Import an external file containing the JS code and only
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<script}\OtherTok{ type=}\StringTok{"text/javascript"}\KeywordTok{>}
\CommentTok{// JS code here}
\KeywordTok{</script>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{<!-- We use the src attribute to link the external file -->}
\KeywordTok{<script}\OtherTok{ type=}\StringTok{"text/javascript"}\OtherTok{ src=}\StringTok{"file.js"}\KeywordTok{>}
\end{Highlighting}
\end{Shaded}

Whether to choose the first, second or third method depends on the content of your script. If we consider the JS library jQuery, it unfortunately contains so much code making it a challenge to understand. This often makes users avoid the first method.

\hypertarget{setup}{%
\section{Setup}\label{setup}}

Like R or Python, JavaScript (JS) is an interpreted language, executed client-side, in other words in the browser. This also means that JS code may not be run without a suitable tool.

\hypertarget{node}{%
\subsection{Node}\label{node}}

\href{https://nodejs.org/en/}{Node} contains an interpreter for JS as well as a dependencies manager, npm (Node Package Manager). To install Node on your computer, browse to the website and follow the installation instructions. Afterwards, open a terminal and check if

\begin{verbatim}
$ which node
$ node --version
\end{verbatim}

returns something. If not, Node may not be properly installed.

\hypertarget{choose-a-good-ide}{%
\subsection{Choose a good IDE}\label{choose-a-good-ide}}

Personally, I really like \href{https://code.visualstudio.com}{VSCode} for coding with JS, as it contains a Node interpreter allowing you to seamlessly execute any JS code. As a side note, I encourage you to try the dracula color theme, which is my favorite! Many also chose the \href{https://rstudio.com/products/rstudio/}{Rstudio IDE}, provided that you have Node installed. Below, we will see how to run a JS code in both IDE's.

\hypertarget{first-script}{%
\subsection{First Script}\label{first-script}}

Let's write our first script:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You notice that all instruction end by \texttt{;}. You can run this script either in Rstudio IDE or VSCode.

\begin{figure}
\includegraphics[width=29.61in]{images/survival-kit/script-vscode} \caption{Run JS in VSCode}\label{fig:script-vscode}
\end{figure}

In VSCode, clicking on the run arrow (top center) of Figure \ref{fig:script-vscode}, triggers the \texttt{node\ hello.js} command, which tells Node to run the script. We see the result in the right panel (code=0 means the execution is fine and we even have the compute time). To run this script in the RStudio IDE, one needs to click on the terminal tab (you could also open a basic terminal) and type \texttt{node\ hello.js} (or \texttt{node\ mycustompath/hello.js} if you are not in the folder containing the script). You should see the Hello World message in the console (see Figure \ref{fig:script-rstudio}).

\begin{figure}
\includegraphics[width=26.75in]{images/survival-kit/script-rstudio} \caption{Run JS in a terminal}\label{fig:script-rstudio}
\end{figure}

\hypertarget{programming-with-js-basis}{%
\section{Programming with JS: basis}\label{programming-with-js-basis}}

We are now all set to introduce the basis of JS. As many languages, JS is made of variables and instructions. All instructions end by the \texttt{;} symbol.

\hypertarget{js-types}{%
\subsection{JS types}\label{js-types}}

JS defines several types:

\begin{itemize}
\tightlist
\item
  Number: does not distinguish between integers and others (in R for instance, numeric contains integers and double)
\item
  String: characters (`blabla')
\item
  Boolean: true/false
\end{itemize}

To check the type of an element, we may use the \texttt{typeof} operator.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof} \DecValTok{1}\OperatorTok{;} \CommentTok{// number}
\KeywordTok{typeof} \StringTok{'pouic'}\OperatorTok{;} \CommentTok{// string}
\end{Highlighting}
\end{Shaded}

In JS, \texttt{typeof} is not a function like in R!!! Therefore don't write \texttt{typeof(\textquotesingle{}string\textquotesingle{});}.

\hypertarget{variables}{%
\subsection{Variables}\label{variables}}

Variables are key elements in programmation. They allow to store intermediate results and do other manipulations. In JS, a variable is defined by:

\begin{itemize}
\tightlist
\item
  a type
\item
  a name
\item
  a value
\end{itemize}

Valid variable names:

don't use an existing name like typeof

don't start with a number (123soleil)

don't include any space (total price)

Besides, code style is a critical element in programming, increasing readability, and general consistence. There are several styles, the main ones being \texttt{snake\_case} and \texttt{camelCase}. I personally use the camelCase syntax to write variables in JS. To set a variable we use \texttt{let} (there exists \texttt{var} but this is not the latest JS norm (ESMAScript 6 or ES6). You will see later that we still use \texttt{var} in the shiny core and many other R packages).

There are two ways to create variables in JavaScript.

\hypertarget{const}{%
\subsubsection{Const}\label{const}}

In JavaScript, a variable may be created with \texttt{const}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ n }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{n }\OperatorTok{=} \DecValTok{2}\OperatorTok{;} \CommentTok{// error}
\KeywordTok{const}\NormalTok{ n }\OperatorTok{=} \DecValTok{3}\OperatorTok{;} \CommentTok{// error}
\KeywordTok{const}\NormalTok{ a}\OperatorTok{;}
\NormalTok{a }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// errors}
\end{Highlighting}
\end{Shaded}

As shown above, such variables:

\begin{itemize}
\tightlist
\item
  Cannot be modified
\item
  Cannot share the same name
\item
  Must be assigned a value
\end{itemize}

\hypertarget{let}{%
\subsubsection{let}\label{let}}

Another way to define a variable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ myVariable }\OperatorTok{=} \StringTok{'welcome'}\OperatorTok{;}
\NormalTok{myVariable }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(myVariable)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Then we may use all mathematical operators to manipulate our variables.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ myNumber }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// affectation}
\NormalTok{myNumber}\OperatorTok{--;} \CommentTok{// decrement}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(myNumber)}\OperatorTok{;} \CommentTok{// print 0}
\end{Highlighting}
\end{Shaded}

List of numerical operators in JS:

+

-

*

/

\% (modulo)

++ (incrementation)

-- (decrementation)

To concatenate two strings, we use the\texttt{+} symbol.

You may also know \texttt{var} to declare variables. What is the difference with \texttt{let}? It is mainly a scope \href{https://www.w3schools.com/js/js_let.asp}{reason}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ i }\OperatorTok{=} \DecValTok{2}\OperatorTok{;} \CommentTok{// this will modify i globally, not locally}
\OperatorTok{\}}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VerbatimStringTok{`i is }\SpecialCharTok{$\{}\NormalTok{i}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}\OperatorTok{;} \CommentTok{// i is 2.}

\KeywordTok{let}\NormalTok{ j }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ j }\OperatorTok{=} \DecValTok{2}\OperatorTok{;} \CommentTok{// j is only declared locally and not globally!}
\OperatorTok{\}}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VerbatimStringTok{`j is }\SpecialCharTok{$\{}\NormalTok{j}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}\OperatorTok{;} \CommentTok{// j is 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{conditions}{%
\subsection{Conditions}\label{conditions}}

Below are the operators to check conditions.

== (A equal B)

!= (A not equal to B)

\textgreater{} (\textgreater{}=)

\textless{} (\textless{}=)

AND (A AND B)

OR (A OR B)

To test conditions there exists several ways:

\begin{itemize}
\tightlist
\item
  \texttt{if\ (condition)\ \{\ console.log(\textquotesingle{}Test\ passed\textquotesingle{});\ \}}
\item
  \texttt{if\ (condition)\ \{\ instruction\ A\}\ else\ \{\ instruction\ B\ \}}
\end{itemize}

This is very common to other languages (and R for instance). Whenever a lot of possible conditions need to be evaluated, it is better to choose the \texttt{switch}.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch}\NormalTok{ (variable) }\OperatorTok{\{}
  \ControlFlowTok{case} \DataTypeTok{val1}\OperatorTok{:} \CommentTok{// instruction 1}
  \ControlFlowTok{break}\OperatorTok{;} \CommentTok{// don't forget the break!}
  \ControlFlowTok{case} \DataTypeTok{val2}\OperatorTok{:}  \CommentTok{// instruction 2}
  \ControlFlowTok{break}\OperatorTok{;}
  \DataTypeTok{default}\OperatorTok{:} \CommentTok{// when none of val1 and val2 are satisfied}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{objects}{%
\subsection{Objects}\label{objects}}

JavaScript is an object oriented programming language (like Python). An object is defined by:

\begin{itemize}
\tightlist
\item
  a type
\item
  some properties
\item
  some methods (to manipulate properties)
\end{itemize}

Let's define our first object below:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ me }\OperatorTok{=} \OperatorTok{\{}
  \DataTypeTok{name }\OperatorTok{:} \StringTok{'Divad'}\OperatorTok{,}
  \DataTypeTok{age }\OperatorTok{:} \DecValTok{29}\OperatorTok{,}
  \DataTypeTok{music }\OperatorTok{:} \StringTok{''}\OperatorTok{,}
  \DataTypeTok{printName}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VerbatimStringTok{`I am }\SpecialCharTok{$\{}\KeywordTok{this}\NormalTok{.}\AttributeTok{name}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}

\VariableTok{me}\NormalTok{.}\AttributeTok{geek} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;} \CommentTok{// works (see const variables above)}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VariableTok{JSON}\NormalTok{.}\AttributeTok{stringify}\NormalTok{(me))}\OperatorTok{;} \CommentTok{// print a human readable object.}
  
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VariableTok{me}\NormalTok{.}\AttributeTok{name}\NormalTok{)}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VariableTok{me}\NormalTok{.}\AttributeTok{age}\NormalTok{)}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VariableTok{me}\NormalTok{.}\AttributeTok{music}\NormalTok{)}\OperatorTok{;}
\CommentTok{// don't repeat yourself!!!}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ key }\KeywordTok{in}\NormalTok{ me) }\OperatorTok{\{} \CommentTok{// here is it ok to use `in`}
 \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VerbatimStringTok{`me[}\SpecialCharTok{$\{}\NormalTok{key}\SpecialCharTok{\}}\VerbatimStringTok{] is }\SpecialCharTok{$\{}\NormalTok{me[key]}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}

\VariableTok{me}\NormalTok{.}\AttributeTok{printName}\NormalTok{()}\OperatorTok{;}

\NormalTok{me }\OperatorTok{=} \OperatorTok{\{}
  \DataTypeTok{name}\OperatorTok{:} \StringTok{'Paul'}\OperatorTok{,}
  \DataTypeTok{age}\OperatorTok{:} \DecValTok{40}
\OperatorTok{\}} \CommentTok{// error (see const variables above)}
\end{Highlighting}
\end{Shaded}

Some comments on the above code:

\begin{itemize}
\tightlist
\item
  to access an object propertie, we use \texttt{object.propertie}
\item
  to print a human readable version of the object \texttt{JSON.stringify} will do the job
\item
  we introduced string interpolation with \texttt{\$\{*\}}. \texttt{*} may be any valid expression.
\item
  methods are accessed like properties (we may also pass parameters). We use \texttt{this} to refer to the object itself. Take note, we will see it a lot!
\end{itemize}

In JavaScript, we can find already predefined objects to interact with arrays, dates.

\hypertarget{arrays}{%
\subsubsection{Arrays}\label{arrays}}

An array is a structure allowing to store informations for instance

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ table }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\OperatorTok{,} \StringTok{'plop'}\NormalTok{]}\OperatorTok{;}
\VariableTok{table}\NormalTok{.}\AttributeTok{push}\NormalTok{(}\StringTok{'hello'}\NormalTok{)}\OperatorTok{;}
\NormalTok{table }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{]}\OperatorTok{;} \CommentTok{// error (as explain in above in the variable part)}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(table)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Array may be nested

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ nested }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\OperatorTok{,}\NormalTok{ [}\StringTok{'a'}\OperatorTok{,}\NormalTok{ [}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{]]}\OperatorTok{,} \StringTok{'plop'}\NormalTok{]}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(nested)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In arrays, elements may be accessed by their index, but as mentionned before, the first index is 0 (not 1 like in R). A convenient way to print all arrays's elements is to use an iteration:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ nested }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\OperatorTok{,}\NormalTok{ [}\StringTok{'a'}\OperatorTok{,}\NormalTok{ [}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{]]}\OperatorTok{,} \StringTok{'plop'}\NormalTok{]}\OperatorTok{;}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i of nested) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(i)}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// or with the classic approach}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{<} \VariableTok{nested}\NormalTok{.}\AttributeTok{length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(nested[i])}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Note that the \texttt{length} method returns the size of an array and is very convenient in for loops. Below is a table referencing the principal methods for arrays (we will use some of them later)

\begin{longtable}[]{@{}cc@{}}
\toprule
Method/Property & Description\tabularnewline
\midrule
\endhead
length & Return the number of elements in an array\tabularnewline
Join(string separator) & Transform an array in a string\tabularnewline
concat(array1, array2) & Assemble 2 arrays\tabularnewline
pop() & Remove the last element of an array\tabularnewline
shift() & Remove the first element of an array\tabularnewline
unshift(el1, el2, \ldots{}) & Insert elements at the beginning of an array\tabularnewline
push(el1, el2, \ldots{}) & Add extra elements at the end of an array\tabularnewline
sort() & Sort array elements by increasing value of alphabetical order\tabularnewline
reverse() & Symetric of sort()\tabularnewline
\bottomrule
\end{longtable}

Quite honestly, we mainly use \texttt{push} and \texttt{length} in the next chapters.

\hypertarget{strings}{%
\subsubsection{Strings}\label{strings}}

Below are the main methods related to the String object (character in R)

\begin{longtable}[]{@{}cc@{}}
\toprule
Method/Property/Operator & Description\tabularnewline
\midrule
\endhead
+ (operator) & String concatenation\tabularnewline
length & String length\tabularnewline
indexOf() & Gives the position of the character following the input string\tabularnewline
toLowerCase() & Put the string in small letters\tabularnewline
toUpperCase() & Put the string in capital letters\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{math}{%
\subsubsection{Math}\label{math}}

Below we mention some useful methods to handle mathematical objects

\begin{longtable}[]{@{}cc@{}}
\toprule
Method & Description\tabularnewline
\midrule
\endhead
parseInt() & Convert a string to integer\tabularnewline
parseFloat() & Conversion to floating number\tabularnewline
\bottomrule
\end{longtable}

All classic functions like \texttt{sqrt}, trigonometric functions are of course available. We call them with the \texttt{Math.*} prefix.

\hypertarget{iterations}{%
\subsection{Iterations}\label{iterations}}

Iterations allow to repeat an instruction or a set of instructions multiple times. Let's assume we have an array containing 100000 random numbers. How would you do to automatically print them? This a what we are going to see below!

\hypertarget{for-loops}{%
\subsubsection{For loops}\label{for-loops}}

The for loop has multiple uses. Below is a classic case where we start by defining the index (variable). We then set an upper bound (the array length) and we finish by incrementing the index value. The code between curly braces is then executed.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ table }\OperatorTok{=}\NormalTok{ [...}\AttributeTok{Array}\NormalTok{(}\DecValTok{100}\NormalTok{).}\AttributeTok{keys}\NormalTok{()]}\OperatorTok{;} \CommentTok{// create an empty array of length 100 (so from 0 to 99, not from 1 to 100 like in R!!!)}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{<} \VariableTok{table}\NormalTok{.}\AttributeTok{length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) }\OperatorTok{\{}
    \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(table[i])}\OperatorTok{;} 
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The way we created the array is a bit special and deserves some explanations:

\begin{itemize}
\tightlist
\item
  \texttt{Array} is a method to define a new array. We call it this way \texttt{Array(arrayLength)} since we don't want to write 100 values 1 by 1. But if you try \texttt{console.log(Array(10));} you will get \texttt{{[}\ \textless{}10\ empty\ items\textgreater{}\ {]}}, meaning that 10 slots are available but nothing is inside yet.
\item
  \texttt{keys} defines keys for each table index. As a reminder, since \texttt{Array(10)} is an object (check with \texttt{console.log(typeof\ Array(10));}) we may use \texttt{Array(10).keys()}. This creates an Array Iterator
\item
  \texttt{...} is a \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax}{spread syntax}, and is called with an iterable object (see above)
\end{itemize}

NOTE: Contrary to R, JavaScript index starts from 0 (not from 1)! This is good to keep in mind when we will mix both R and JS.

Let's have a look at the \texttt{forEach} method for arrays (introduced in ES5):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ letters }\OperatorTok{=}\NormalTok{ [}\StringTok{"a"}\OperatorTok{,} \StringTok{"b"}\OperatorTok{,} \StringTok{"c"}\OperatorTok{,} \StringTok{"d"}\NormalTok{]}\OperatorTok{;}
\VariableTok{letters}\NormalTok{.}\AttributeTok{forEach}\NormalTok{((letter) }\OperatorTok{=>} \OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(letter)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Below is another way to create a for loop (introduced in ES6):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ samples }\OperatorTok{=}\NormalTok{ [}\StringTok{'blabla'}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \KeywordTok{null}\NormalTok{]}\OperatorTok{;} \CommentTok{// this is an array!}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ sample of samples) }\OperatorTok{\{}
 \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(sample)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

What loop \texttt{for} loop should we use? The answer is: it depends on the situation! Actually, there even exists other ways (replace \texttt{of} by \texttt{in} and you get the indexes of the array, like with the first code, but this is really \href{https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/}{not recommended}).

\hypertarget{other-iterations-while}{%
\subsubsection{Other iterations: while}\label{other-iterations-while}}

While loops are another way to iterate, as long as the condition defined is TRUE. The incrementation step is done at the end of the instruction.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ h }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{while}\NormalTok{ (i }\OperatorTok{<=}\NormalTok{ h) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(i)}\OperatorTok{;}
\NormalTok{  i}\OperatorTok{++;} \CommentTok{// we need to increment to avoid infinite loop}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{functions}{%
\subsection{Functions}\label{functions}}

Functions are useful to wrap a succession of instructions to accomplish a given task. Defining functions allows programmers to save time (less copy and paste, less search and replace), make less errors and easily share code. In modern JavaScript (ES6), functions are defined as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ a }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fun }\OperatorTok{=}\NormalTok{ (parm1}\OperatorTok{,}\NormalTok{ parm2) }\OperatorTok{=>} \OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(a)}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ p }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
  \ControlFlowTok{return} \VariableTok{Math}\NormalTok{.}\AttributeTok{max}\NormalTok{(parm1}\OperatorTok{,}\NormalTok{ parm2)}\OperatorTok{;} \CommentTok{// I use the Math object that contains the max method}
\OperatorTok{\}}
\KeywordTok{let}\NormalTok{ res }\OperatorTok{=} \AttributeTok{fun}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(res)}\OperatorTok{;} \CommentTok{// prints a and 2. a global}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(p)}\OperatorTok{;} \CommentTok{// fails because p was defined inside the function}
\end{Highlighting}
\end{Shaded}

This above functions computes the maximum of 2 provided numbers. Some comments about scoping rules: variables defined inside the function are available for the function, but are not available outside the function definition. It should be noted that functions may use global variables defined outside of it.

\hypertarget{export-functions-about-modules}{%
\subsubsection{Export functions: about modules}\label{export-functions-about-modules}}

What happens if you wrote 100 functions that you want to reuse in different scripts? To prevent copying and pasting, we will now introduce the concept of modules. Let's save the below function in a script \texttt{utils.js}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ findMax }\OperatorTok{=}\NormalTok{ (parm1}\OperatorTok{,}\NormalTok{ parm2) }\OperatorTok{=>} \OperatorTok{\{}
  \ControlFlowTok{return} \VariableTok{Math}\NormalTok{.}\AttributeTok{max}\NormalTok{(parm1}\OperatorTok{,}\NormalTok{ parm2)}\OperatorTok{;} \CommentTok{// I use the Math object that contains the max method}
\OperatorTok{\}}

\VariableTok{module}\NormalTok{.}\AttributeTok{exports} \OperatorTok{=} \OperatorTok{\{}
\NormalTok{  findMax }\OperatorTok{=}\NormalTok{ findMax}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Let's create a \texttt{test.js} script in the same folder that uses the \texttt{findMax} function. To do this, we need to import the corresponding module:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \OperatorTok{\{}\NormalTok{findMax}\OperatorTok{\}} \OperatorTok{=} \AttributeTok{require}\NormalTok{(}\StringTok{'./utils.js'}\NormalTok{)}\OperatorTok{;}
\AttributeTok{findMax}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;} \CommentTok{// prints 2}
\end{Highlighting}
\end{Shaded}

In the next chapters, we will see that some of the underlying JS code to build custom shiny inputs share the same utils functions. Therefore, introducing modules is necessary.

\hypertarget{event-listeners}{%
\subsection{Event listeners}\label{event-listeners}}

When you explore a web application, clicking on a button usually triggers something like a computation, a modal or an alert. How does this work?
In JavaScript, interactivity plays a critical role. Indeed, you want the web application to react to user inputs like mouse clicks, keyboard events. Below we introduce DOM events.

Let's consider a basic HTML button.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<button}\OtherTok{ id=}\StringTok{"mybutton"}\KeywordTok{>}\NormalTok{Go!}\KeywordTok{</button>}
\end{Highlighting}
\end{Shaded}

On the JavaScript side, we first capture the button element using its id selector (\texttt{getElementById}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ btn }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{'mybutton'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We then apply the \texttt{addEventListener} method. In short, an event listener is a program that triggers when a given event occurs (we can add multiple event listeners per HTML element). It takes 2 main parameters:

\begin{itemize}
\tightlist
\item
  the event: click, change, mouseover, \ldots{}
\item
  the function to call
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{btn}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \AttributeTok{alert}\NormalTok{(}\StringTok{'Thanks!'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We could compare the JavaScript events to Shiny observeEvent in which we are listenning to a specific user input.

\hypertarget{jquery}{%
\section{jQuery}\label{jquery}}

\hypertarget{introduction-1}{%
\subsection{Introduction}\label{introduction-1}}

\href{https://jquery.com}{jQuery} is a famous JavaScript library providing a user friendly interface to manipulate the DOM and is present in almost all actual websites. It is slightly easier (understand more convenient to use) than vanilla JS, even though web developers tend to avoid it to go back to vanilla JS (Bootstrap 5, the next iteration of Bootstrap will not rely on jQuery anymore). To use jQuery in a webpage, we must include its code either by dowloading the code and putting the minified JS file in our HTML or setting a link to a CDN.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!doctype }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
\KeywordTok{<head>}
  \KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"utf-8"}\KeywordTok{>}
  \KeywordTok{<title>}\NormalTok{Including jQuery}\KeywordTok{</title>}
  \CommentTok{<!-- How to include jQuery -->}
  \KeywordTok{<script}\OtherTok{ src=}\StringTok{"https://code.jquery.com/jquery-3.5.0.js"}\KeywordTok{></script>}
\KeywordTok{</head>}
\KeywordTok{<body>}
 
\KeywordTok{<p>}\NormalTok{Hello World}\KeywordTok{</p>}

 
\KeywordTok{<script>}
\AttributeTok{$}\NormalTok{(}\StringTok{'p'}\NormalTok{).}\AttributeTok{css}\NormalTok{(}\StringTok{'color'}\OperatorTok{,} \StringTok{'red'}\NormalTok{)}\OperatorTok{;}
\KeywordTok{</script>}
 
\KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

\hypertarget{syntax}{%
\subsection{Syntax}\label{syntax}}

Below is a minimal jQuery code representing its philosophy (``write less, do more.''):

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(selector).}\AttributeTok{action}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The selector slot stands for any jQuery selector like class, id, element, {[}attribute{]}, :input (will select all input elements) and many \href{https://www.w3schools.com/jquery/jquery_ref_selectors.asp}{more}. As a reminder, let's consider the following example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<p}\OtherTok{ class=}\StringTok{"text"}\KeywordTok{>}\NormalTok{Hello World}\KeywordTok{</p>}
\end{Highlighting}
\end{Shaded}

To select and interact with this element, we use JavaScript and jQuery:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ inner }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementsByClassName}\NormalTok{(}\StringTok{'text'}\NormalTok{).}\AttributeTok{innerHTML}\OperatorTok{;} \CommentTok{// vanilla JS}
\KeywordTok{let}\NormalTok{ inner }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'.text'}\NormalTok{).}\AttributeTok{html}\NormalTok{()}\OperatorTok{;} \CommentTok{// jQuery}
\end{Highlighting}
\end{Shaded}

This is of course possible to chain selectors

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<ul}\OtherTok{ class=}\StringTok{"list"}\KeywordTok{>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{1}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{2}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{3}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\OtherTok{ id=}\StringTok{"precious-item"}\KeywordTok{>}\NormalTok{4}\KeywordTok{</li>}
\KeywordTok{</ul>}

\KeywordTok{<ul}\OtherTok{ class=}\StringTok{"list"}\OtherTok{ id=}\StringTok{"list2"}\KeywordTok{>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{1}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{2}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{3}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{4}\KeywordTok{</li>}
\KeywordTok{</ul>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ items }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'.list .item'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will return an array containing 8 li tags}
\KeywordTok{let}\NormalTok{ otherItems }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#list2 .item'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will select only li tags from the second ul element}
\KeywordTok{let}\NormalTok{ lists }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'ul'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will return an array with 2 ul elements}
\KeywordTok{let}\NormalTok{ firstItem }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#list2:first-child'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will return the first li element of the second ul.}
\end{Highlighting}
\end{Shaded}

jQuery is obviously simpler than pure JavaScript.

\hypertarget{useful-functions}{%
\subsection{Useful functions}\label{useful-functions}}

There exist filtering functions dedicated to simplify item \href{https://api.jquery.com/category/traversing/}{selection}. We gathered the one mostly used in Shiny below.

\hypertarget{travel-in-the-dom}{%
\subsubsection{Travel in the DOM}\label{travel-in-the-dom}}

\begin{longtable}[]{@{}cc@{}}
\toprule
\begin{minipage}[b]{0.42\columnwidth}\centering
Method\strut
\end{minipage} & \begin{minipage}[b]{0.52\columnwidth}\centering
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.42\columnwidth}\centering
children()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get the children of each element passed in the selector (important: only travels a single level down the DOM tree)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
first()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Given an list of elements, select the first item\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
last()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Given an list of elements, select the last item\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
find()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Look for a descendant of the selected element(s) that could be multiple levels down in the DOM\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
closest()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Returns the first ancestor matching the condition (travels up in the DOM)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
filter()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Fine tune element selection by applying a filter. Only return element for which the condition is true\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
siblings()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get all siblings of the selected element(s)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
next()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get the immediately following sibling\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
prev()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get the immediately preceding sibling\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
not()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Given an existing set of selected elements, remove element(s) that match the given condition\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{manipulate-tags}{%
\subsubsection{Manipulate tags}\label{manipulate-tags}}

Below is a list of the main jQuery \href{https://api.jquery.com/category/manipulation/}{methods} to manipulate tags (adding class, css property\ldots{})

\begin{longtable}[]{@{}cc@{}}
\toprule
\begin{minipage}[b]{0.42\columnwidth}\centering
Method\strut
\end{minipage} & \begin{minipage}[b]{0.52\columnwidth}\centering
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.42\columnwidth}\centering
addClass()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Add class or multiple classes to the set of matched elements\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
hasClass()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Check if the matched element(s) have a given class\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
removeClass()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Remove class or multiple classes to the set of matched elements\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
attr()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get or set the value of a specific attribute\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
after()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Insert content after\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
before ()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Insert content before\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
css()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get or set a css property\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
remove()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Remove element(s) from the DOM\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
val()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get the current value of the matched element(s)\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

TO DO: add more methods

\hypertarget{chaining-jquery-methods}{%
\subsection{Chaining jQuery methods}\label{chaining-jquery-methods}}

A lot of jQuery methods may be chained, that is like pipe operations in R.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<ul>}
  \KeywordTok{<li>}\NormalTok{Item 1}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 2}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 3}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 4}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 5}\KeywordTok{</li>}
\KeywordTok{</ul>}
\end{Highlighting}
\end{Shaded}

We end the chain by \texttt{;} and each step is indent by 2 spaces in the right direction.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\StringTok{'ul'}\NormalTok{)}
\NormalTok{  .}\AttributeTok{first}\NormalTok{()}
\NormalTok{  .}\AttributeTok{css}\NormalTok{(}\StringTok{'color'}\OperatorTok{,} \StringTok{'green'}\NormalTok{) }\CommentTok{// add some style with css}
\NormalTok{  .}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\OperatorTok{,} \StringTok{'myAwesomeItem'}\NormalTok{) }\CommentTok{// add an id attribute}
\NormalTok{  .}\AttributeTok{addClass}\NormalTok{(}\StringTok{'amazing-ul'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{iterations-1}{%
\subsection{Iterations}\label{iterations-1}}

Like in vanilla JavaScript, it is possible to do iterations in jQuery. Let's consider the following HTML elements.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<ul>}
  \KeywordTok{<li>}\NormalTok{Item 1}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 2}\KeywordTok{</li>}
\KeywordTok{</ul>}
\end{Highlighting}
\end{Shaded}

We apply the \texttt{each} method to change the style of each matched element step by step.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\StringTok{'li'}\NormalTok{).}\AttributeTok{each}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(}\KeywordTok{this}\NormalTok{).}\AttributeTok{css}\NormalTok{(}\StringTok{'visibility'}\OperatorTok{,} \StringTok{'hidden'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will hide all li items}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{map} methods has a different purpose. It creates a new object based on the provided one.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ items }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\NormalTok{]}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ threshold }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}

\KeywordTok{let}\NormalTok{ filteredItems }\OperatorTok{=} \VariableTok{$}\NormalTok{.}\AttributeTok{map}\NormalTok{(items}\OperatorTok{,} \KeywordTok{function}\NormalTok{(i) }\OperatorTok{\{}
  \CommentTok{// removes all items > threshold}
  \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{>}\NormalTok{ threshold) }
    \ControlFlowTok{return} \KeywordTok{null}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ i}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{good-practice}{%
\subsection{Good practice}\label{good-practice}}

It is recommended to wrap any jQuery code as follows:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{ready}\NormalTok{(}\KeywordTok{function}\NormalTok{()}\OperatorTok{\{}
  \CommentTok{// your code}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// or a shortcut}

\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// your code}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Indeed, do you guess what would happen if you try to modify an element that does not even exist? The code above will make sure that the document is ready before starting any jQuery manipulation.

\hypertarget{events}{%
\subsection{Events}\label{events}}

In jQuery there exists a significant number methods related to events. Below are the most popular:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{click}\NormalTok{()}\OperatorTok{;} \CommentTok{// click event}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{change}\NormalTok{()}\OperatorTok{;} \CommentTok{// trigger change on an element}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
 \CommentTok{// whatever}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;} \CommentTok{// attach an event handler function. Here we add click for the example}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{one}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
 \CommentTok{// whatever}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;} \CommentTok{// the difference with on is that one will trigger only once}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{resize}\NormalTok{()}\OperatorTok{;} \CommentTok{// useful to trigger plot resize in Shiny so that they correctly fit their container}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{trigger}\NormalTok{(}\StringTok{'change'}\NormalTok{) }\CommentTok{// similar to $(element).change(); You will find it in the Shiny core.}
\end{Highlighting}
\end{Shaded}

The \texttt{.on} event is frequently used in Shiny since it allows to pass custom events which are not part of the JS prefined events. For instance shinydashboard relies on a specific HTML/JavaScript/CSS template including a homemade API for handling the dashboard events. Don't worry if this section is not clear at the moment. We will see practical examples in the following chapters.

\hypertarget{extending-objects}{%
\subsection{Extending objects}\label{extending-objects}}

A last feature we need to mention about jQuery is the ability to extend objects with additional properties and/or method.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// jQuery way}
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ object1 }\OperatorTok{=} \OperatorTok{\{}
    \DataTypeTok{apple}\OperatorTok{:} \DecValTok{0}
  \OperatorTok{\};}
  \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(object1}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{print}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
      \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\KeywordTok{this}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \VariableTok{object1}\NormalTok{.}\AttributeTok{print}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

With vanilla JS we would use \texttt{Object.defineProperty}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// pure JavaScript}
\VariableTok{Object}\NormalTok{.}\AttributeTok{defineProperty}\NormalTok{(object1}\OperatorTok{,} \StringTok{'print'}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{value}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\KeywordTok{this}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{writable}\OperatorTok{:} \KeywordTok{false}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{part-shiny-whats-under-the-hood}{%
\part*{Shiny: What's under the Hood?}\label{part-shiny-whats-under-the-hood}}
\addcontentsline{toc}{part}{Shiny: What's under the Hood?}

\hypertarget{shiny-intro}{%
\chapter{Introduction}\label{shiny-intro}}

\hypertarget{shiny-html-css-and-javascript}{%
\section{Shiny, HTML, CSS and JavaScript}\label{shiny-html-css-and-javascript}}

In the book prerequisites, to get the most out of this book, it was recommended that the reader should be quite familiar with Shiny. In the two previous chapters, we quickly introduced HTML and JavaScript. However, in this chapter, we are going to see what Shiny has under the hood.

Shiny allows the development of web applications with R in minutes. Let's face it: this is quite mind blowing! While this may not be a production ready app, it will still be a fully functional, working prototype. Believe me, doing a web application with pure HTML/CSS and JavaScript is more difficult, especially for someone with a non-web developer background.

Is Shiny less customizable than a classic web app? Not at all! Indeed, Shiny has its own engine to build HTML tags, through R, meaning that all HTML elements are available. You may also include any custom \href{https://shiny.rstudio.com/articles/packaging-javascript.html}{JavaScript} or \href{https://mastering-shiny.org/advanced-ui.html}{CSS} code.

Do you remember about the first exercise in Chapter \ref{survival-kit-html}?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{p} function generates HTML (see chapter \ref{htmltools-overview}). The main difference between HTML tags and Shiny tags is the absence of closing tag for Shiny. For instance, in raw HTML, we expect \texttt{\textless{}p\textgreater{}} to be closed by \texttt{\textless{}/p\textgreater{}}. In Shiny, we only call \texttt{p(...)}, where \texttt{...} may be attributes like class/id or children tags.

In this chapter, we will answer to the following questions:

\begin{itemize}
\tightlist
\item
  What web dependencies is Shiny based on?
\item
  How is R/JavaScript communication achieved?
\item
  How does Shiny deal with inputs?
\end{itemize}

In Chapter \ref{htmltools-dependencies} we will explore tools to manage HTML dependencies. In Chapter \ref{insert-tabs}, we will see a special case to insert dependencies during the app runtime. Finally, in the last part of this book, we will be designing custom inputs and knowing how to debug them is priceless.

\hypertarget{shiny-websocket}{%
\section{Websocket: R/JS bidirectional communication}\label{shiny-websocket}}

How does R (server) and JavaScript (client) communicate? This is a builtin Shiny feature highlighted \href{https://github.com/rstudio/shiny}{here}, which leverages the \href{https://github.com/rstudio/httpuv}{httpuv} and \href{https://github.com/rstudio/websocket}{websocket} packages. Before going further let's define what is a websocket! It is an advanced technology allowing bidirectional communication between a client and a server. For instance, a chat system may be built on top of a websocket. In the following, we will show how to inspect the websocket in a web browser. Let's run the following app (see \ref{fig:shiny-websocket}, left panel)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{fluidPage}\NormalTok{(}
    \KeywordTok{selectInput}\NormalTok{(}\StringTok{"variable"}\NormalTok{, }\StringTok{"Variable:"}\NormalTok{,}
                \KeywordTok{c}\NormalTok{(}\StringTok{"Cylinders"}\NormalTok{ =}\StringTok{ "cyl"}\NormalTok{,}
                  \StringTok{"Transmission"}\NormalTok{ =}\StringTok{ "am"}\NormalTok{,}
                  \StringTok{"Gears"}\NormalTok{ =}\StringTok{ "gear"}\NormalTok{)),}
    \KeywordTok{tableOutput}\NormalTok{(}\StringTok{"data"}\NormalTok{)}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{    output}\OperatorTok{$}\NormalTok{data <-}\StringTok{ }\KeywordTok{renderTable}\NormalTok{(\{}
\NormalTok{      mtcars[, }\KeywordTok{c}\NormalTok{(}\StringTok{"mpg"}\NormalTok{, input}\OperatorTok{$}\NormalTok{variable), drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{    \}, }\DataTypeTok{rownames =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

After opening the HTML inspector, we select the network tab and search for websocket in the list. By choosing the message tab, you may inspect what R and JavaScript say to each others. On the JavaScript side, the websocket is created in the shinyapp.js \href{https://github.com/rstudio/shiny/blob/master/srcjs/shinyapp.js}{file}. The first element received from R is the first message in the list shown in Figure \ref{fig:shiny-websocket}. It is a JSON object containing the method used as well as passed data. In the meantime, you may change the select input value.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{socket}\NormalTok{.}\AttributeTok{send}\NormalTok{(}\VariableTok{JSON}\NormalTok{.}\AttributeTok{stringify}\NormalTok{(}\OperatorTok{\{}
  \DataTypeTok{method}\OperatorTok{:} \StringTok{'init'}\OperatorTok{,}
  \DataTypeTok{data}\OperatorTok{:} \VariableTok{self}\NormalTok{.}\AttributeTok{$initialInput}
\OperatorTok{\}}\NormalTok{))}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The second message received from R is after updating the select input.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{this}\NormalTok{.}\AttributeTok{sendInput} \OperatorTok{=} \KeywordTok{function}\NormalTok{(values) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ msg }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{stringify}\NormalTok{(}\OperatorTok{\{}
    \DataTypeTok{method}\OperatorTok{:} \StringTok{'update'}\OperatorTok{,}
    \DataTypeTok{data}\OperatorTok{:}\NormalTok{ values}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// other things}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Although complex, it is extremely useful to check whether the input / output communication are working properly. If not, we would see the error field identifying the issue.

Finally, \texttt{Shiny.shinyapp.\$socket.readyState} returns the state of the socket connection. It should be 1 if your app is running. In some instances when the socket is closed, nothing would be shown. Note that the R option \texttt{options(shiny.trace\ =\ TRUE)} allows the websocket messages to be displayed directly in the R console.

\begin{figure}
\includegraphics[width=27.69in]{images/survival-kit/shiny-websocket} \caption{Shiny websocket}\label{fig:shiny-websocket}
\end{figure}

\hypertarget{shiny-session}{%
\section{The Shiny session object}\label{shiny-session}}

We won't be able to go anywhere without giving some reminders about the Shiny \href{https://shiny.rstudio.com/reference/shiny/1.4.0/session.html}{session} object. Why do we say object? \texttt{session} is actually an instance of the \href{https://github.com/rstudio/shiny/blob/master/R/shiny.R}{\texttt{ShinySession}} R6 class.
The initialization takes one parameter, namely the websocket. As shown in the last section, the websocket allows bidirectional exchanges between R and JS. Understanding how R and JS communicate allows us to discuss the Shiny input system.

\begin{itemize}
\tightlist
\item
  \texttt{sendCustomMessage} sends messages from R to JS. It calls the private \texttt{sendMessage} method which itself calls \texttt{write}. The message is sent only when the session is opened, throught the websocket \texttt{private\$websocket\$send(json)}. If the \texttt{shiny.trace} \href{https://shiny.rstudio.com/reference/shiny/0.14/shiny-options.html}{option} is TRUE, a message showing the sent JSON is displayed, which is useful for debugging.
\item
  \texttt{sendInputMessage} is used to update inputs from the server
\end{itemize}

The below code is extracted from the \texttt{shiny.R} \href{https://github.com/rstudio/shiny/blob/master/R/shiny.R}{file}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sendCustomMessage =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(type, message) \{}
\NormalTok{  data <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{  data[[type]] <-}\StringTok{ }\NormalTok{message}
\NormalTok{  private}\OperatorTok{$}\KeywordTok{sendMessage}\NormalTok{(}\DataTypeTok{custom =}\NormalTok{ data)}
\NormalTok{\}}

\NormalTok{sendInputMessage =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, message) \{}
\NormalTok{  data <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{message =}\NormalTok{ message)}
  
  \CommentTok{# Add to input message queue}
\NormalTok{  private}\OperatorTok{$}\NormalTok{inputMessageQueue[[}\KeywordTok{length}\NormalTok{(private}\OperatorTok{$}\NormalTok{inputMessageQueue) }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\NormalTok{data}
  \CommentTok{# Needed so that Shiny knows to actually flush the input message queue}
\NormalTok{  self}\OperatorTok{$}\KeywordTok{requestFlush}\NormalTok{()}
\NormalTok{\}}


\NormalTok{sendMessage =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \CommentTok{# This function is a wrapper for $write}
\NormalTok{  msg <-}\StringTok{ }\KeywordTok{list}\NormalTok{(...)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{anyUnnamed}\NormalTok{(msg)) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"All arguments to sendMessage must be named."}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{  private}\OperatorTok{$}\KeywordTok{write}\NormalTok{(}\KeywordTok{toJSON}\NormalTok{(msg))}
\NormalTok{\}}


\NormalTok{write =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(json) \{}
  \ControlFlowTok{if}\NormalTok{ (self}\OperatorTok{$}\NormalTok{closed)\{}
    \KeywordTok{return}\NormalTok{()}
\NormalTok{  \}}
\NormalTok{  traceOption <-}\StringTok{ }\KeywordTok{getOption}\NormalTok{(}\StringTok{'shiny.trace'}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{isTRUE}\NormalTok{(traceOption) }\OperatorTok{||}\StringTok{ }\NormalTok{traceOption }\OperatorTok{==}\StringTok{ "send"}\NormalTok{)}
    \KeywordTok{message}\NormalTok{(}\StringTok{'SEND '}\NormalTok{,}
            \KeywordTok{gsub}\NormalTok{(}\StringTok{'(?m)base64,[a-zA-Z0-9+/=]+'}\NormalTok{,}\StringTok{'[base64 data]'}\NormalTok{,json,}\DataTypeTok{perl=}\OtherTok{TRUE}\NormalTok{))}
\NormalTok{  private}\OperatorTok{$}\NormalTok{websocket}\OperatorTok{$}\KeywordTok{send}\NormalTok{(json)}
\NormalTok{\}}
\CommentTok{# ...}
\end{Highlighting}
\end{Shaded}

No worry if it is not clear at the moment. We will discuss those elements in the following sections.

\hypertarget{shiny-input-system}{%
\chapter{Shiny's input system}\label{shiny-input-system}}

Shiny inputs are key elements of Shiny apps since they are a way for the end-user to interact with the app. You may know \texttt{sliderInput}, \texttt{numericInput}, \texttt{checkboxInput} but sometimes you may need fancier elements like \texttt{knobInput} from \href{https://github.com/dreamRs/shinyWidgets/blob/master/R/input-knob.R}{shinyWidgets}, as depicted on Figure \ref{fig:fancy-inputs} or even more sofisticated inputs like the \texttt{smartSelect} of \href{https://github.com/RinteRface/shinyMobile/blob/master/R/f7-inputs.R}{shinyMobile} (Figure \ref{fig:fancy-inputs}, right panel). Have you ever wondered what are the mechanisms behind inputs? Have you ever dreamt to develop your own?

The goal of this section is to understand how Shiny inputs work.

\begin{figure}
\includegraphics[width=0.5\linewidth]{images/survival-kit/jquery-knobs} \includegraphics[width=0.5\linewidth]{images/survival-kit/smart-select} \caption{Custom shiny inputs. left: knobInput from shinyWidgets; right: smart select from shinyMobile}\label{fig:fancy-inputs}
\end{figure}

\hypertarget{shiny-javascript-sources}{%
\section{Shiny JavaScript sources}\label{shiny-javascript-sources}}

The Shiny input system relies on the Shiny JavaScript sources. They are located in the srcjs folder shown in Figure \ref{fig:shiny-js-sources}.

\begin{figure}
\includegraphics[width=32.08in]{images/survival-kit/shiny-js-sources} \caption{Shiny JavaScript sources}\label{fig:shiny-js-sources}
\end{figure}

Notice the \texttt{\_start.js} and \texttt{\_end.js}. These will be used by the \texttt{Gruntfile.js}, that is a \href{https://gruntjs.com}{grunt-based} tool to run different tasks such as concatenate multiple JavaScript files, lint the code, minify it \ldots{} See \href{https://github.com/rstudio/shiny/tree/master/tools}{here} for a summary.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{grunt}\NormalTok{.}\AttributeTok{registerTask}\NormalTok{(}\StringTok{'default'}\OperatorTok{,}\NormalTok{ [}
  \StringTok{'concat'}\OperatorTok{,}
  \StringTok{'string-replace'}\OperatorTok{,}
  \StringTok{'validateStringReplace'}\OperatorTok{,}
  \StringTok{'eslint'}\OperatorTok{,}
  \StringTok{'configureBabel'}\OperatorTok{,}
  \StringTok{'babel'}\OperatorTok{,}
  \StringTok{'uglify'}
\NormalTok{])}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

These results in a large big \href{https://github.com/rstudio/shiny/blob/master/inst/www/shared/shiny.js}{file} and its minified \href{https://github.com/rstudio/shiny/blob/master/inst/www/shared/shiny.min.js}{version} in the \texttt{shiny/inst/www/shared} folder.

\hypertarget{the-shiny-javascript-object}{%
\section{The Shiny JavaScript object}\label{the-shiny-javascript-object}}

The \texttt{Shiny} object is exported at the top of the \texttt{shiny.js} file \footnote{Refer to Chapter \ref{survival-kit-javascript} if you don't remember how to export an object and make it available to all JS files.}. In other words, this means that we may use this object and any of its properties within the HTML inspector console tab, in any JavaScript file or shiny app as below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      console.log(Shiny);}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

This object contains many properties and methods as shown in Figure \ref{fig:shiny-object}. Some of particular interest, such as like \texttt{Shiny.setInputValue}, \texttt{Shiny.addCustomMessageHandler}, \texttt{Shiny.shinyapps}, \texttt{Shiny.bindAll}, \ldots{} will be detailed later

\begin{figure}
\includegraphics[width=17.44in]{images/survival-kit/shiny-object} \caption{The Shiny JavaScript object}\label{fig:shiny-object}
\end{figure}

\hypertarget{initialization}{%
\section{Initialization}\label{initialization}}

When we run our app, most of the time it works just fine! The question is, how are the inputs and outputs handeled correctly to allow this to happen? Upon initialization, Shiny runs several JavaScript functions. Not surprisingly, there is one called \href{https://github.com/rstudio/shiny/blob/master/srcjs/init_shiny.js}{\texttt{init\_shiny}} containing a subtantial number of elements such as \texttt{bindInputs} and \texttt{unbindInputs} to bind/unbind inputs. Besides, they are accessible to the programmer (see a usecase \href{https://stackoverflow.com/questions/51633326/dateinput-not-working-on-dt-in-shiny}{here}). To illustrate what they do, let's run the app below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
              \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{  ),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

We then open the HTML inspector and run \texttt{Shiny.unbindAll(document)} (document is the scope, that is where to search). Try to change the slider input. You will notice that nothing happens. Now let's type \texttt{Shiny.bindAll(document)} and update the slider value. Moving the slider successfuly update the plot. Magic isn't it? This simply shows that when inputs are not bound, nothing happens so binding inputs is necessary.

Let's see below what is an input binding and how it works.

\hypertarget{input-bindings}{%
\section{Input bindings}\label{input-bindings}}

\hypertarget{input-structure}{%
\subsection{Input structure}\label{input-structure}}

An input element is given by the \texttt{\textless{}input\textgreater{}} tag as well as several attributes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<input}\OtherTok{ id} \OtherTok{=} \StringTok{inputId}\OtherTok{ type} \OtherTok{=} \StringTok{"text"}\OtherTok{ class} \OtherTok{=} \StringTok{"input-text"}\OtherTok{ value} \OtherTok{=} \StringTok{value}\KeywordTok{>}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  id garantees the input uniquess. We will see very soon that all instances of the same input share a unique input binding, therefore id is mandatory.
\item
  \href{https://www.w3schools.com/tags/att_input_type.asp}{type}
\item
  class is targeted by CSS and JavaScript
\item
  value holds the input value
\end{itemize}

\hypertarget{binding-shiny-inputs}{%
\subsection{Binding Shiny inputs}\label{binding-shiny-inputs}}

An input binding allows Shiny to identify each instance of a given input and what you may do with this input. For instance, a slider input must update whenever the range is dragged or when the left and right arrows of the keyboard are pressed. It relies on a class defined in the \texttt{input\_binding.js} \href{https://github.com/rstudio/shiny/blob/master/srcjs/input_binding.js}{file}.

Let's describe each method chronologically.

\hypertarget{find-the-input}{%
\subsubsection{Find the input}\label{find-the-input}}

The first step, is critical which is to locate the input in the DOM. On the R side, we define an input, with a specific attribute that will serve as a receptor for the binding. For most of inputs, this may be handled by the type attribute. In other cases, this may be the class, like for the \texttt{actionButton}. On the JS side, we need a method that will indentify this receptor. Moreover, two different types of inputs (for instance \texttt{radioButton} and \texttt{selectInput}) cannot have the same receptor for conflict reasons, whereas two instances of the same input type can (if your app contains 10 sliders, they all share the same input binding!). The receptor identifier is provided by the \texttt{find} method of the \texttt{InputBinding} class. This method must be applied on a scope, that is the \texttt{document}. \texttt{find} accepts any valid jQuery selector. Figure \ref{fig:shiny-find-inputs} summarizes this important step.

\begin{figure}
\includegraphics[width=20in]{images/survival-kit/shiny-find-inputs} \caption{How to find inputs?}\label{fig:shiny-find-inputs}
\end{figure}

Below, we are going to create a new binding for the \texttt{textInput}, with only two methods mentionned in the previous section, that is \texttt{find} and \texttt{getValue}. For that, we need to create a customized textInput, \texttt{customTextInput} to make it unique. We now add the \texttt{input-text} class and make our own input binding pointing to that specific class.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{customTextInput <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (inputId, label, }\DataTypeTok{value =} \StringTok{""}\NormalTok{, }\DataTypeTok{width =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{placeholder =} \OtherTok{NULL}\NormalTok{) \{}
  
  \CommentTok{# this external wrapper ensure to control the input width}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"form-group shiny-input-container"}\NormalTok{, }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) \{}
      \KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, }\KeywordTok{validateCssUnit}\NormalTok{(width), }\StringTok{";"}\NormalTok{)}
\NormalTok{    \},}
    \CommentTok{# input label}
\NormalTok{    shiny}\OperatorTok{:::}\KeywordTok{shinyInputLabel}\NormalTok{(inputId, label), }
    
    \CommentTok{# input element}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{input}\NormalTok{(}
      \DataTypeTok{id =}\NormalTok{ inputId, }
      \DataTypeTok{type =} \StringTok{"text"}\NormalTok{, }
      \DataTypeTok{class =} \StringTok{"form-control input-text"}\NormalTok{, }
      \DataTypeTok{value =}\NormalTok{ value,}
      \DataTypeTok{placeholder =}\NormalTok{ placeholder}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Figure \ref{fig:text-input} shows the main elements of the \texttt{textInput} widget. In the above code, \texttt{shinyInputLabel} is a Shiny internal function that creates the numeric input label, or in other word the text displayed next to it. The core input element is wrapped by \texttt{tags\$input}. No worry if the structure seems unclear, we will give more details about shiny tags in the next chapter.

\begin{figure}
\includegraphics[width=9.72in]{images/survival-kit/text-input} \caption{Shiny's textInput elements}\label{fig:text-input}
\end{figure}

We put everything in a Shiny app and invit the reader to open the HTML inspector and look at the \texttt{console.log} result.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      // Input binding}
\StringTok{      let customTextBinding = new Shiny.InputBinding();}

\StringTok{      $.extend(customTextBinding, \{}
\StringTok{        find: function(scope) \{}
\StringTok{          console.log($(scope).find('.input-text'));}
\StringTok{          return $(scope).find('.input-text');}
\StringTok{        \}}
\StringTok{      \});}
\StringTok{      }
\StringTok{      Shiny.inputBindings.register(customTextBinding, 'text');}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{customTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\StringTok{"Caption"}\NormalTok{, }\StringTok{"Data Summary"}\NormalTok{),}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"customText"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{customText <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(input}\OperatorTok{$}\NormalTok{caption)}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Results are shown on Figure \ref{fig:shiny-find-inputs-result}. If the corresponding input is found, you should see the corresponding tag element in the HTML inspector console.

\begin{figure}
\includegraphics[width=35.81in]{images/survival-kit/shiny-find-inputs-result} \caption{find method output}\label{fig:shiny-find-inputs-result}
\end{figure}

\hypertarget{initialize-inputs}{%
\subsubsection{Initialize inputs}\label{initialize-inputs}}

Upon initialization, Shiny calls the \texttt{initializeInputs} function that takes all input bindings and call their \texttt{initialize} method before binding all inputs. Note that once an input has been initialized it has a \texttt{\_shiny\_initialized} tag to avoid initializing it twice. The initialize method is not always defined but some elements require to be explicitly initialized or activated. For instance the \href{https://framework7.io}{Framework7} API, on top of which \href{https://github.com/RinteRface/shinyMobile}{shinyMobile} is built, require to instantiate all elements. Below is an example for the \href{https://framework7.io/docs/toggle.html}{toggle} input:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// what is expected}
\KeywordTok{let}\NormalTok{ toggle }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{toggle}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}
  \DataTypeTok{el}\OperatorTok{:} \StringTok{'.toggle'}\OperatorTok{,}
  \DataTypeTok{on}\OperatorTok{:} \OperatorTok{\{}
    \DataTypeTok{change}\OperatorTok{:} \KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
      \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{'Toggle changed'}\NormalTok{)}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{el:\ \textquotesingle{}.toggle\textquotesingle{}} means that we are looking at the element(s) having the \texttt{toggle} class. \texttt{app.toggle.create} is internal to the Framework7 API. The corresponding shinyMobile input binding starts as follows.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ f7ToggleBinding }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{InputBinding}\NormalTok{()}\OperatorTok{;}
  \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(f7ToggleBinding}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{initialize}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
      \VariableTok{app}\NormalTok{.}\VariableTok{toggle}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}\DataTypeTok{el}\OperatorTok{:}\NormalTok{ el}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \CommentTok{// other methods}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Once initialized, we may use all specific methods provided by the API. \href{https://framework7.io}{Framework7} is clearly a gold mine, as its API provides many possible options for many inputs / widgets. Later in this section, we will demonstrate how to initialize a box element from the \href{https://adminlte.io/docs/2.4/js-box-widget}{AdminLTE2} HTML template.

\hypertarget{get-the-value}{%
\subsubsection{Get the value}\label{get-the-value}}

\texttt{getValue(el)} returns the input value. The way to obtain the value is different for almost all inputs. For instance, the \texttt{textInput} is pretty simple since the value is located in the \texttt{value} attribute. \texttt{el} refers to the element holding the id attribute and recognized by the \texttt{find} method. Figure \ref{fig:shiny-el} shows the result of a \texttt{console.log(\$(el));}.

\begin{figure}
\includegraphics[width=35.5in]{images/survival-kit/shiny-el} \caption{About el}\label{fig:shiny-el}
\end{figure}

To get the value, we apply the jQuery method \texttt{val} on the \texttt{\$(el)} element and return the result.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      // Input binding}
\StringTok{      let customTextBinding = new Shiny.InputBinding();}

\StringTok{      $.extend(customTextBinding, \{}
\StringTok{        find: function(scope) \{}
\StringTok{          return $(scope).find('.input-text');}
\StringTok{        \},}
\StringTok{        // Given the DOM element for the input, return the value}
\StringTok{        getValue: function(el) \{}
\StringTok{          console.log($(el));}
\StringTok{          return $(el).val();}
\StringTok{        \}}
\StringTok{      \});}
\StringTok{      }
\StringTok{      Shiny.inputBindings.register(customTextBinding, 'text');}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{customTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\StringTok{"Caption"}\NormalTok{, }\StringTok{"Data Summary"}\NormalTok{),}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"customText"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{customText <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(input}\OperatorTok{$}\NormalTok{caption)}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

This time, the input value is returned. Notice that when you try to change the text content, the output value does not update as we would normally expect. We are actually missing a couple of methods so that the binding is fully working. We will introduce them in the following sections!

\hypertarget{set-and-update}{%
\subsubsection{Set and update}\label{set-and-update}}

\texttt{setValue(el,\ value)} is used to set the value of the current input. This method is necessary so that the input value may be updated. It has to be used in combination with \texttt{receiveMessage(el,\ data)}, which is the JavaScript part of all the R \texttt{updateInput} functions. We usually call the \texttt{setValue} method inside.

Let's create a function to update our custom text input. Call it \texttt{updateCustomTextInput}. It requires at least 3 parameters:

\begin{itemize}
\tightlist
\item
  inputId tells which input to update.
\item
  value is the new value. This will be taken by the \texttt{setValue} JS method in the input binding
\item
  session is the Shiny session object mentionned earlier. We will use the \texttt{sendInputMessage} to send values from R to JavaScript. The \texttt{receiveMessage} method will apply \texttt{setValue} with the data received from R
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{updateCustomTextInput <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, }\DataTypeTok{value =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, }\DataTypeTok{message =}\NormalTok{ value)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We add \texttt{setValue} and \texttt{receiveMessage} to custom input binding:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      // Input binding}
\StringTok{      let customTextBinding = new Shiny.InputBinding();}

\StringTok{      $.extend(customTextBinding, \{}
\StringTok{        find: function(scope) \{}
\StringTok{          return $(scope).find('.input-text');}
\StringTok{        \},}
\StringTok{        // Given the DOM element for the input, return the value}
\StringTok{        getValue: function(el) \{}
\StringTok{          return $(el).val();}
\StringTok{        \},}
\StringTok{        setValue: function(el, value) \{}
\StringTok{          $(el).val(value);}
\StringTok{        \},}
\StringTok{        receiveMessage: function(el, data) \{}
\StringTok{          console.log(data);}
\StringTok{          this.setValue(el, data);}
\StringTok{        \}}
\StringTok{      \});}
\StringTok{      }
\StringTok{      Shiny.inputBindings.register(customTextBinding, 'text');}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{customTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\StringTok{"Caption"}\NormalTok{, }\StringTok{"Data Summary"}\NormalTok{),}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Update text!"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"btn-success"}\NormalTok{),}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"customText"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{customText <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(input}\OperatorTok{$}\NormalTok{caption)}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
    \KeywordTok{updateCustomTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\DataTypeTok{value =} \StringTok{"new text"}\NormalTok{)}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Figure \ref{fig:shiny-update-inputs} illustrates the main mechanisms.

\begin{figure}
\includegraphics[width=20in]{images/survival-kit/shiny-update-inputs} \caption{Events following a click on the update button. This figure demonstrates how R and JS communicate, through the websocket.}\label{fig:shiny-update-inputs}
\end{figure}

If we have to pass multiple elements to update, we would have to change the \texttt{updateCustomTextInput} function such as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{updateCustomTextInput <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, }\DataTypeTok{value =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{placeholder =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  message <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{:::}\KeywordTok{dropNulls}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{value =}\NormalTok{ value,}
      \DataTypeTok{placeholder =}\NormalTok{ placeholder}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{dropNulls} is an internal function ensuring that the list does not contain NULL elements. On the JS side, we would have to update the \texttt{receiveMessage} method. We send a list from R, which is then serialized to a JSON object. Properties like \texttt{value} may be accessed using the . notation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(data)}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{data}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{'value'}\NormalTok{)) }\OperatorTok{\{}
    \KeywordTok{this}\NormalTok{.}\AttributeTok{setValue}\NormalTok{(el}\OperatorTok{,} \VariableTok{data}\NormalTok{.}\AttributeTok{value}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
  \CommentTok{// other parameters to update...}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

So far so good! We managed to update the text input value. Yet, the output value does not change. We are going to fix this missing step in the next section.

\hypertarget{subscribe}{%
\subsubsection{Subscribe}\label{subscribe}}

\texttt{subscribe(el,\ callback)} listens to events defining Shiny to update the input value and make it available in the app. Some API like Bootstrap explicitly mention those events (like \texttt{hide.bs.tab}, \texttt{shown.bs.tab}, \ldots{}).
Going back to our custom text input, what event would make it change?

\begin{itemize}
\tightlist
\item
  After a key is release on the keyboard. We may listen to \texttt{keyup}
\item
  After copying and pasting any text in the input field or dictating text. The \texttt{input} event may be helpful
\end{itemize}

We may add those \href{https://javascript.info/events-change-input}{events} to our binding using an event listener seen at the end of Chapter \ref{survival-kit-javascript}.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'keyup.customTextBinding input.customTextBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
\AttributeTok{callback}\NormalTok{(}\KeywordTok{true}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{callback} ensures that the new value is captured by Shiny. We will come back later on the callback parameter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      // Input binding}
\StringTok{      let customTextBinding = new Shiny.InputBinding();}

\StringTok{      $.extend(customTextBinding, \{}
\StringTok{        find: function(scope) \{}
\StringTok{          return $(scope).find('.input-text');}
\StringTok{        \},}
\StringTok{        // Given the DOM element for the input, return the value}
\StringTok{        getValue: function(el) \{}
\StringTok{          return $(el).val();}
\StringTok{        \},}
\StringTok{        setValue: function(el, value) \{}
\StringTok{          $(el).val(value);}
\StringTok{        \},}
\StringTok{        receiveMessage: function(el, data) \{}
\StringTok{          if (data.hasOwnProperty('value')) \{}
\StringTok{            this.setValue(el, data.value);}
\StringTok{            $(el).trigger('change');}
\StringTok{          \}}
\StringTok{        \},}
\StringTok{        subscribe: function(el, callback) \{}
\StringTok{          $(el).on('keyup.customTextBinding input.customTextBinding', function(event) \{}
\StringTok{            console.log(event);}
\StringTok{            callback();}
\StringTok{          \});}
\StringTok{        \}}
\StringTok{      \});}
\StringTok{      }
\StringTok{      Shiny.inputBindings.register(customTextBinding, 'text');}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{customTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\StringTok{"Caption"}\NormalTok{, }\StringTok{"Data Summary"}\NormalTok{),}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Update text!"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"btn-success"}\NormalTok{),}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"customText"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{customText <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(input}\OperatorTok{$}\NormalTok{caption)}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
    \KeywordTok{updateCustomTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\DataTypeTok{value =} \StringTok{"new text"}\NormalTok{)}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Hooray! The output result is successfully changed when the input value is manually updated. However, nothing happens when we click on the update button. What did we miss? Looking back at the \texttt{receiveMessage} method, we changed the input value but how does Shiny knows that this step was successful? To check that no event is raised, we put a \texttt{console.log(event);} in the \texttt{subscribe} method. Any action like removing the text content or adding new text triggers event but clicking on the action button does not. Therefore, we must trigger an event and add it to the \texttt{subscribe} method. We may choose the \texttt{change} event, that triggers when an element is updated.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'change.customTextBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \AttributeTok{callback}\NormalTok{(}\KeywordTok{false}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Let's try again.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      // Input binding}
\StringTok{      let customTextBinding = new Shiny.InputBinding();}

\StringTok{      $.extend(customTextBinding, \{}
\StringTok{        find: function(scope) \{}
\StringTok{          return $(scope).find('.input-text');}
\StringTok{        \},}
\StringTok{        // Given the DOM element for the input, return the value}
\StringTok{        getValue: function(el) \{}
\StringTok{          return $(el).val();}
\StringTok{        \},}
\StringTok{        setValue: function(el, value) \{}
\StringTok{          $(el).val(value);}
\StringTok{        \},}
\StringTok{        receiveMessage: function(el, data) \{}
\StringTok{          if (data.hasOwnProperty('value')) \{}
\StringTok{            this.setValue(el, data.value);}
\StringTok{            $(el).trigger('change');}
\StringTok{          \}}
\StringTok{        \},}
\StringTok{        subscribe: function(el, callback) \{}
\StringTok{          $(el).on('keyup.customTextBinding input.textInputBinding', function(event) \{}
\StringTok{            callback();}
\StringTok{          \});}

\StringTok{          $(el).on('change.customTextBinding', function(event) \{}
\StringTok{            callback(false);}
\StringTok{          \});}
\StringTok{        \}}
\StringTok{      \});}
\StringTok{      }
\StringTok{      Shiny.inputBindings.register(customTextBinding, 'text');}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{customTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\StringTok{"Caption"}\NormalTok{, }\StringTok{"Data Summary"}\NormalTok{),}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Update text!"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"btn-success"}\NormalTok{),}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"customText"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{customText <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(input}\OperatorTok{$}\NormalTok{caption)}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
    \KeywordTok{updateCustomTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\DataTypeTok{value =} \StringTok{"new text"}\NormalTok{)}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Perfect? Not exactly. It would be better to only change the input value once the keyboard is completely released for some time (and not each time a key is released). This is what we call debouncing, which allows a delay before telling Shiny to read the new value, and is achieved using the \texttt{getRatePolicy} method. Additionally, we must also pass \texttt{true} to the \texttt{callback} in the subscribe method, in order to apply our specific rate policy (\href{https://davidwalsh.name/javascript-debounce-function}{debounce}, throttle). This is useful for instance when we don't want to flood the server with useless update requests. For example when using a slider, we only want to send the value as soon as the range stops moving and not all intermediate values. Those elements are defined \href{https://github.com/rstudio/shiny/blob/master/srcjs/input_rate.js}{here}.

Run the app below and try to manually change the text input value by adding a couple of letters as fast as you can. What do you notice? We see the output value only updates when we release the keyboard.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      // Input binding}
\StringTok{      let customTextBinding = new Shiny.InputBinding();}

\StringTok{      $.extend(customTextBinding, \{}
\StringTok{        find: function(scope) \{}
\StringTok{          return $(scope).find('.input-text');}
\StringTok{        \},}
\StringTok{        // Given the DOM element for the input, return the value}
\StringTok{        getValue: function(el) \{}
\StringTok{          return $(el).val();}
\StringTok{        \},}
\StringTok{        setValue: function(el, value) \{}
\StringTok{          $(el).val(value);}
\StringTok{        \},}
\StringTok{        receiveMessage: function(el, data) \{}
\StringTok{          if (data.hasOwnProperty('value')) \{}
\StringTok{            this.setValue(el, data.value);}
\StringTok{            $(el).trigger('change');}
\StringTok{          \}}
\StringTok{        \},}
\StringTok{        subscribe: function(el, callback) \{}
\StringTok{          $(el).on('keyup.customTextBinding input.textInputBinding', function(event) \{}
\StringTok{            callback(true);}
\StringTok{          \});}

\StringTok{          $(el).on('change.customTextBinding', function(event) \{}
\StringTok{            callback();}
\StringTok{          \});}
\StringTok{        \},}
\StringTok{        getRatePolicy: function() \{}
\StringTok{          return \{}
\StringTok{            policy: 'debounce',}
\StringTok{            delay: 250}
\StringTok{          \};}
\StringTok{        \},}
\StringTok{        unsubscribe: function(el) \{}
\StringTok{          $(el).off('.customTextBinding');}
\StringTok{        \}}
\StringTok{      \});}
\StringTok{      }
\StringTok{      Shiny.inputBindings.register(customTextBinding, 'text');}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{customTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\StringTok{"Caption"}\NormalTok{, }\StringTok{"Data Summary"}\NormalTok{),}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Update text!"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"btn-success"}\NormalTok{),}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"customText"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{customText <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(input}\OperatorTok{$}\NormalTok{caption)}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
    \KeywordTok{updateCustomTextInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\DataTypeTok{value =} \StringTok{"new text"}\NormalTok{)}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

You may adjust the delay according to your needs, but we caution to not set the delay too long as this becomes problematic too.

\hypertarget{register-an-input-binding}{%
\subsubsection{Register an input binding}\label{register-an-input-binding}}

At the end of the input binding definition, we register it for Shiny.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ myBinding }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{inputBinding}\NormalTok{()}\OperatorTok{;}
  \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(myBinding}\OperatorTok{,} \OperatorTok{\{}
  \CommentTok{// methods go here}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\VariableTok{Shiny}\NormalTok{.}\VariableTok{inputBindings}\NormalTok{.}\AttributeTok{register}\NormalTok{(myBinding}\OperatorTok{,} \StringTok{'reference'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Although the Shiny \href{https://shiny.rstudio.com/articles/building-inputs.html}{documentation} mentions a \texttt{Shiny.inputBindings.setPriority} method to handle conflicting bindings, this case almost never happens.

\hypertarget{binding-other-elements}{%
\subsection{Binding other elements}\label{binding-other-elements}}

The Shiny input binding system is too convenient to be only used it for input elements. In shinydashboard, you may know the \texttt{box} function. Boxes are containers with a title, body, footer, as well as optional elements. It would be nice to capture the state of the box in an input, so as to trigger other actions as soon as this input changes. Since an input value is unique, we must add an inputId parameter to the box function:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"%OR%"}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(a)) a }\ControlFlowTok{else}\NormalTok{ b}

\NormalTok{box2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (..., }\DataTypeTok{inputId =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{footer =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{solidHeader =} \OtherTok{FALSE}\NormalTok{, }
                 \DataTypeTok{background =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{height =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{collapsible =} \OtherTok{FALSE}\NormalTok{, }
                 \DataTypeTok{collapsed =} \OtherTok{FALSE}\NormalTok{) }
\NormalTok{\{}
\NormalTok{  boxClass <-}\StringTok{ "box"}
  \ControlFlowTok{if}\NormalTok{ (solidHeader }\OperatorTok{||}\StringTok{ }\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(background)) \{}
\NormalTok{    boxClass <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(boxClass, }\StringTok{"box-solid"}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
\NormalTok{    boxClass <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(boxClass, }\StringTok{" box-"}\NormalTok{, status)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (collapsible }\OperatorTok{&&}\StringTok{ }\NormalTok{collapsed) \{}
\NormalTok{    boxClass <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(boxClass, }\StringTok{"collapsed-box"}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(background)) \{}
\NormalTok{    boxClass <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(boxClass, }\StringTok{" bg-"}\NormalTok{, background)}
\NormalTok{  \}}
\NormalTok{  style <-}\StringTok{ }\OtherTok{NULL}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(height)) \{}
\NormalTok{    style <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"height: "}\NormalTok{, }\KeywordTok{validateCssUnit}\NormalTok{(height))}
\NormalTok{  \}}
\NormalTok{  titleTag <-}\StringTok{ }\OtherTok{NULL}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) \{}
\NormalTok{    titleTag <-}\StringTok{ }\KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"box-title"}\NormalTok{, title)}
\NormalTok{  \}}
\NormalTok{  collapseTag <-}\StringTok{ }\OtherTok{NULL}
  \ControlFlowTok{if}\NormalTok{ (collapsible) \{}
\NormalTok{    buttonStatus <-}\StringTok{ }\NormalTok{status }\OperatorTok{%OR%}\StringTok{ "default"}
\NormalTok{    collapseIcon <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (collapsed) }
      \StringTok{"plus"}
    \ControlFlowTok{else} \StringTok{"minus"}
\NormalTok{    collapseTag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"box-tools pull-right"}\NormalTok{, tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"btn btn-box-tool"}\NormalTok{), }
                                                                   \StringTok{`}\DataTypeTok{data-widget}\StringTok{`}\NormalTok{ =}\StringTok{ "collapse"}\NormalTok{, shiny}\OperatorTok{::}\KeywordTok{icon}\NormalTok{(collapseIcon)))}
\NormalTok{  \}}
\NormalTok{  headerTag <-}\StringTok{ }\OtherTok{NULL}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(titleTag) }\OperatorTok{||}\StringTok{ }\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(collapseTag)) \{}
\NormalTok{    headerTag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"box-header"}\NormalTok{, titleTag, collapseTag)}
\NormalTok{  \}}
  
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{"col-sm-"}\NormalTok{, width), }
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{id =}\NormalTok{ inputId, }
      \DataTypeTok{class =}\NormalTok{ boxClass, }
      \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(style)) }
\NormalTok{        style, }
\NormalTok{      headerTag, }
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"box-body"}\NormalTok{, ...),}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(footer)) }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"box-footer"}\NormalTok{, footer)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Since we may collapse and uncollapse the box, we create the \texttt{updateBox} function, which will toggle it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{updateBox <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, }\DataTypeTok{message =} \OtherTok{NULL}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When collapsed, a box gets the \texttt{collapsed-box} class. Note: this will be useful for the input binding. As mentionned above, it is also necessary to know when to tell Shiny to update the value with the \texttt{subscribe} method. Most of the time, the change event might be sufficient, but as shinydashboard is built on top of \href{https://adminlte.io/docs/2.4/js-box-widget}{AdminLTE2}, it has an API to control the box behaviour. We identify 2 events corresponding to the collapsible action:

\begin{itemize}
\tightlist
\item
  expanded.boxwidget (Triggered after the box is expanded)
\item
  collapsed.boxwidget (Triggered after the box is collapsed)
\end{itemize}

Unfortunatly, after further investigations, those events are not possible to use since the AdminLTE code does not trigger them in the main JS \href{https://github.com/rstudio/shinydashboard/blob/master/srcjs/AdminLTE/app.js}{code} (see the collapse method line 577-612). There are other solutions, as shown below with the \texttt{click} event.

There is also a plug and play \texttt{toggleBox} method. To unleash the power of our box, we need to activate it with \texttt{\$(\textquotesingle{}\#\textless{}box\_id\textgreater{}\textquotesingle{}).activateBox();} before the binding step. If you remember, the \texttt{initialize} method is exactly doing this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ boxBinding }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{InputBinding}\NormalTok{()}\OperatorTok{;}
\VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(boxBinding}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{initialize}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{activateBox}\NormalTok{()}\OperatorTok{;} \CommentTok{// box activation}
  \OperatorTok{\},}
  \DataTypeTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
    \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{'.box'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
    \KeywordTok{let}\NormalTok{ isCollapsed }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{hasClass}\NormalTok{(}\StringTok{'collapsed-box'}\NormalTok{)}
    \ControlFlowTok{return} \OperatorTok{\{}\DataTypeTok{collapsed}\OperatorTok{:}\NormalTok{ isCollapsed}\OperatorTok{\};} \CommentTok{// this will be a list in R}
  \OperatorTok{\},}
  \DataTypeTok{setValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ value) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{toggleBox}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\},} 
  \DataTypeTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
    \KeywordTok{this}\NormalTok{.}\AttributeTok{setValue}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{trigger}\NormalTok{(}\StringTok{'change'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \StringTok{'[data-widget="collapse"]'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
      \AttributeTok{setTimeout}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
        \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\},} \DecValTok{550}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;} 
    
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'change'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
      \AttributeTok{setTimeout}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
        \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\},} \DecValTok{550}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{unsubscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{off}\NormalTok{(}\StringTok{'.boxBinding'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\VariableTok{Shiny}\NormalTok{.}\VariableTok{inputBindings}\NormalTok{.}\AttributeTok{register}\NormalTok{(boxBinding}\OperatorTok{,} \StringTok{'box-input'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Some comments about the binding:

\begin{itemize}
\tightlist
\item
  \texttt{getValue} returns an object which will give a list in R. This is in case we add other elements like the remove action available in AdminLTE
\item
  \texttt{setValue} calls the plug and play \texttt{toggleBox} method
\item
  \texttt{receiveMessage} must trigger a change event so that Shiny knows when the value needs to be updated
\item
  \texttt{subscribe} listens to the \texttt{click} event on the \texttt{{[}data-widget="collapse"{]}} element and delays the \texttt{callback} call by a value which is slightly higher than the default AdminLTE2 animation to collapse the box (500mx). If you omit this part, the input will not have time to properly update!!!
\item
  We don't need an extra listener for the \texttt{updateBox} function since it also triggers a click on the collapse button, thereby forwarding to the corresponding listener
\end{itemize}

Let's try our new toy in a simple dashboard:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{dashboardPage}\NormalTok{(}
    \KeywordTok{dashboardHeader}\NormalTok{(),}
    \KeywordTok{dashboardSidebar}\NormalTok{(),}
    \KeywordTok{dashboardBody}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
        \StringTok{"$(function() \{}
\StringTok{          let boxBinding = new Shiny.InputBinding();}
\StringTok{          $.extend(boxBinding, \{}
\StringTok{            initialize: function(el) \{}
\StringTok{              $(el).activateBox();}
\StringTok{            \},}
\StringTok{            find: function(scope) \{}
\StringTok{              return $(scope).find('.box');}
\StringTok{            \},}
\StringTok{            getValue: function(el) \{}
\StringTok{              let isCollapsed = $(el).hasClass('collapsed-box');}
\StringTok{              return \{collapsed: isCollapsed\}; // this will be a list in R}
\StringTok{            \},}
\StringTok{            setValue: function(el, value) \{}
\StringTok{              $(el).toggleBox();}
\StringTok{            \}, }
\StringTok{            receiveMessage: function(el, data) \{}
\StringTok{              this.setValue(el, data);}
\StringTok{              $(el).trigger('change');}
\StringTok{            \},}
\StringTok{            subscribe: function(el, callback) \{}
\StringTok{              $(el).on('click', '[data-widget=}\CharTok{\textbackslash{}"}\StringTok{collapse}\CharTok{\textbackslash{}"}\StringTok{]', function(event) \{}
\StringTok{                setTimeout(function() \{}
\StringTok{                  callback();}
\StringTok{                \}, 550);}
\StringTok{              \}); }
\StringTok{              $(el).on('change', function(event) \{}
\StringTok{                setTimeout(function() \{}
\StringTok{                  callback();}
\StringTok{                \}, 550);}
\StringTok{              \});}
\StringTok{            \},}
\StringTok{            unsubscribe: function(el) \{}
\StringTok{              $(el).off('.boxBinding');}
\StringTok{            \}}
\StringTok{          \});}
\StringTok{          }
\StringTok{          Shiny.inputBindings.register(boxBinding, 'box-input');}
\StringTok{        \});}
\StringTok{        "}
\NormalTok{      ),}
      
      \KeywordTok{box2}\NormalTok{(}
        \DataTypeTok{title =} \KeywordTok{textOutput}\NormalTok{(}\StringTok{"box_state"}\NormalTok{),}
        \StringTok{"Box body"}\NormalTok{,}
        \DataTypeTok{inputId =} \StringTok{"mybox"}\NormalTok{,}
        \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
        \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"plot"}\NormalTok{)}
\NormalTok{      ),}
      \KeywordTok{actionButton}\NormalTok{(}\StringTok{"toggle_box"}\NormalTok{, }\StringTok{"Toggle Box"}\NormalTok{)}
\NormalTok{    ),}
    \DataTypeTok{title =} \StringTok{"Dashboard example"}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{}
    
\NormalTok{    output}\OperatorTok{$}\NormalTok{plot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
      \KeywordTok{req}\NormalTok{(}\OperatorTok{!}\NormalTok{input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed)}
      \KeywordTok{plot}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{200}\NormalTok{))}
\NormalTok{    \})}
    
\NormalTok{    output}\OperatorTok{$}\NormalTok{box_state <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(\{}
\NormalTok{      state <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed) }\StringTok{"collapsed"} \ControlFlowTok{else} \StringTok{"uncollapsed"}
      \KeywordTok{paste}\NormalTok{(}\StringTok{"My box is"}\NormalTok{, state)}
\NormalTok{    \})}
    
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{toggle_box, \{}
      \KeywordTok{updateBox}\NormalTok{(}\StringTok{"mybox"}\NormalTok{)}
\NormalTok{    \})}
    
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{utilities-to-quickly-define-new-inputs}{%
\section{Utilities to quickly define new inputs}\label{utilities-to-quickly-define-new-inputs}}

If you ever wondered where the \texttt{Shiny.onInputChange} or \texttt{Shiny.setInputValue} comes from (see \href{https://shiny.rstudio.com/articles/communicating-with-js.html}{article}), it is actually defined in the \texttt{initShiny} function.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{exports}\NormalTok{.}\AttributeTok{setInputValue} \OperatorTok{=} \VariableTok{exports}\NormalTok{.}\AttributeTok{onInputChange} \OperatorTok{=} \KeywordTok{function}\NormalTok{(name}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ opts) }\OperatorTok{\{}
\NormalTok{  opts }\OperatorTok{=} \AttributeTok{addDefaultInputOpts}\NormalTok{(opts)}\OperatorTok{;}
  \VariableTok{inputs}\NormalTok{.}\AttributeTok{setInput}\NormalTok{(name}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ opts)}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Briefly, this function avoids creating an input binding. It is faster to code but there is a price to pay: losing the ability to easily update the new input. Indeed, all input functions like \texttt{sliderInput} have their own update function like \texttt{updateSliderInput}, because of the custom input binding system (We will see it very soon)!

\hypertarget{miscellaneous}{%
\section{Miscellaneous}\label{miscellaneous}}

We present some tools that may be useful\ldots{}TO FINISH

\hypertarget{get-access-to-initial-values}{%
\subsection{Get access to initial values}\label{get-access-to-initial-values}}

Something we may notice when exploring the \texttt{initShiny} function is the existence of a \texttt{Shiny.shinyapp} object, defined as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ shinyapp }\OperatorTok{=} \VariableTok{exports}\NormalTok{.}\AttributeTok{shinyapp} \OperatorTok{=} \KeywordTok{new} \AttributeTok{ShinyApp}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Let's explore what \texttt{shinyApp} contains. The definition is located in the shinyapps.js \href{https://github.com/rstudio/shiny/blob/master/srcjs/shinyapp.js}{script}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ ShinyApp }\OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$socket} \OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
  
  \CommentTok{// Cached input values}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$inputValues} \OperatorTok{=} \OperatorTok{\{\};}
  
  \CommentTok{// Input values at initialization (and reconnect)}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$initialInput} \OperatorTok{=} \OperatorTok{\{\};}
  
  \CommentTok{// Output bindings}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$bindings} \OperatorTok{=} \OperatorTok{\{\};}
  
  \CommentTok{// Cached values/errors}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$values} \OperatorTok{=} \OperatorTok{\{\};}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$errors} \OperatorTok{=} \OperatorTok{\{\};}
  
  \CommentTok{// Conditional bindings (show/hide element based on expression)}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$conditionals} \OperatorTok{=} \OperatorTok{\{\};}
  
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$pendingMessages} \OperatorTok{=}\NormalTok{ []}\OperatorTok{;}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$activeRequests} \OperatorTok{=} \OperatorTok{\{\};}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$nextRequestId} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}
  
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$allowReconnect} \OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

It creates several properties, some of them are easy to guess like \texttt{inputValues} or \texttt{initialInput}. Let's run the example below and open the HTML inspector. Notice that the \texttt{sliderInput} is set to 500 at \texttt{t0} (initialization).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
              \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{  ),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Figure \ref{fig:shiny-initial-inputs} shows how to access Shiny's initial input value with \texttt{Shiny.shinyapp.\$initialInput.obs}. After changing the slider position, its value is given by \texttt{Shiny.shinyapp.\$inputValues.obs}. \texttt{\$initialInput} and \texttt{\$inputValues} contains many more elements, however we are only interested in the slider function in this example.

\begin{figure}
\includegraphics[width=27.61in]{images/survival-kit/shiny-init-input} \caption{Explore initial input values}\label{fig:shiny-initial-inputs}
\end{figure}

\hypertarget{shiny-custom-handler}{%
\chapter{Custom handlers: from R to JavaScript}\label{shiny-custom-handler}}

Shiny provides tools to ease the communication between R and JavaScript. This is what happens in the last part. If you remember, we were playing with a \texttt{selectInput} and a \texttt{datatable}. How does R send messages to JavaScript?

We already discussed the usage of \texttt{sendInputMessage()} in the input binding section. The other important method is \texttt{sendCustomMessage(type,\ message)}. It works by pair with the JS method \texttt{Shiny.AddCustomMessageHandler}, linked with the type parameter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{say_hello_to_js <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(text, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{'say-hello'}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ text)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The JavaScript receptor is defined below:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{AddCustomMessageHandler}\NormalTok{(}\StringTok{'say-hello'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \AttributeTok{alert}\NormalTok{(}\VerbatimStringTok{`R says }\SpecialCharTok{$\{}\NormalTok{message}\SpecialCharTok{\}}\VerbatimStringTok{ to you!`}\NormalTok{)}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The shiny app below will simply print a welcome message every 5 seconds. We obviously set \texttt{options(shiny.trace\ =\ TRUE)}. Figure \ref{fig:shiny-custom-message} summarizes the main mechanisms involved in the R to JS communication.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{options}\NormalTok{(}\DataTypeTok{shiny.trace =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \StringTok{"$(function() \{}
\StringTok{        Shiny.addCustomMessageHandler('say-hello', function(message) \{}
\StringTok{          alert(`R says $\{message\} to you!`);}
\StringTok{        \});}
\StringTok{      \});}
\StringTok{      "}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(\{}
    \KeywordTok{invalidateLater}\NormalTok{(}\DecValTok{5000}\NormalTok{)}
    \KeywordTok{say_hello_to_js}\NormalTok{(}\StringTok{"hello"}\NormalTok{)}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

You will find a whole chapter dedicated to custom handlers here \ref{custom-templates-interactivity}.

\begin{figure}
\includegraphics[width=20in]{images/survival-kit/shiny-custom-message} \caption{From R to JavaScript}\label{fig:shiny-custom-message}
\end{figure}

\hypertarget{part-htmltools}{%
\part*{htmltools}\label{part-htmltools}}
\addcontentsline{toc}{part}{htmltools}

While building a custom html template, you will need to know more about the wonderful \href{https://github.com/rstudio/htmltools}{htmltools} developed by Winston Chang, member of the shiny core team. It has the same spirit as devtools, that is, making your web developer life easier. What follows does not have the pretention to be an exhaustive guide about this package. Yet, it will provide you yith the main tools to be more efficient.

\hypertarget{htmltools-overview}{%
\chapter{htmltools overview}\label{htmltools-overview}}

\hypertarget{html-tags}{%
\section{HTML Tags}\label{html-tags}}

htmltools contains tools to write HTML tags that were introduced in Chapter \ref{survival-kit-html}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{div}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

If you had to gather multiple tags together, prefer \texttt{tagList()} as \texttt{list()}, although the HTML output is the same. The first has the shiny.tag.list class in addition to list. (The \href{http://golemverse.org}{Golem} package allows to test if an R object is a tag list. In this case, using a list would cause the test fail).

\hypertarget{notations}{%
\section{Notations}\label{notations}}

Whether to use \texttt{tags\$div} or \texttt{div} depends if the tag is exported by default.
For instance, you could use \texttt{htmltools::div} but not \texttt{htmltools::nav} since nav does not have a dedicated function (only for p, h1, h2, h3, h4, h5, h6, a, br, div, span, pre, code, img, strong, em, hr).
Rather use \texttt{htmltools::tags\$nav}. Alternatively, there exists a function (in shiny and htmltools)
called \texttt{withTags()}. Wrapping your code in this function enables you to use \texttt{withTags(nav(),\ ...)} instead of \texttt{tags\$nav()}, thereby omitting the \texttt{tags\$} prefixes.

\hypertarget{adding-new-tags}{%
\section{Adding new tags}\label{adding-new-tags}}

The \texttt{tag} function allows to add extra HTML tags not already defined. You may use it as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tag}\NormalTok{(}\StringTok{"test"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}\DataTypeTok{class =} \StringTok{"test"}\NormalTok{, }\KeywordTok{p}\NormalTok{(}\StringTok{"Custom Tag"}\NormalTok{)))}
\CommentTok{# structure below}
\NormalTok{tag }
\NormalTok{}\StringTok{"test"} 
\NormalTok{list }
\NormalTok{class =}\StringTok{ "test"} 
\NormalTok{p }
\NormalTok{}\StringTok{"Custom Tag"} 
\end{Highlighting}
\end{Shaded}

\hypertarget{alternative-way-to-write-tags}{%
\section{Alternative way to write tags}\label{alternative-way-to-write-tags}}

htmltools comes with the \texttt{HTML()} function that you can feed with raw HTML:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{HTML}\NormalTok{(}\StringTok{'<div>Blabla</div>'}\NormalTok{)}
\CommentTok{# will render exactly like}
\KeywordTok{div}\NormalTok{(}\StringTok{"Blabla"}\NormalTok{)}

\CommentTok{# but there class is different}
\KeywordTok{class}\NormalTok{(}\KeywordTok{HTML}\NormalTok{(}\StringTok{'<div>Blabla</div>'}\NormalTok{))}
\KeywordTok{class}\NormalTok{(}\KeywordTok{div}\NormalTok{(}\StringTok{"Blabla"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

You will not be able to use tag related functions, as in the following parts.
Therefore, I strongly recommand using R and not mixing HTML in R. Interestingly, if
you want to convert raw HTML to R code, there is a Shiny App developed by Alan
Dipert from RStudio, namely \href{https://github.com/alandipert/html2r}{html2R}. There
are some issues, non standard attributes (like \texttt{data-toggle}) are not correctly processed but there are \href{https://github.com/alandipert/html2r/issues/2}{solutions}. This will save you precious time!

\hypertarget{playing-with-tags}{%
\section{Playing with tags}\label{playing-with-tags}}

\hypertarget{tags-structure}{%
\subsection{Tags structure}\label{tags-structure}}

According to the \texttt{tag} function, a tag has:

\begin{itemize}
\tightlist
\item
  a name such as span, div, h1 \ldots{} \texttt{tag\$name}
\item
  some attributes, which you can access with \texttt{tag\$attribs}
\item
  children, which you can access with \texttt{tag\$children}
\item
  a class, namely ``shiny.tag''
\end{itemize}

For instance:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# create the tag}
\NormalTok{myTag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
  \DataTypeTok{class =} \StringTok{"divclass"}\NormalTok{, }
  \DataTypeTok{id =} \StringTok{"first"}\NormalTok{,}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"Here comes your baby"}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"child"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"baby"}\NormalTok{, }\StringTok{"Crying"}\NormalTok{)}
\NormalTok{)}
\CommentTok{# access its name}
\NormalTok{myTag}\OperatorTok{$}\NormalTok{name}
\CommentTok{# access its attributes (id and class)}
\NormalTok{myTag}\OperatorTok{$}\NormalTok{attribs}
\CommentTok{# access children (returns a list of 2 elements)}
\NormalTok{myTag}\OperatorTok{$}\NormalTok{children}
\CommentTok{# access its class}
\KeywordTok{class}\NormalTok{(myTag)}
\end{Highlighting}
\end{Shaded}

How to modify the class of the second child, namely span?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{second_children <-}\StringTok{ }\NormalTok{myTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]]}
\NormalTok{second_children}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ "adult"}
\NormalTok{myTag}
\CommentTok{# Hummm, this is not working ...}
\end{Highlighting}
\end{Shaded}

Why is this not working? By assigning \texttt{myTag\$children{[}{[}2{]}{]}} to second\_children, \texttt{second\_children\$attribs\$class\ \textless{}-\ "adult"} modifies the class of the copy and not the original object. Thus we do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]]}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ "adult"}
\NormalTok{myTag}
\end{Highlighting}
\end{Shaded}

In the following section we explore helper functions, such as \texttt{tagAppendChild} from htmltools.

\hypertarget{useful-functions-for-tags}{%
\subsection{Useful functions for tags}\label{useful-functions-for-tags}}

htmltools and Shiny have powerful functions to easily add attributes to tags, check for existing attributes, get attributes and add other siblings to a list of tags.

\hypertarget{add-attributes}{%
\subsubsection{Add attributes}\label{add-attributes}}

\begin{itemize}
\tightlist
\item
  \texttt{tagAppendAttributes}: this function allow you to add a new attribute to the current tag.
\end{itemize}

For instance, assuming you created a div for which you forgot to add an id attribute:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\StringTok{"Where is my brain"}\NormalTok{)}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagAppendAttributes}\NormalTok{(mydiv, }\DataTypeTok{id =} \StringTok{"here_it_is"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can pass as many attributes as you want, including non standard attributes such as \texttt{data-toggle} (see Bootstrap 3 tabs for instance):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagAppendAttributes}\NormalTok{(mydiv, }\StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "tabs"}\NormalTok{)}
\CommentTok{# even though you could proceed as follows}
\NormalTok{mydiv}\OperatorTok{$}\NormalTok{attribs[[}\StringTok{"aria-controls"}\NormalTok{]] <-}\StringTok{ "home"}
\end{Highlighting}
\end{Shaded}

\hypertarget{check-if-tag-has-specific-attribute}{%
\subsubsection{Check if tag has specific attribute}\label{check-if-tag-has-specific-attribute}}

\begin{itemize}
\tightlist
\item
  \texttt{tagHasAttribute}: to check if a tag has a specific attribute
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# I want to know if div has a class}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"myclass"}\NormalTok{)}
\NormalTok{has_class <-}\StringTok{ }\KeywordTok{tagHasAttribute}\NormalTok{(mydiv, }\StringTok{"class"}\NormalTok{)}
\NormalTok{has_class}
\CommentTok{# if you are familiar with %>%}
\NormalTok{has_class <-}\StringTok{ }\NormalTok{mydiv }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagHasAttribute}\NormalTok{(}\StringTok{"class"}\NormalTok{)}
\NormalTok{has_class}
\end{Highlighting}
\end{Shaded}

\hypertarget{get-all-attributes}{%
\subsubsection{Get all attributes}\label{get-all-attributes}}

\begin{itemize}
\tightlist
\item
  \texttt{tagGetAttribute}: to get the value of the targeted attributes, if it exists, otherwise NULL.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"test"}\NormalTok{)}
\CommentTok{# returns the class}
\KeywordTok{tagGetAttribute}\NormalTok{(mydiv, }\StringTok{"class"}\NormalTok{)}
\CommentTok{# returns NULL}
\KeywordTok{tagGetAttribute}\NormalTok{(mydiv, }\StringTok{"id"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{set-childchildren}{%
\subsubsection{Set child/children}\label{set-childchildren}}

\begin{itemize}
\tightlist
\item
  \texttt{tagSetChildren} allows to create children for a given tag. For instance:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"parent"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"mother"}\NormalTok{, }\StringTok{"Not the mama!!!"}\NormalTok{)}
\CommentTok{# mydiv has 1 child "Not the mama!!!"}
\NormalTok{mydiv }
\NormalTok{children <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, span)}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagSetChildren}\NormalTok{(mydiv, children)}
\CommentTok{# mydiv has 3 children, the first one was removed}
\NormalTok{mydiv }
\end{Highlighting}
\end{Shaded}

Notice that \texttt{tagSetChildren} removes all existing children. Below we see another set of functions to add children while conserving existing ones.

\hypertarget{add-child-or-children}{%
\subsubsection{Add child or children}\label{add-child-or-children}}

\begin{itemize}
\tightlist
\item
  \texttt{tagAppendChild} and \texttt{tagAppendChildren}: add other tags to an existing tag.
  Whereas \texttt{tagAppendChild} only takes one tag, you can pass a list of tags to \texttt{tagAppendChildren}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"parent"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"mother"}\NormalTok{, }\StringTok{"Not the mama!!!"}\NormalTok{)}
\NormalTok{otherTag <-}\StringTok{ }\KeywordTok{span}\NormalTok{(}\StringTok{"I am your child"}\NormalTok{)}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagAppendChild}\NormalTok{(mydiv, otherTag)}
\end{Highlighting}
\end{Shaded}

You might wonder why there is no \texttt{tagRemoveChild} or \texttt{tagRemoveAttributes}.
Let's look at the \texttt{tagAppendChild}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tagAppendChild <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (tag, child) \{}
\NormalTok{  tag}\OperatorTok{$}\NormalTok{children[[}\KeywordTok{length}\NormalTok{(tag}\OperatorTok{$}\NormalTok{children) }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\NormalTok{child}
\NormalTok{  tag}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Below we write the \texttt{tagRemoveChild}, where tag is the target and n is the position to remove in the list of children:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"parent"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"mother"}\NormalTok{, }\StringTok{"Not the mama!!!"}\NormalTok{, }\KeywordTok{span}\NormalTok{(}\StringTok{"Hey!"}\NormalTok{))}

\CommentTok{# we create the tagRemoveChild function}
\NormalTok{tagRemoveChild <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, n) \{}
  \CommentTok{# check if the list is empty}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(tag}\OperatorTok{$}\NormalTok{children) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{stop}\NormalTok{(}\KeywordTok{paste}\NormalTok{(tag}\OperatorTok{$}\NormalTok{name, }\StringTok{"does not have any children!"}\NormalTok{))}
\NormalTok{  \}}
\NormalTok{  tag}\OperatorTok{$}\NormalTok{children[n] <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{  tag}
\NormalTok{\}}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagRemoveChild}\NormalTok{(mydiv, }\DecValTok{1}\NormalTok{)}
\NormalTok{mydiv}
\end{Highlighting}
\end{Shaded}

When defining the \texttt{tagRemoveChild}, we choose \texttt{{[}} instead of \texttt{{[}{[}} to allow to select multiple list elements:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"parent"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"mother"}\NormalTok{, }\StringTok{"Not the mama!!!"}\NormalTok{, }\StringTok{"Hey!"}\NormalTok{)}
\CommentTok{# fails}
\StringTok{`}\DataTypeTok{[[}\StringTok{`}\NormalTok{(mydiv}\OperatorTok{$}\NormalTok{children, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\CommentTok{# works}
\StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{(mydiv}\OperatorTok{$}\NormalTok{children, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Alternatively, we could also create a \texttt{tagRemoveChildren} function. Also notice that the function raises an error if the provided tag does not have children.

\hypertarget{other-interesting-functions}{%
\subsection{Other interesting functions}\label{other-interesting-functions}}

The \href{https://github.com/ThinkR-open/golem/blob/dev/inst/utils/golem_utils_ui.R}{Golem} package written by \href{https://thinkr.fr}{thinkr} contains neat functions to edit your tags.

Particularly, the \texttt{tagRemoveAttributes}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tagRemoveAttributes <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, ...) \{}
\NormalTok{  attrs <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(}\KeywordTok{list}\NormalTok{(...))}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(attrs)) \{}
\NormalTok{    tag}\OperatorTok{$}\NormalTok{attribs[[ attrs[i] ]] <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{  \}}
\NormalTok{  tag}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"test"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"coucou"}\NormalTok{, }\StringTok{"Hello"}\NormalTok{)}
\KeywordTok{tagRemoveAttributes}\NormalTok{(mydiv, }\StringTok{"class"}\NormalTok{, }\StringTok{"id"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{conditionally-set-attributes}{%
\subsection{Conditionally set attributes}\label{conditionally-set-attributes}}

Sometimes, you only want to set attributes under specific conditions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_button <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{color =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{( }
    \DataTypeTok{style =} \KeywordTok{paste}\NormalTok{(}\StringTok{"color:"}\NormalTok{, color),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{my_button}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

This example will not fail but having \texttt{style="color:\ "} is not clean. We may use conditions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_button <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{color =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{( }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(color)) }\KeywordTok{paste}\NormalTok{(}\StringTok{"color:"}\NormalTok{, color),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{my_button}\NormalTok{(}\StringTok{"blue"}\NormalTok{)}
\KeywordTok{my_button}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

In this example, style won't be available if color is not specified.

\hypertarget{using}{%
\subsection{Using \%\textgreater{}\%}\label{using}}

While doing a lot of manipulation for a tag, if you don't need to create intermediate
objects, this is a good idea to use \texttt{\%\textgreater{}\%} from \href{https://magrittr.tidyverse.org}{magrittr}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"cl"}\NormalTok{, }\KeywordTok{h1}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{tagAppendAttributes}\NormalTok{(}\DataTypeTok{id =} \StringTok{"myid"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{tagAppendChild}\NormalTok{(}\KeywordTok{p}\NormalTok{(}\StringTok{"some extra text here!"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

The pipe syntax is overall easier to follow and read.

\hypertarget{programmatically-create-children-elements}{%
\subsection{Programmatically create children elements}\label{programmatically-create-children-elements}}

Assume you want to create a tag with three children inside:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{div}\NormalTok{(}
  \KeywordTok{span}\NormalTok{(}\DecValTok{1}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DecValTok{2}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DecValTok{3}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DecValTok{4}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The structure is correct but imagine if you had to create 1000 \texttt{span} or fancier tag. The previous approach is not consistent with DRY programming. \texttt{lapply} function will be useful here (or the purrr \texttt{map} family):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# base R}
\KeywordTok{div}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) }\KeywordTok{span}\NormalTok{(i)))}
\CommentTok{# purrr + %>%}
\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) }\KeywordTok{span}\NormalTok{(i)) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{div}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{htmltools-dependencies}{%
\chapter{Dependency utilities}\label{htmltools-dependencies}}

When creating a new template, you sometimes need to import custom HTML dependencies
are not available in shiny. Fortunately, this is not aproblem using htmltools!

\hypertarget{the-dirty-approach}{%
\section{The dirty approach}\label{the-dirty-approach}}

This approach is dirty since it is not easily re-usable by others. Instead, we prefer a packaging approach, like in the next section.

Let's consider the following example. I want to include a bootstrap 4 card in a shiny app. Briefly, Bootstrap is the most popular HTML/CSS/JS framework to develop websites and web apps. This example is taken from an interesting question \href{https://community.rstudio.com/t/create-a-div-using-htmltools-withtags/22439/2}{here}.
The naive approach would be to include the HTML code directly in the app code

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# we create the card function before}
\NormalTok{my_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{withTags}\NormalTok{(}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"card border-success mb-3"}\NormalTok{,}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-header bg-transparent border-success"}\NormalTok{),}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body text-success"}\NormalTok{,}
        \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, }\StringTok{"title"}\NormalTok{),}
        \KeywordTok{p}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-text"}\NormalTok{, ...)}
\NormalTok{      ),}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-footer bg-transparent border-success"}\NormalTok{, }\StringTok{"footer"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# we build our app}
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{fluidPage}\NormalTok{(}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{column}\NormalTok{(}
        \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
        \DataTypeTok{align =} \StringTok{"center"}\NormalTok{,}
        \KeywordTok{br}\NormalTok{(),}
        \KeywordTok{my_card}\NormalTok{(}\StringTok{"blablabla. PouetPouet Pouet."}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

and unfortunately see that nothing is displayed. If you remember, this was expected since
shiny does not contain bootstrap 4 dependencies and this card is unfortunately a
bootstrap 4 object. Don't panic! Load the necessary css to display
this card (if required, we could include the javascript as well). We could use either
\texttt{includeCSS()}, \texttt{tags\$head(tags\$link(rel\ =\ "stylesheet",\ type\ =\ "text/css",\ href\ =\ "custom.css"))}. See
more \href{https://shiny.rstudio.com/articles/css.html}{here}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{fluidPage}\NormalTok{(}
    \CommentTok{# load the css code}
    \KeywordTok{includeCSS}\NormalTok{(}\DataTypeTok{path =} \StringTok{"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"}\NormalTok{),}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{column}\NormalTok{(}
        \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
        \DataTypeTok{align =} \StringTok{"center"}\NormalTok{,}
        \KeywordTok{br}\NormalTok{(),}
        \KeywordTok{my_card}\NormalTok{(}\StringTok{"blablabla. PouetPouet Pouet."}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The card may seem ugly but at least it is displayed. Fear not, we will fix the aesthetics later.

\hypertarget{the-clean-approach}{%
\section{The clean approach}\label{the-clean-approach}}

We will use the \texttt{htmlDependency} and \texttt{attachDependencies} functions from htmltools.
The htmlDependency takes several arguments:

\begin{itemize}
\tightlist
\item
  the name of your dependency
\item
  the version (useful to remember on which version it is built upon)
\item
  a path to the dependency (can be a CDN or a local folder)
\item
  script and stylesheet to respectively pass css and scripts
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# handle dependency}
\NormalTok{card_css <-}\StringTok{ "bootstrap.min.css"}
\NormalTok{bs4_card_dep <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{htmlDependency}\NormalTok{(}
    \DataTypeTok{name =} \StringTok{"bs4_card"}\NormalTok{,}
    \DataTypeTok{version =} \StringTok{"1.0"}\NormalTok{,}
    \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/"}\NormalTok{),}
    \DataTypeTok{stylesheet =}\NormalTok{ card_css}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We create the card tag and give it the bootstrap 4 dependency through the \texttt{attachDependencies()} function. In recent version of htmltools, we may simply use
\texttt{tagList(tag,\ deps)} instead.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# create the card}
\NormalTok{my_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  cardTag <-}\StringTok{ }\KeywordTok{withTags}\NormalTok{(}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"card border-success mb-3"}\NormalTok{,}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-header bg-transparent border-success"}\NormalTok{),}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body text-success"}\NormalTok{,}
        \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, }\StringTok{"title"}\NormalTok{),}
        \KeywordTok{p}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-text"}\NormalTok{, ...)}
\NormalTok{      ),}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-footer bg-transparent border-success"}\NormalTok{, }\StringTok{"footer"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
  
  \CommentTok{# attach dependencies (old way)}
  \CommentTok{# htmltools::attachDependencies(cardTag, bs4_card_dep())}
  
  \CommentTok{# simpler way}
  \KeywordTok{tagList}\NormalTok{(cardTag, }\KeywordTok{bs4_card_dep}\NormalTok{())}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We finally run our app:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# run shiny app }
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{title =} \StringTok{"Hello Shiny!"}\NormalTok{,}
  \KeywordTok{fluidRow}\NormalTok{(}
    \KeywordTok{column}\NormalTok{(}
      \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
      \DataTypeTok{align =} \StringTok{"center"}\NormalTok{,}
      \KeywordTok{br}\NormalTok{(),}
      \KeywordTok{my_card}\NormalTok{(}\StringTok{"blablabla. PouetPouet Pouet."}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\KeywordTok{shinyApp}\NormalTok{(ui, }\DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{ \})}
\end{Highlighting}
\end{Shaded}

With this approach, you could develop a package of custom dependencies that people
could use when they need to add custom elements in shiny.

\hypertarget{another-example-importing-html-dependencies-from-other-packages}{%
\section{Another example: Importing HTML dependencies from other packages}\label{another-example-importing-html-dependencies-from-other-packages}}

The shinydashboard package helps to design dashboards with shiny. In the following, we would like to integrate the box component in a classic Shiny App (without the dashboard layout). However, if you try to include the Shinydashboard box tag, you will notice that nothing is displayed since Shiny does not have shinydashboard dependencies. Fortunately htmltools contains a function, namely \texttt{findDependencies} that looks for all dependencies attached to a tag. Before going futher, let's define the basic skeleton of a shinydashboard:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{dashboardPage}\NormalTok{(}
    \KeywordTok{dashboardHeader}\NormalTok{(),}
    \KeywordTok{dashboardSidebar}\NormalTok{(),}
    \KeywordTok{dashboardBody}\NormalTok{(),}
    \DataTypeTok{title =} \StringTok{"Dashboard example"}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{ \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

There are numerous details associated with shinydashboard that we will unfortunately not go into. If you are interested in learning more, please \href{https://rstudio.github.io/shinydashboard/}{help yourself}. The key point here is the main wrapper function dashboardPage. The fluidPage is another wrapper function that most are already familiar with. We apply \texttt{findDependencies} on \texttt{dashboardPage}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deps <-}\StringTok{ }\KeywordTok{findDependencies}\NormalTok{(}
  \KeywordTok{dashboardPage}\NormalTok{(}
    \DataTypeTok{header =} \KeywordTok{dashboardHeader}\NormalTok{(), }
    \DataTypeTok{sidebar =} \KeywordTok{dashboardSidebar}\NormalTok{(), }
    \DataTypeTok{body =} \KeywordTok{dashboardBody}\NormalTok{()}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{deps}
\end{Highlighting}
\end{Shaded}

deps is a list containing four dependencies:

\begin{itemize}
\tightlist
\item
  \href{https://fontawesome.com}{Font Awesome} handles icons
\item
  \href{https://getbootstrap.com/docs/3.3/}{Bootstrap} is the main HTML/CSS/JS template. Importantly,
  please note the version 3.3.7, whereas the current is 4.3.1
\item
  \href{https://adminlte.io}{AdminLTE} is the dependency containg HTML/CSS/JS related to the admin template.
  It is closely linked to Bootstrap 3.
\item
  shinydashboard, the CSS and javascript necessary for shinydashboard to work properly. In practice,
  integrating custom HTML templates to shiny does not usually work out of the box for many reasons (Explain why!) and some modifications are necessary.
\end{itemize}

\begin{verbatim}
[[1]]
List of 10
$ name      : chr "font-awesome"
$ version   : chr "5.3.1"
$ src       :List of 1
..$ file: chr "www/shared/fontawesome"
$ meta      : NULL
$ script    : NULL
$ stylesheet: chr [1:2] "css/all.min.css" "css/v4-shims.min.css"
$ head      : NULL
$ attachment: NULL
$ package   : chr "shiny"
$ all_files : logi TRUE
- attr(*, "class")= chr "html_dependency"
[[2]]
List of 10
$ name      : chr "bootstrap"
$ version   : chr "3.3.7"
$ src       :List of 2
..$ href: chr "shared/bootstrap"
..$ file: chr "/Library/Frameworks/R.framework/Versions/3.5/Resources/library/shiny/www/shared/bootstrap"
$ meta      :List of 1
..$ viewport: chr "width=device-width, initial-scale=1"
$ script    : chr [1:3] "js/bootstrap.min.js" "shim/html5shiv.min.js" "shim/respond.min.js"
$ stylesheet: chr "css/bootstrap.min.css"
$ head      : NULL
$ attachment: NULL
$ package   : NULL
$ all_files : logi TRUE
- attr(*, "class")= chr "html_dependency"
[[3]]
List of 10
$ name      : chr "AdminLTE"
$ version   : chr "2.0.6"
$ src       :List of 1
..$ file: chr "/Library/Frameworks/R.framework/Versions/3.5/Resources/library/shinydashboard/AdminLTE"
$ meta      : NULL
$ script    : chr "app.min.js"
$ stylesheet: chr [1:2] "AdminLTE.min.css" "_all-skins.min.css"
$ head      : NULL
$ attachment: NULL
$ package   : NULL
$ all_files : logi TRUE
- attr(*, "class")= chr "html_dependency"
[[4]]
List of 10
$ name      : chr "shinydashboard"
$ version   : chr "0.7.1"
$ src       :List of 1
..$ file: chr "/Library/Frameworks/R.framework/Versions/3.5/Resources/library/shinydashboard"
$ meta      : NULL
$ script    : chr "shinydashboard.min.js"
$ stylesheet: chr "shinydashboard.css"
$ head      : NULL
$ attachment: NULL
$ package   : NULL
$ all_files : logi TRUE
- attr(*, "class")= chr "html_dependency"
\end{verbatim}

Below, we attach the dependencies to the \texttt{box} with \texttt{tagList}, as shown above. Notice that our custom \texttt{box} does not contain all parameters from shinydashboard, which is actually ok at this time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_box <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(title, status) \{}
  \KeywordTok{tagList}\NormalTok{(}\KeywordTok{box}\NormalTok{(}\DataTypeTok{title =}\NormalTok{ title, }\DataTypeTok{status =}\NormalTok{ status), deps)}
\NormalTok{\}}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{titlePanel}\NormalTok{(}\StringTok{"Shiny with a box"}\NormalTok{),}
  \KeywordTok{my_box}\NormalTok{(}\DataTypeTok{title =} \StringTok{"My box"}\NormalTok{, }\DataTypeTok{status =} \StringTok{"danger"}\NormalTok{),}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

You now have limitless possibilities! Interestingly, this same approach is the basis of \href{https://github.com/dreamRs/shinyWidgets/blob/master/R/useBs4Dash.R}{shinyWidgets} for the \texttt{useBs4Dash} function and other related tools.

\hypertarget{suppress-dependencies}{%
\section{Suppress dependencies}\label{suppress-dependencies}}

In rare cases, you may need to remove an existing conflicting dependency. The \texttt{suppressDependencies} function allows users to perform this. For instance, \href{https://github.com/Appsilon/shiny.semantic}{shiny.semantic} built on top of
semantic ui is not compatible with Bootstrap. Below, we remove the AdminLTE dependency
from a shinydashboard page and nothing is displayed (as expected):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{dashboardPage}\NormalTok{(}
    \KeywordTok{dashboardHeader}\NormalTok{(),}
    \KeywordTok{dashboardSidebar}\NormalTok{(),}
    \KeywordTok{dashboardBody}\NormalTok{(}\KeywordTok{suppressDependencies}\NormalTok{(}\StringTok{"AdminLTE"}\NormalTok{)),}
    \DataTypeTok{title =} \StringTok{"Dashboard example"}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{ \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{htmltools-other-tools}{%
\chapter{Other tools}\label{htmltools-other-tools}}

\hypertarget{css}{%
\section{CSS}\label{css}}

Sometimes, it is temptating to write inline CSS for a tag in the \texttt{style} attribute, for instance:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{title <-}\StringTok{ }\KeywordTok{h4}\NormalTok{(}
  \StringTok{"A title"}\NormalTok{,}
  \DataTypeTok{style =} \StringTok{"color: cyan; text-align: center; margin-top: 100px;"}
\NormalTok{)}
\KeywordTok{shinyApp}\NormalTok{(}\DataTypeTok{ui =}\NormalTok{ title, }\DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{\})}
\end{Highlighting}
\end{Shaded}

As the number of CSS properties grows, the code may become hard to read. The \href{https://github.com/nteetor/cascadess}{\{cascadess\}} package developed by \href{}{Nathan Teetor} provides a more readable syntax, which works well with \texttt{\%\textgreater{}\%}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \KeywordTok{cascadess}\NormalTok{(),}
  \KeywordTok{h4}\NormalTok{(}
    \StringTok{"A title"}\NormalTok{,}
\NormalTok{    .style }\OperatorTok{%>%}
\StringTok{      }\KeywordTok{text}\NormalTok{(}\DataTypeTok{color =} \StringTok{"cyan"}\NormalTok{, }\DataTypeTok{align =} \StringTok{"center"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{      }\KeywordTok{margin}\NormalTok{(}\DataTypeTok{top =} \DecValTok{5}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\KeywordTok{shinyApp}\NormalTok{(ui, }\DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{\})}
\end{Highlighting}
\end{Shaded}

\{cascadess\} is a pleasing way to learn CSS through R. For instance, the CSS \href{https://www.google.com/search?client=safari\&rls=en\&q=text+properties+css\&ie=UTF-8\&oe=UTF-8}{text formating} includes properties like \texttt{text-color}, \texttt{text-align}, \ldots{}The \texttt{text} function has the same parameters, namely color, align, as shown in the above example.

Notice that we included the \texttt{cascadess} function, which is nothing more than an htmldependency object necessary to apply styles on elements.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cascadess}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 10
##  $ name      : chr "cascadess"
##  $ version   : chr "0.1.0"
##  $ src       :List of 2
##   ..$ file: chr "/Library/Frameworks/R.framework/Versions/3.6/Resources/library/cascadess/www/cascadess"
##   ..$ href: chr "cascadess/cascadess"
##  $ meta      : NULL
##  $ script    : NULL
##  $ stylesheet: chr "cascadess.min.css"
##  $ head      : NULL
##  $ attachment: NULL
##  $ package   : NULL
##  $ all_files : logi TRUE
##  - attr(*, "class")= chr "html_dependency"
\end{verbatim}

Try to run the previous example without this element. Nothing will be properly displayed!

\hypertarget{part-practice}{%
\part*{Practice}\label{part-practice}}
\addcontentsline{toc}{part}{Practice}

In this chapter, you will learn how to build your own html templates taken from the web and package them, so that they can be re-used at any time by anybody.

\hypertarget{custom-templates-selection}{%
\chapter{Template selection}\label{custom-templates-selection}}

There are numerous HTML templates all over the web. However,few may be suitable for shiny.

\begin{itemize}
\tightlist
\item
  shiny is built on top of \href{https://getbootstrap.com/docs/3.3/}{Bootstrap 3} (HTML, CSS and Javascript framework), and changing the framework will not be a trivial endeavor. However, \href{https://github.com/ericrayanderson/shinymaterial}{shinymaterial} and \href{https://github.com/Appsilon/shiny.semantic}{shiny.semantic} are good examples that show this is possible.
\item
  shiny relies on \href{https://jquery.com}{jQuery} (currently v 3.4.1 for shiny). Consequently, all templates based upon \href{https://fr.reactjs.org}{React}, \href{https://vuejs.org}{Vue} and other Javascript framework will not be natively supported. Again, there exist some \href{https://github.com/alandipert/react-widget-demo/blob/master/app.R}{examples} for React with shiny and more generally,
  the \href{https://react-r.github.io/reactR/}{reactR} package developed by Kent Russell and Alan Dipert from RStudio.
\end{itemize}

See \href{https://github.com/rstudio/shiny/tree/master/inst/www/shared}{the github repository} for more details about all dependencies related to the shiny package.

\begin{quote}
Notes: As shiny depends on Bootstrap 3.4.1, we recommend the user whom is interested in experimenting with Bootstrap 4 to be consciously aware of the potential incompatibilities. See a working example here with \href{https://github.com/RinteRface/bs4Dash}{bs4Dash}.
\end{quote}

A good source of \textbf{open source} HTML templates is \href{https://colorlib.com}{Colorlib} and \href{https://www.creative-tim.com/bootstrap-themes/free}{Creative Tim}.

In the next chapter, we will focus on the \href{https://preview-dev.tabler.io/layout-dark.html}{tabler.io} dashboard template (See Figure \ref{fig:tabler-dark}).

\begin{figure}
\includegraphics[width=34.33in]{images/practice/tabler-dark} \caption{Tabler dashboard overview}\label{fig:tabler-dark}
\end{figure}

\hypertarget{custom-templates-dependencies}{%
\chapter{Define dependencies}\label{custom-templates-dependencies}}

The tabler template is a tiny Bootstrap 4 dashboard template. In this chapter, we will describe how to customize tabler by providing an R wrapper. In this way, the underlying JavaScript code is left untouched yet we are able to incorporate greater functionality.

\hypertarget{discover-the-project}{%
\section{Discover the project}\label{discover-the-project}}

The first step of any template adaptation consists of exploring the underlying Github repository (if open source) and look for mandatory elements, like CSS/JS dependencies. This is a similar strategy if you want to incorporate an HTMLWidget as well.

\begin{figure}
\includegraphics[width=32.03in]{images/practice/tabler-github} \caption{Github project exploration}\label{fig:tabler-github}
\end{figure}

As shown in Figure \ref{fig:tabler-github}, the most important folders are:

\begin{itemize}
\tightlist
\item
  dist: contains CSS and JS files as well as other libraries like Bootstrap and jQuery. It is also a good moment to look at the version of each dependency that might conflict with Shiny
\item
  demo is the website folder used for demonstration purpose. This is our source to explore the template capabilities in depth
\end{itemize}

The scss and build folder may be used to customize the tabler template directly. However as stated above, directions on how to do so are out of scope for this book.

\hypertarget{identify-mandatory-dependencies}{%
\section{Identify mandatory dependencies}\label{identify-mandatory-dependencies}}

Bootstrap 4, jQuery, tabler.min.css and tabler.min.js are key elements for the template, contrary to flag icons which are optional (and take a lot of space). If your goal is to release your template on CRAN, be mindful of the 5 Mb maximum size limit. From personal experience, I can attest that this is quite challenging to manage.

To inspect dependencies, we proceed as follows

\begin{itemize}
\tightlist
\item
  Download or clone the Github repository
\item
  Go to the demo folder and open the layout-dark.html file
\item
  Open the HTML inspector
\end{itemize}

\includegraphics[width=0.5\linewidth]{images/practice/tabler-deps-1} \includegraphics[width=0.5\linewidth]{images/practice/tabler-deps-2}

As depicted in Figure \ref{fig:tabler-deps} left-hand side, we need to include the tabler.min.css from the header. If you are not convinced, try to remove it from the DOM and see what happens. \href{https://www.10bestdesign.com/jqvmap/}{jqvmap} is actually related to an external visualization plugin used in the demo. Finally the demo.min.css file is for the demo purpose. This will not prevent the template from working, so we will skip it for now. So far so good, we only need one file thus!

JavaScript dependencies are shown on the right-hand side and located at the end of the body tag. Because we will not need all chart-related dependencies like apexcharts, jquery.vmap and vmap world and may safely ignore them. We will keep the Bootstrap 4 bundle.js, jQuery core and tabler.min.js (the order is crucial).

\hypertarget{bundle-dependencies}{%
\section{Bundle dependencies}\label{bundle-dependencies}}

With the help of the \texttt{htmltoolsDependency} function, we are going to create our main Tabler HTML dependency containing all assets to allow our template to render properly. In this example, I am going to cheat a bit: instead of handling local files, I will use a CDN (content delivery network) that hosts all necessary Tabler \href{https://www.jsdelivr.com/package/npm/tabler}{assets}. The main reason is that it will allow us to test the template directly from the bookdown project. But in theory, this template would need to live inside an R package, in a github repository.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tablers_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"tabler"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"1.0.7"}\NormalTok{, }\CommentTok{# we take that of tabler,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://cdn.jsdelivr.net/npm/tabler@1.0.0-alpha.7/dist/"}\NormalTok{),}
  \DataTypeTok{script =} \StringTok{"js/tabler.min.js"}\NormalTok{,}
  \DataTypeTok{stylesheet =} \StringTok{"css/tabler.min.css"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

I advise the reader to create one HTML dependency per element. The Bootstrap version is v4.3.1 (Shiny relies on 3.4.1) and jQuery is 3.5.0 (Shiny relies on 3.4.1). We can also use a CDN:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bs4_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"Bootstrap"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"4.3.1"}\NormalTok{,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/"}\NormalTok{),}
  \DataTypeTok{script =} \StringTok{"bootstrap.bundle.min.js"}
\NormalTok{)}

\NormalTok{jQuery_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"jquery"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"3.5.0"}\NormalTok{,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://code.jquery.com/"}\NormalTok{),}
  \DataTypeTok{script =} \StringTok{"jquery-3.5.0.slim.min.js"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We finally create our dependency manager:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# add all dependencies to a tag. Don't forget to set append to TRUE to preserve any existing dependency}
\NormalTok{addDeps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
  \CommentTok{# below, the order is of critical importance!}
\NormalTok{  deps <-}\StringTok{ }\KeywordTok{list}\NormalTok{(bs4_deps, tablers_deps)}
  \KeywordTok{attachDependencies}\NormalTok{(tag, deps, }\DataTypeTok{append =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice the dependencies order in the \texttt{deps} list: this will be exactly the same order in the \texttt{head} of the HTML page. Some libraries require to be loaded at a specific place, like the Tabler dependencies which must come after Bootstrap.
It is not surprising since Tabler is built on top of Bootstrap 4.

Let's see how to use \texttt{addDeps}. We consider a \texttt{\textless{}div\textgreater{}} placeholder and check for its dependencies with \texttt{findDependencies} (should be NULL). Then, we wrap it with \texttt{addDeps}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag <-}\StringTok{ }\KeywordTok{div}\NormalTok{()}
\KeywordTok{findDependencies}\NormalTok{(tag)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag <-}\StringTok{ }\KeywordTok{addDeps}\NormalTok{(}\KeywordTok{div}\NormalTok{())}
\KeywordTok{findDependencies}\NormalTok{(tag)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## List of 10
##  $ name      : chr "Bootstrap"
##  $ version   : chr "4.3.1"
##  $ src       :List of 1
##   ..$ href: chr "https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/"
##  $ meta      : NULL
##  $ script    : chr "bootstrap.bundle.min.js"
##  $ stylesheet: NULL
##  $ head      : NULL
##  $ attachment: NULL
##  $ package   : NULL
##  $ all_files : logi TRUE
##  - attr(*, "class")= chr "html_dependency"
## 
## [[2]]
## List of 10
##  $ name      : chr "tabler"
##  $ version   : chr "1.0.7"
##  $ src       :List of 1
##   ..$ href: chr "https://cdn.jsdelivr.net/npm/tabler@1.0.0-alpha.7/dist/"
##  $ meta      : NULL
##  $ script    : chr "js/tabler.min.js"
##  $ stylesheet: chr "css/tabler.min.css"
##  $ head      : NULL
##  $ attachment: NULL
##  $ package   : NULL
##  $ all_files : logi TRUE
##  - attr(*, "class")= chr "html_dependency"
\end{verbatim}

As shown above, our dependencies are applied to the div, in the correct order. This order is set by the list \texttt{list(bs4\_deps,\ jQuery\_deps,\ tablers\_deps)} and allows use to avoid potential conflicts. If we try to run this simple tag in a shiny app, we notice that all dependencies are added to the \texttt{\textless{}head\textgreater{}} tag, whereas the original template loads JavaScript dependencies in the \texttt{\textless{}body\textgreater{}}. Unfortunately, htmltools does not allow developers to distribute dependencies in different places. Here there is no impact but for other templates like \href{https://framework7.io}{Framework7} (which is powering \href{https://github.com/RinteRface/shinyMobile}{shinyMobile}), JavaScript must be place in the body. In practice, this is challenging to guess and may only be solved by manual testing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(tag)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Even though the \texttt{addDeps} function may be applied to any tag, we will use it with the core HTML template, that remain to be designed!

Would you like to see if our dependency system works? Let's meet in the next chapter to design the main dashboard layout.

\hypertarget{custom-templates-skeleton}{%
\chapter{Template skeleton}\label{custom-templates-skeleton}}

The list of all available layouts is quite impressive (horizontal, vertical, compressed, right to left, dark, \ldots{}). In the next steps, we will focus on the dark-compressed template. We leave the reader to try other templates as an exercise.

\hypertarget{identify-template-elements}{%
\section{Identify template elements}\label{identify-template-elements}}

We are quite lucky since there is nothing fancy about the tabler layout. As usual, let's inspect the layout-condensed-dark.html (in the tabler /demo folder) in Figure \ref{fig:tabler-layout-intro}

\begin{figure}
\includegraphics[width=17.56in]{images/practice/tabler-layout-intro} \caption{Tabler condensed layout}\label{fig:tabler-layout-intro}
\end{figure}

There are 2 main components:
- the header containing the brand logo, the navigation and dropdown
- the content containing the dashboard body as well as the footer

Something important: the dashboard body does not mean \texttt{\textless{}body\textgreater{}} tag!

This is all!

\hypertarget{design-the-page-layout}{%
\section{Design the page layout}\label{design-the-page-layout}}

\hypertarget{the-page-wrapper}{%
\subsection{The page wrapper}\label{the-page-wrapper}}

Do you remember the structure of a basic html page seen in Chapter \ref{survival-kit-html}? Well, if not, here is a reminder.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
  \CommentTok{<!-- head content here -->}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<p>}\NormalTok{Hello World}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

We actually don't need to include the \texttt{\textless{}html\textgreater{}} tag since shiny will automatically do it. Below we construct a list of tags with \texttt{tagList}, including the head and the body. In the head we have the \texttt{meta} tags which has multiple purposes:

\begin{itemize}
\tightlist
\item
  describe the encoding,
\item
  how to display the app on different devices. For instance \texttt{apple-mobile-web-app-status-bar-style} is for iOS devices mobile support.
\item
  Set the favicon, which is an icon representing the website icon, that is the one you may see on the right side of the searchbar. Try \href{https://twitter.com/home}{twitter} for instance.
\end{itemize}

The page title and favicon may be changed by the developer, so they may be included as parameters of the function. If you remember, there also should be CSS in the head but nothing here! Actually, the insertion of dependencies will be achieved by our \texttt{addDeps} function defined in Chapter \ref{custom-templates-dependencies}. Tabler comes with 2 main themes, namely white and dark, which may be applied through the \texttt{\textless{}body\textgreater{}} class attribute (respectively ``antialiased theme-dark'' and ``antialiased''). The \ldots{} parameter contain other template elements like the header and the dashboard body, that remain to be created. As shown in Figure \ref{fig:tabler-dark} of Chapter \ref{custom-templates-selection}, the tabler dashboard template may contain a navigation bar and a footer. As they are not mandatory, we will not create dedicated parameters and pass all elements in the \ldots{}slot.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{dark =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{favicon =} \OtherTok{NULL}\NormalTok{)\{}
  
  \CommentTok{# head}
\NormalTok{  head_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{charset =} \StringTok{"utf-8"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
      \DataTypeTok{name =} \StringTok{"viewport"}\NormalTok{, }
      \DataTypeTok{content =} \StringTok{"}
\StringTok{        width=device-width, }
\StringTok{        initial-scale=1, }
\StringTok{        viewport-fit=cover"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\StringTok{`}\DataTypeTok{http-equiv}\StringTok{`}\NormalTok{ =}\StringTok{ "X-UA-Compatible"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"ie=edge"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{title}\NormalTok{(title),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}
      \DataTypeTok{rel =} \StringTok{"preconnect"}\NormalTok{, }
      \DataTypeTok{href =} \StringTok{"https://fonts.gstatic.com/"}\NormalTok{, }
      \DataTypeTok{crossorigin =} \OtherTok{NA}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"msapplication-TileColor"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"#206bc4"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"theme-color"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"#206bc4"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"apple-mobile-web-app-status-bar-style"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"black-translucent"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"apple-mobile-web-app-capable"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"yes"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"mobile-web-app-capable"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"yes"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"HandheldFriendly"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"True"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"MobileOptimized"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"320"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"robots"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"noindex,nofollow,noarchive"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}\DataTypeTok{rel =} \StringTok{"icon"}\NormalTok{, }\DataTypeTok{href =}\NormalTok{ favicon, }\DataTypeTok{type =} \StringTok{"image/x-icon"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}\DataTypeTok{rel =} \StringTok{"shortcut icon"}\NormalTok{, }\DataTypeTok{href =}\NormalTok{ favicon, }\DataTypeTok{type=}\StringTok{"image/x-icon"}\NormalTok{)}
\NormalTok{  )}
  
  \CommentTok{# body}
\NormalTok{  body_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"antialiased "}\NormalTok{, }\ControlFlowTok{if}\NormalTok{(dark) }\StringTok{"theme-dark"}\NormalTok{),}
      \DataTypeTok{style =} \StringTok{"display: block;"}\NormalTok{,}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"page"}\NormalTok{, ...)}
\NormalTok{    )}
\NormalTok{  ) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{addDeps}\NormalTok{()}
  
  \KeywordTok{tagList}\NormalTok{(head_tag, body_tag)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Below we quickly test if a tabler element renders well which confirms our setup is adequate. To do this, we include a random tabler element taken from the demo html page, using \texttt{HTML}. Let's be clear: you should avoid as much as possible using \texttt{HTML} because of security \href{https://mastering-shiny.org/advanced-ui.html}{issues}. This also checks that our basic Shiny input/output system works as expected with a sliderInput linked to a plot output.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#thematic_on()}
\CommentTok{#onStop(thematic_off)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \StringTok{"test"}\NormalTok{, }
  \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
              \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{  ),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{),}
  \KeywordTok{br}\NormalTok{(),}
  \KeywordTok{HTML}\NormalTok{(}
    \StringTok{'<div class="col-sm-6 col-lg-3">}
\StringTok{   <div class="card">}
\StringTok{      <div class="card-body">}
\StringTok{         <div class="d-flex align-items-center">}
\StringTok{            <div class="subheader">Sales</div>}
\StringTok{            <div class="ml-auto lh-1">}
\StringTok{               <div class="dropdown">}
\StringTok{                  <a class="dropdown-toggle text-muted" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">}
\StringTok{                  Last 7 days}
\StringTok{                  </a>}
\StringTok{                  <div class="dropdown-menu dropdown-menu-right">}
\StringTok{                     <a class="dropdown-item active" href="#">Last 7 days</a>}
\StringTok{                     <a class="dropdown-item" href="#">Last 30 days</a>}
\StringTok{                     <a class="dropdown-item" href="#">Last 3 months</a>}
\StringTok{                  </div>}
\StringTok{               </div>}
\StringTok{            </div>}
\StringTok{         </div>}
\StringTok{         <div class="h1 mb-3">75%</div>}
\StringTok{         <div class="d-flex mb-2">}
\StringTok{            <div>Conversion rate</div>}
\StringTok{            <div class="ml-auto">}
\StringTok{               <span class="text-green d-inline-flex align-items-center lh-1">}
\StringTok{                  7% }
\StringTok{                  <svg xmlns="http://www.w3.org/2000/svg" class="icon ml-1" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">}
\StringTok{                     <path stroke="none" d="M0 0h24v24H0z"></path>}
\StringTok{                     <polyline points="3 17 9 11 13 15 21 7"></polyline>}
\StringTok{                     <polyline points="14 7 21 7 21 14"></polyline>}
\StringTok{                  </svg>}
\StringTok{               </span>}
\StringTok{            </div>}
\StringTok{         </div>}
\StringTok{         <div class="progress progress-sm">}
\StringTok{            <div class="progress-bar bg-blue" style="width: 75%" role="progressbar" aria-valuenow="75" aria-valuemin="0" aria-valuemax="100">}
\StringTok{               <span class="sr-only">75% Complete</span>}
\StringTok{            </div>}
\StringTok{         </div>}
\StringTok{      </div>}
\StringTok{   </div>}
\StringTok{</div>}
\StringTok{    '}
\NormalTok{  ),}
\DataTypeTok{title =} \StringTok{"Tabler test"}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Ok, our info card and the shiny element work like a charm, which is a good start. Now we may focus on the aesthetics.

\hypertarget{the-body-content}{%
\subsection{The body content}\label{the-body-content}}

In this part, we translate the dashboard body HTML code to R. As a reminder, the \href{https://alandipert.shinyapps.io/html2r/}{html2r} by \href{https://github.com/alandipert}{Alan Dipert} substantially speeds up the conversion process. You copy the code in the HTML text area, click on convert and get the R shiny output. We create a function called \texttt{tabler\_body}. The \ldots{} parameter holds all the dashboard body elements and the footer is dedicated for the future \texttt{tabler\_footer} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_body <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{footer =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"content"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"container-xl"}\NormalTok{, ...),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{footer}\NormalTok{(}\DataTypeTok{class =} \StringTok{"footer footer-transparent"}\NormalTok{, footer)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let's test it with the previous example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}\KeywordTok{tabler_body}\NormalTok{(}\KeywordTok{h1}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)))}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Way better!

\hypertarget{the-footer}{%
\subsection{The footer}\label{the-footer}}

The footer is composed of a left and right containers. We decide to create parameters left and right in which the user will be able to pass any elements.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_footer <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{left =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{right =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"container"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"row text-center align-items-center flex-row-reverse"}\NormalTok{,}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"col-lg-auto ml-lg-auto"}\NormalTok{, right),}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"col-12 col-lg-auto mt-3 mt-lg-0"}\NormalTok{, left)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

All the class attributes are taken from the original HTML template. If you are already familiar with Bootstrap 4, you may easily customize the style. In short, \texttt{row} means that all elements will be aligned on a row, \texttt{text-center} amd \texttt{align-items-center} handle the text and content centering. \texttt{flex-row-reverse} display elements in a reversed order. Notice also that a \texttt{row} element contains columns created with the \texttt{col} class. The Bootstrap grid system relies on the Flexible Box Module, also known as \href{https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox}{flexbox}.

As above, let's check our brand new element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{, }\StringTok{"More"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-navbar-or-header}{%
\subsection{The navbar (or header)}\label{the-navbar-or-header}}

This function is called \texttt{tabler\_header}. In the tabler template, the header has the \texttt{navbar\ navbar-expand-md\ navbar-light} classes. We don't need the navbar-light classe since we are only interested in the dark theme. As shown in Figure \ref{fig:tabler-header}, the navbar is composed of 4 elements:

\begin{itemize}
\tightlist
\item
  the navbar toggler is only visible when we reduce the screen width, like on mobile devices
\item
  the brand image
\item
  the navigation
\item
  the dropdown menus (this is not mandatory)
\end{itemize}

\begin{figure}
\includegraphics[width=20in]{images/practice/tabler-header} \caption{Tabler header structure}\label{fig:tabler-header}
\end{figure}

You may have a look at the \href{https://getbootstrap.com/docs/4.0/components/navbar/}{Bootstrap 4} documentation for extra configuration and layout.

Each of these element will be considered as an input parameter to the \texttt{tabler\_navbar} function, except the navbar toggler which is a default element and must not be removed. Morever, we will only show the brand element when it is provided. The \ldots{} parameter is a slot for extra elements (between the menu and dropdowns). In the following, we start by creating the main container, that is \texttt{header\_tag} and its unique child \texttt{container\_tag}. The latter has 4 children \texttt{toggler\_tag}, \texttt{brand\_tag}, \texttt{dropdown\_tag} and \texttt{navmenu\_tag}. In this situations, \{htmltools\} functions like \texttt{tagAppendChild} and \texttt{tagAppendChildren} are game changers to better organize the code and make it more maintainable. One never knows in advance how much extra feature will be added to that component. Hence being cautious at the very beginning is crucial!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{brand_url =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{brand_image =} \OtherTok{NULL}\NormalTok{, nav_menu, }\DataTypeTok{nav_right =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  header_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{header}\NormalTok{(}\DataTypeTok{class =} \StringTok{"navbar navbar-expand-md"}\NormalTok{)}
\NormalTok{  container_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"container-xl"}\NormalTok{)}
  
  \CommentTok{# toggler for small devices (must not be removed)}
\NormalTok{  toggler_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"navbar-toggler"}\NormalTok{, }
    \DataTypeTok{type =} \StringTok{"button"}\NormalTok{, }
    \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "collapse"}\NormalTok{, }
    \StringTok{`}\DataTypeTok{data-target}\StringTok{`}\NormalTok{ =}\StringTok{ "#navbar-menu"}\NormalTok{,}
    \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"navbar-toggler-icon"}\NormalTok{)}
\NormalTok{  )}
  
  \CommentTok{# brand elements}
\NormalTok{  brand_tag <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(brand_url) }\OperatorTok{||}\StringTok{ }\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(brand_image)) \{}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{href =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(brand_url)) \{}
\NormalTok{        brand_url}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \StringTok{"#"}
\NormalTok{      \},}
      \DataTypeTok{class =} \StringTok{"navbar-brand navbar-brand-autodark d-none-navbar-horizontal pr-0 pr-md-3"}\NormalTok{,}
      \ControlFlowTok{if}\NormalTok{(}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(brand_image)) \{}
        \KeywordTok{img}\NormalTok{(}
          \DataTypeTok{src =}\NormalTok{ brand_image, }
          \DataTypeTok{alt =} \StringTok{"brand Image"}\NormalTok{,}
          \DataTypeTok{class =} \StringTok{"navbar-brand-image"}
\NormalTok{        )}
\NormalTok{      \}}
\NormalTok{    )}
\NormalTok{  \}}
  
\NormalTok{  dropdown_tag <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(nav_right)) \{}
    \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"navbar-nav flex-row order-md-last"}\NormalTok{, nav_right)}
\NormalTok{  \}}
  
\NormalTok{  navmenu_tag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"collapse navbar-collapse"}\NormalTok{, }
    \DataTypeTok{id =} \StringTok{"navbar-menu"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"d-flex flex-column flex-md-row flex-fill align-items-stretch align-items-md-center"}\NormalTok{,}
\NormalTok{      nav_menu}
\NormalTok{    ),}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(}\KeywordTok{list}\NormalTok{(...)) }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"ml-md-auto pl-md-4 py-2 py-md-0 mr-md-4 order-first order-md-last flex-grow-1 flex-md-grow-0"}\NormalTok{, }
\NormalTok{        ...}
\NormalTok{      )}
\NormalTok{    \}}
\NormalTok{  )}
  
\NormalTok{  container_tag <-}\StringTok{ }\NormalTok{container_tag }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChildren}\NormalTok{(}
\NormalTok{    toggler_tag,}
\NormalTok{    brand_tag,}
\NormalTok{    dropdown_tag,}
\NormalTok{    navmenu_tag}
\NormalTok{  )}
  
\NormalTok{  header_tag }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChild}\NormalTok{(container_tag)}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The navbar menu is the main component of the navbar. The \ldots{} parameter is a slot for the menu items. Compared to the original tabler dashboard template where there is only the class navbar-nav, we have to add at least, the \texttt{nav} class to make sure items are correctly activated/inactivated. The \texttt{nav-pills} class is to select pills instead of basic tabs (see \href{https://getbootstrap.com/docs/4.0/components/navs/}{here}), which is nothing more than a cosmetic consideration. Notice the \texttt{ul} tag that will contain \texttt{li} elements, that is the navbar items.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{ul}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav nav-pills navbar-nav"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Besides, each navbar menu item could be either a simple button or contain multiple menu sub-items. For now, we only focus on simple items.

\hypertarget{navbar-navigation}{%
\subsubsection{Navbar navigation}\label{navbar-navigation}}

The navbar is extremely important since it will drive the navigation of the template. We would like to associate each item to a separate page in the body content. This will allow us to go to a new page each time we change an item. In brief, it is very similar to the Shiny \texttt{tabsetPanel} function.

In HTML, menu items are \texttt{\textless{}a\textgreater{}} tags (links) with a given \texttt{href} attribute pointing to a specific page located in the server files. The point with a Shiny app is that we can't decide how to split our content into several pages. We only have app.R generating a simple HTML page. The strategy here is to create a tabbed navigation, to mimic multiple pages.

Let's see how tabset navigation works. In the menu list, all items must have:

\begin{itemize}
\tightlist
\item
  a \texttt{data-toggle} attribute set to tab
\item
  an \texttt{href} attribute holding a unique id. This unique id is mandatory since it will point the menu item to the corresponding body content.
\end{itemize}

On the body side, tab panels are contained in a tabset panel (simple div container), have a \texttt{role} attribute set to tabpanel and an \texttt{id} corresponding the \texttt{href} passed in the menu item. The exact match between \texttt{id} and \texttt{href} is mandatory, as shown in Figure \ref{fig:tabler-tabset}.

\begin{figure}
\includegraphics[width=20in]{images/practice/tabler-tabset} \caption{Tabler tabset main principle}\label{fig:tabler-tabset}
\end{figure}

Below, we propose a possible implementation of a menu item, as well as the corresponding body tab panel. The text parameter corresponds to the nav item text displayed in the menu. We also added an optional icon and the ability to select the item at start.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(text, tabName, }\DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{selected =} \OtherTok{FALSE}\NormalTok{) \{}
  
\NormalTok{  item_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"nav-link"}\NormalTok{, }\ControlFlowTok{if}\NormalTok{(selected) }\StringTok{" active"}\NormalTok{)}
  
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"nav-item"}\NormalTok{,}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ item_cl,}
      \DataTypeTok{href =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, tabName),}
      \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "pill"}\NormalTok{, }\CommentTok{# see https://getbootstrap.com/docs/4.0/components/navs/}
      \StringTok{`}\DataTypeTok{data-value}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{tabName,}
      \DataTypeTok{role =} \StringTok{"tab"}\NormalTok{,}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav-link-icon d-md-none d-lg-inline-block"}\NormalTok{, icon),}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav-link-title"}\NormalTok{, text)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We also decided to add a fade transition effect between tabs, as per Bootstrap 4 documentation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_tab_items <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"tab-content"}\NormalTok{, ...)}
\NormalTok{\}}

\NormalTok{tabler_tab_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{tabName =} \OtherTok{NULL}\NormalTok{, ...) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{role =} \StringTok{"tabpanel"}\NormalTok{,}
    \DataTypeTok{class =} \StringTok{"tab-pane fade container-fluid"}\NormalTok{,}
    \DataTypeTok{id =}\NormalTok{ tabName,}
\NormalTok{    ...}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

What about testing this in a shiny app?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \KeywordTok{tabler_navbar_menu}\NormalTok{(}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 1"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{      ),}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 2"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab2"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_tab_items}\NormalTok{(}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{      ),}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Second Tab"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

At this point you might argue that we did not even validated the template elements. For instance, going back to the \texttt{tabler\_navbar\_menu\_item} function, we find the following possible issues:

\begin{itemize}
\tightlist
\item
  What happens if the user provides an invalid tabName, ie a text that is not valid for jQuery like \texttt{tab\&?++}?
\item
  What happens if the user accidentaly activates 2 tabs at start?
\end{itemize}

We will see later in Chapter \ref{custom-templates-testing} how to validate those parameter.

\hypertarget{fine-tune-tabs-behavior}{%
\subsubsection{Fine tune tabs behavior}\label{fine-tune-tabs-behavior}}

Quite good isn't it? You will notice however that even if the first tab is selected by default, its content is not shown. To fix this, we will apply our jQuery skills. According to the Bootstrap documentation, we must trigger the show event on the active tab at start, as well as add the classes \texttt{show} and \texttt{active} to the associated tab panel in the dashboard body. We therefore target the nav item that has the active class and if no item is found, we select the first item by default and activate its body content. We will explore another alternative in Chapter \ref{custom-templates-inputs}.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// this makes sure to trigger the show event on the active   tab at start}
  \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#navbar-menu .nav-link.active'}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// if multiple items are found}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{activeTab}\NormalTok{.}\AttributeTok{length} \OperatorTok{>} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{let}\NormalTok{ tabId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{tabId}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{addClass}\NormalTok{(}\StringTok{'show active'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\StringTok{'#navbar-menu .nav-link'}\NormalTok{)}
\NormalTok{      .}\AttributeTok{first}\NormalTok{()}
\NormalTok{      .}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The script is included in a tag but best practice it to put it in a separate js file (I do it this way because it is more convenient for the demonstration).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#thematic_on()}
\CommentTok{#onStop(thematic_off)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \KeywordTok{HTML}\NormalTok{(}
        \StringTok{"$(function() \{}
\StringTok{          // this makes sure to trigger the show event on the active tab at start}
\StringTok{          const activeTab = $('#navbar-menu .nav-link.active');}
\StringTok{          if (activeTab.length > 0) \{}
\StringTok{            const tabId = $(activeTab).attr('data-value');}
\StringTok{            $(activeTab).tab('show');}
\StringTok{            $(`#$\{tabId\}`).addClass('show active');}
\StringTok{          \} else \{}
\StringTok{            $('#navbar-menu .nav-link')}
\StringTok{              .first()}
\StringTok{              .tab('show');}
\StringTok{          \}}
\StringTok{        \});}
\StringTok{        "}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \KeywordTok{tabler_navbar_menu}\NormalTok{(}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 1"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{      ),}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 2"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab2"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_tab_items}\NormalTok{(}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \KeywordTok{sliderInput}\NormalTok{(}
          \StringTok{"obs"}\NormalTok{, }
          \StringTok{"Number of observations:"}\NormalTok{,}
          \DataTypeTok{min =} \DecValTok{0}\NormalTok{,}
          \DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }
          \DataTypeTok{value =} \DecValTok{500}
\NormalTok{        ),}
        \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{      ),}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Second Tab"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{, }\StringTok{"More"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The result is shown in Figure \ref{fig:tabler-nav}. I'd also suggest to include at least 1 input/output per tab, to test whether everything works properly.

\begin{figure}
\includegraphics[width=15.04in]{images/practice/tabler-nav} \caption{Tabler template with navbar}\label{fig:tabler-nav}
\end{figure}

Looks like we are done for the main template elements. Actually, wouldn't it be better to include, at least, card containers?

\hypertarget{card-containers}{%
\subsection{Card containers}\label{card-containers}}

Card are a central piece of template as they may contain visualizations, metrics and much more. Fortunately, Tabler has a large range of card containers.

\hypertarget{classic-card}{%
\subsubsection{Classic card}\label{classic-card}}

What I call a classic card is like the \texttt{box} container of \href{https://rstudio.github.io/shinydashboard/structure.html}{shinydashboard}. The card structure has key elements:

\begin{itemize}
\tightlist
\item
  a width to control the space taken by the card in the Bootstrap \href{https://getbootstrap.com/docs/4.0/layout/grid/}{grid}
\item
  a title, in general in the header (tabler does always not follow this rule and header is optional)
\item
  a body where is the main content
\item
  style elements like color statuses
\item
  a footer (optional, tabler does not include this)
\end{itemize}

A comprehensive list of all tabler card features may be found \href{https://preview-dev.tabler.io/docs/cards.html}{here}. To be faster, I will copy the following HTML code in the \href{https://github.com/alandipert/html2r}{html2R} shiny app to convert it to Shiny tags

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"col-md-6"}\KeywordTok{>}
  \KeywordTok{<div}\OtherTok{ class=}\StringTok{"card"}\KeywordTok{>}
    \KeywordTok{<div}\OtherTok{ class=}\StringTok{"card-status-top bg-danger"}\KeywordTok{></div>}
    \KeywordTok{<div}\OtherTok{ class=}\StringTok{"card-body"}\KeywordTok{>}
      \KeywordTok{<h3}\OtherTok{ class=}\StringTok{"card-title"}\KeywordTok{>}\NormalTok{Title}\KeywordTok{</h3>}
      \KeywordTok{<p>}\NormalTok{Some Text.}\KeywordTok{</p>}
    \KeywordTok{</div>}
  \KeywordTok{</div>}
\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

Below is the result. The next step consist in replacing all content by parameters to the \texttt{tabler\_card} function, whenever necessary. For instance, the first \texttt{\textless{}div\textgreater{}} sets the width of the card. The Bootstrap grid ranges from 0 to 12, so why not creating a width parameter to control the card size. We proceed similarly for the title, status, body content. It seems reasonable to allow title to be NULL (if so, the title will not be shown), same thing for the status. Regarding the card default width, a value of six also makes sense, which would take half of the row.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{padding =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  card_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"card"}\NormalTok{, }
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" card-"}\NormalTok{, padding)}
\NormalTok{  )}
  
\NormalTok{  status_tag <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
    \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"card-status-top bg-"}\NormalTok{, status))}
\NormalTok{  \}}
  
\NormalTok{  body_tag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"card-body"}\NormalTok{,}
    \CommentTok{# we could have a smaller title like h4 or h5...}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) \{}
      \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, title)}
\NormalTok{    \},}
\NormalTok{    ...}
\NormalTok{  )}
  
\NormalTok{  main_wrapper <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"col-md-"}\NormalTok{, width))}
\NormalTok{  card_wrapper <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =}\NormalTok{ card_cl)}
  
\NormalTok{  card_wrapper <-}\StringTok{ }\NormalTok{card_wrapper }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChildren}\NormalTok{(status_tag, body_tag)}
\NormalTok{  main_wrapper }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChild}\NormalTok{(card_wrapper)}
\NormalTok{\}}

\CommentTok{# test the card}
\KeywordTok{data}\NormalTok{(}\StringTok{"economics_long"}\NormalTok{)}
\NormalTok{economics_long <-}\StringTok{ }\NormalTok{economics_long }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(variable) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice}\NormalTok{((}\KeywordTok{n}\NormalTok{()}\OperatorTok{-}\DecValTok{100}\NormalTok{)}\OperatorTok{:}\KeywordTok{n}\NormalTok{())}


\NormalTok{my_card <-}\StringTok{ }\KeywordTok{tabler_card}\NormalTok{(}
  \KeywordTok{apexchartOutput}\NormalTok{(}\StringTok{"my_chart"}\NormalTok{), }
  \DataTypeTok{title =} \StringTok{"My card"}\NormalTok{, }
  \DataTypeTok{status =} \StringTok{"danger"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In the meantime, I'd be also nice to be able to display cards in the same row. Let's create the \texttt{tabler\_row}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_row <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"row row-deck"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{spark_data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{date =} \KeywordTok{Sys.Date}\NormalTok{() }\OperatorTok{+}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{,}
  \DataTypeTok{var1 =} \KeywordTok{round}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{10}\NormalTok{)),}
  \DataTypeTok{var2 =} \KeywordTok{round}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{10}\NormalTok{)),}
  \DataTypeTok{var3 =} \KeywordTok{round}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\NormalTok{)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_row}\NormalTok{(}
\NormalTok{      my_card,}
      \KeywordTok{tabler_card}\NormalTok{(}
        \KeywordTok{apexchartOutput}\NormalTok{(}\StringTok{"spark_box"}\NormalTok{), }
        \DataTypeTok{title =} \StringTok{"My card"}\NormalTok{, }
        \DataTypeTok{status =} \StringTok{"success"}
\NormalTok{      ) }
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{my_chart <-}\StringTok{ }\KeywordTok{renderApexchart}\NormalTok{(\{}
    \KeywordTok{apex}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ economics_long, }\DataTypeTok{type =} \StringTok{"area"}\NormalTok{, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ date, }\DataTypeTok{y =}\NormalTok{ value01, }\DataTypeTok{fill =}\NormalTok{ variable)) }\OperatorTok{%>%}
\StringTok{      }\KeywordTok{ax_yaxis}\NormalTok{(}\DataTypeTok{decimalsInFloat =} \DecValTok{2}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\CommentTok{# number of decimals to keep}
\StringTok{      }\KeywordTok{ax_chart}\NormalTok{(}\DataTypeTok{stacked =} \OtherTok{TRUE}\NormalTok{) }\OperatorTok{%>%}
\StringTok{      }\KeywordTok{ax_yaxis}\NormalTok{(}\DataTypeTok{max =} \DecValTok{4}\NormalTok{, }\DataTypeTok{tickAmount =} \DecValTok{4}\NormalTok{)}
\NormalTok{  \})}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{spark_box <-}\StringTok{ }\KeywordTok{renderApexchart}\NormalTok{(\{}
    \KeywordTok{spark_box}\NormalTok{(}
      \DataTypeTok{data =}\NormalTok{ spark_data[, }\KeywordTok{c}\NormalTok{(}\StringTok{"date"}\NormalTok{, }\StringTok{"var3"}\NormalTok{)],}
      \DataTypeTok{title =} \KeywordTok{mean}\NormalTok{(spark_data}\OperatorTok{$}\NormalTok{var3), }
      \DataTypeTok{subtitle =} \StringTok{"Variable 3"}\NormalTok{,}
      \DataTypeTok{color =} \StringTok{"#FFF"}\NormalTok{, }\DataTypeTok{background =} \StringTok{"#2E93fA"}\NormalTok{,}
      \DataTypeTok{title_style =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{color =} \StringTok{"#FFF"}\NormalTok{),}
      \DataTypeTok{subtitle_style =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{color =} \StringTok{"#FFF"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The code output is also shown in Figure \ref{fig:tabler-card}.

\begin{figure}
\includegraphics[width=14.85in]{images/practice/tabler-card} \caption{Tabler card component}\label{fig:tabler-card}
\end{figure}

\hypertarget{ribbons-card-components}{%
\subsection{Ribbons: card components}\label{ribbons-card-components}}

Let's finish this part by including a card component, namely the \href{https://preview-dev.tabler.io/docs/ribbons.html}{ribbon}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_ribbon <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{position =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{color =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{bookmark =} \OtherTok{FALSE}\NormalTok{) \{}
  
\NormalTok{  ribbon_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"ribbon"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(position)) }\KeywordTok{sprintf}\NormalTok{(}\StringTok{" bg-%s"}\NormalTok{, position),}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(color)) }\KeywordTok{sprintf}\NormalTok{(}\StringTok{" bg-%s"}\NormalTok{, color),}
    \ControlFlowTok{if}\NormalTok{ (bookmark) }\StringTok{" ribbon-bookmark"}
\NormalTok{  )}
  \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =}\NormalTok{ ribbon_cl, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Integrating the freshly created ribbon component requires to modify the card structure since the ribbon is added after the body tag, and not parameter is associated with this slot. We could also modify the \texttt{tabler\_card} function but htmltools contains tools to help us. Since the ribbon should be put after the card body (but in the card container), we may think about the \texttt{tagAppendChild} function, introduced in Chapter \ref{htmltools-overview}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# add the ribbon to a card}
\NormalTok{my_card <-}\StringTok{ }\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{title =} \StringTok{"Ribbon"}\NormalTok{, }\DataTypeTok{status =} \StringTok{"info"}\NormalTok{)}

\KeywordTok{str}\NormalTok{(my_card)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 3
##  $ name    : chr "div"
##  $ attribs :List of 1
##   ..$ class: chr "col-md-6"
##  $ children:List of 1
##   ..$ :List of 3
##   .. ..$ name    : chr "div"
##   .. ..$ attribs :List of 1
##   .. .. ..$ class: chr "card"
##   .. ..$ children:List of 2
##   .. .. ..$ :List of 3
##   .. .. .. ..$ name    : chr "div"
##   .. .. .. ..$ attribs :List of 1
##   .. .. .. .. ..$ class: chr "card-status-top bg-info"
##   .. .. .. ..$ children: list()
##   .. .. .. ..- attr(*, "class")= chr "shiny.tag"
##   .. .. ..$ :List of 3
##   .. .. .. ..$ name    : chr "div"
##   .. .. .. ..$ attribs :List of 1
##   .. .. .. .. ..$ class: chr "card-body"
##   .. .. .. ..$ children:List of 1
##   .. .. .. .. ..$ :List of 3
##   .. .. .. .. .. ..$ name    : chr "h3"
##   .. .. .. .. .. ..$ attribs :List of 1
##   .. .. .. .. .. .. ..$ class: chr "card-title"
##   .. .. .. .. .. ..$ children:List of 1
##   .. .. .. .. .. .. ..$ : chr "Ribbon"
##   .. .. .. .. .. ..- attr(*, "class")= chr "shiny.tag"
##   .. .. .. ..- attr(*, "class")= chr "shiny.tag"
##   .. ..- attr(*, "class")= chr "shiny.tag"
##  - attr(*, "class")= chr "shiny.tag"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_card}\OperatorTok{$}\NormalTok{children[[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\NormalTok{my_card}\OperatorTok{$}\NormalTok{children[[}\DecValTok{1}\NormalTok{]] }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{tagAppendChild}\NormalTok{(}
    \KeywordTok{tabler_ribbon}\NormalTok{(}
      \KeywordTok{icon}\NormalTok{(}\StringTok{"info-circle"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"fa-lg"}\NormalTok{), }
      \DataTypeTok{bookmark =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{color =} \StringTok{"red"}
\NormalTok{    )}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

As shown above, the ribbon has been successfuly included in the card tag. Now, we check how it looks in a shiny app.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
\NormalTok{    my_card}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=7.58in]{images/practice/tabler-ribbon} \caption{Tabler ribbon component}\label{fig:tabler-ribbon}
\end{figure}

\hypertarget{icons}{%
\subsection{Icons}\label{icons}}

Not mentionned before but we may include fontawesome icons provided with Shiny, as well as other libraries. Moreover, Tabler has a internal svg library located \href{https://preview-dev.tabler.io/icons.html}{here}.

\hypertarget{exercises}{%
\section{Exercises}\label{exercises}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Consider the tab card at the very bottom of the tabler \href{https://preview-dev.tabler.io/docs/cards.html}{documentation}. Propose an implementation of that feature.
\item
  Have a look at this \href{https://preview-dev.tabler.io/snippets.html}{page}. Select 2 elements and create the corresponding R functions.
\end{enumerate}

\hypertarget{custom-templates-testing}{%
\chapter{Testing and validating templates elements}\label{custom-templates-testing}}

Until now, we have been building the template boilerplates, that is the main skeleton functions (page, navbar, navbar menu, \ldots{}) as well as some components such as cards, ribbons, progress bars. We also exposed some techniques to substantially give more interactivity to the template, leveraging our freshly adquired JavaScript skills. Does this mean we are ready to make the template public? Not yet since some essentials steps are missing:

\begin{itemize}
\tightlist
\item
  Input validation is a crucial step toward success. Briefly, it consists in checking user inputs so that your functions fail safely and elegantly by providing meaningful error messages or warnings. This concept has already been covered in R for Data Science, Advanced R and a lot of other resources. Hence, I am not trying to reinvent the wheel and we will rely on already existing patterns, whose effectiveness is no longer to be demonstrated. Welcome to the defensive programming world!
\item
  On the other hand, testing components allows to check if a functions does what it is supposed to do. Consequently, it is a proof of robustness, and increases reproducibility. It significantly reduces the mental load when it comes to start code refactoring, thereby making you feel slightly less guilty about creating breaking changes since, most of the time, your tests will be able to capture those error.
\end{itemize}

\hypertarget{validate-template-functions}{%
\section{Validate template functions}\label{validate-template-functions}}

\hypertarget{create-your-own-validations}{%
\subsection{Create your own validations}\label{create-your-own-validations}}

Below, we will show some examples to validate user inputs. We first consider the \texttt{tabler\_card} element from Chapter \ref{custom-templates-skeleton}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{stacked =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{padding =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  card_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"card"}\NormalTok{, }
    \ControlFlowTok{if}\NormalTok{ (stacked) }\StringTok{" card-stacked"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" card-"}\NormalTok{, padding)}
\NormalTok{  )}
  
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"col-md-"}\NormalTok{, width),}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ card_cl,}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
        \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"card-status-top bg-"}\NormalTok{, status))}
\NormalTok{      \},}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body"}\NormalTok{,}
        \CommentTok{# we could have a smaller title like h4 or h5...}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) \{}
          \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, title)}
\NormalTok{        \},}
\NormalTok{        ...}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The first thing is to think about what to validate. Here, I see at least 3 test:

\begin{itemize}
\tightlist
\item
  checking the status value
\item
  checking the width value
\item
  checking the padding value
\end{itemize}

Writing validation tests requires knowledge about the underlying mechanisms. In our case, we must know the Bootstrap 4 grid rules and valid color statuses. The Bootstrap 4 \href{https://getbootstrap.com/docs/4.0/layout/grid/}{grid} ranges from 1 to 12. In other words, a card having a width of 12 will take the full page wherease, we may align 3 cards or width 4. Valid \href{https://getbootstrap.com/docs/4.0/utilities/colors/}{statuses} are primary, secondary, success, info, danger, warning, light and dark.

It is therefore pretty straightforward to validate the card width: it must be numeric and between 1 and 12. Moreover, since the template has other containers including the width parameter, we will create a function

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{validate_width <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(width) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.numeric}\NormalTok{(width)) \{}
    \ControlFlowTok{if}\NormalTok{ (width }\OperatorTok{<}\StringTok{ }\DecValTok{1} \OperatorTok{||}\StringTok{ }\NormalTok{width }\OperatorTok{>}\StringTok{ }\DecValTok{12}\NormalTok{) \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"width must belong to [1, 12], as per Bootstrap 4 grid documentation. See more at https://getbootstrap.com/docs/4.0/layout/grid/"}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"width must be numeric"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}

\CommentTok{# validate_width(-1)}
\CommentTok{# validate_width(13)}
\CommentTok{# validate_width("string")}
\end{Highlighting}
\end{Shaded}

To check the status parameter, we save the valid statuses in a vector and take the \texttt{validStatuses} function from shinydashboard \href{https://github.com/rstudio/shinydashboard/blob/master/R/utils.R}{utils}. It also make sense to create a function since this parameter is widely used among template components. Contrary to the shinydashboard function, our custom \texttt{valid\_status} does not fail if the status is NULL since it is not a mandatory parameter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{valid_statuses <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"primary"}\NormalTok{, }
  \StringTok{"secondary"}\NormalTok{,}
  \StringTok{"success"}\NormalTok{, }
  \StringTok{"info"}\NormalTok{, }
  \StringTok{"warning"}\NormalTok{, }
  \StringTok{"danger"}\NormalTok{,}
  \StringTok{"light"}\NormalTok{,}
  \StringTok{"dark"}
\NormalTok{)}

\NormalTok{validate_status <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(status) \{}

  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(status)) \{}
    \KeywordTok{return}\NormalTok{(}\OtherTok{TRUE}\NormalTok{) }
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \ControlFlowTok{if}\NormalTok{ (status }\OperatorTok{%in%}\StringTok{ }\NormalTok{valid_statuses) \{}
      \KeywordTok{return}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}

  \KeywordTok{stop}\NormalTok{(}\StringTok{"Invalid status: "}\NormalTok{, status, }\StringTok{". Valid statuses are: "}\NormalTok{,}
       \KeywordTok{paste}\NormalTok{(valid_statuses, }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{), }\StringTok{"."}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We finish by the padding validation. According to the tabler documentation, there are three possible choices, namely \texttt{sm}, \texttt{md} or \texttt{lg}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{valid_paddings <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"sm"}\NormalTok{, }\StringTok{"md"}\NormalTok{, }\StringTok{"lg"}\NormalTok{)}

\NormalTok{validate_padding <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(padding) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) \{}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{(padding }\OperatorTok{%in%}\StringTok{ }\NormalTok{valid_paddings)) \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"Invalid status: "}\NormalTok{, padding, }\StringTok{". Valid choices are: "}\NormalTok{,}
       \KeywordTok{paste}\NormalTok{(valid_paddings, }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{), }\StringTok{"."}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We apply all these validation to our card element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{stacked =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{padding =} \OtherTok{NULL}\NormalTok{) \{}
  
  \KeywordTok{validate_status}\NormalTok{(status)}
  \KeywordTok{validate_width}\NormalTok{(width)}
  \KeywordTok{validate_padding}\NormalTok{(padding)}
  
\NormalTok{  card_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"card"}\NormalTok{, }
    \ControlFlowTok{if}\NormalTok{ (stacked) }\StringTok{" card-stacked"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" card-"}\NormalTok{, padding)}
\NormalTok{  )}
  
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"col-md-"}\NormalTok{, width),}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ card_cl,}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
        \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"card-status-top bg-"}\NormalTok{, status))}
\NormalTok{      \},}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body"}\NormalTok{,}
        \CommentTok{# we could have a smaller title like h4 or h5...}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) \{}
          \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, title)}
\NormalTok{        \},}
\NormalTok{        ...}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As of R 4.0.0, the \texttt{stopifnot} function may be a good alternative to \texttt{stop}.

We recommand to be reasonable and not to validate every single parameter.

\hypertarget{existing-utils-functions}{%
\subsection{Existing utils functions}\label{existing-utils-functions}}

\hypertarget{validating-tags}{%
\subsubsection{Validating tags}\label{validating-tags}}

The problem with the above approach is that it may take time to create all validation functions. Fortunately, packages like \{shinydashboard\} include really powerful validation functions, especially \texttt{tagAssert}. It is not exported which means you will have to import it in your own project. Below is the code, where I left the documentation describing all parameters.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Return TRUE if a shiny.tag object has a CSS class, FALSE otherwise.}
\NormalTok{hasCssClass <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, class) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(tag}\OperatorTok{$}\NormalTok{attribs) }\OperatorTok{||}\StringTok{ }\KeywordTok{is.null}\NormalTok{(tag}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class))}
    \KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}

\NormalTok{  classes <-}\StringTok{ }\KeywordTok{strsplit}\NormalTok{(tag}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class, }\StringTok{" +"}\NormalTok{)[[}\DecValTok{1}\NormalTok{]]}
  \KeywordTok{return}\NormalTok{(class }\OperatorTok{%in%}\StringTok{ }\NormalTok{classes)}
\NormalTok{\}}

\NormalTok{tagAssert <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, }\DataTypeTok{type =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{class =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{allowUI =} \OtherTok{TRUE}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{inherits}\NormalTok{(tag, }\StringTok{"shiny.tag"}\NormalTok{)) \{}
    \KeywordTok{print}\NormalTok{(tag)}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Expected an object with class 'shiny.tag'."}\NormalTok{)}
\NormalTok{  \}}

  \CommentTok{# Skip dynamic output elements}
  \ControlFlowTok{if}\NormalTok{ (allowUI }\OperatorTok{&&}
\StringTok{      }\NormalTok{(}\KeywordTok{hasCssClass}\NormalTok{(tag, }\StringTok{"shiny-html-output"}\NormalTok{) }\OperatorTok{||}
\StringTok{       }\KeywordTok{hasCssClass}\NormalTok{(tag, }\StringTok{"shinydashboard-menu-output"}\NormalTok{))) \{}
    \KeywordTok{return}\NormalTok{()}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(type) }\OperatorTok{&&}\StringTok{ }\NormalTok{tag}\OperatorTok{$}\NormalTok{name }\OperatorTok{!=}\StringTok{ }\NormalTok{type) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Expected tag to be of type "}\NormalTok{, type)}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(class)) \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(tag}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class)) \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"Expected tag to have class '"}\NormalTok{, class, }\StringTok{"'"}\NormalTok{)}

\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      tagClasses <-}\StringTok{ }\KeywordTok{strsplit}\NormalTok{(tag}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class, }\StringTok{" "}\NormalTok{)[[}\DecValTok{1}\NormalTok{]]}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{(class }\OperatorTok{%in%}\StringTok{ }\NormalTok{tagClasses)) \{}
        \KeywordTok{stop}\NormalTok{(}\StringTok{"Expected tag to have class '"}\NormalTok{, class, }\StringTok{"'"}\NormalTok{)}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{myTag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"bg-blue"}\NormalTok{)}

\KeywordTok{tagAssert}\NormalTok{(myTag, }\DataTypeTok{type =} \StringTok{"div"}\NormalTok{)}
\CommentTok{# tagAssert(myTag, type = "li") # will fail}
\KeywordTok{tagAssert}\NormalTok{(myTag, }\DataTypeTok{class =} \StringTok{"bg-blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Importantly, \texttt{tagAssert} will raise an error if the condition is not fulfilled. Another function, \texttt{tagMatch} simply returns TRUE/FALSE. It looks for \texttt{d}, \texttt{class}, \texttt{name} and any other tag attribute like \texttt{data-value}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# This is like a==b, except that if a or b is NULL or an empty vector, it won't}
\CommentTok{# return logical(0). If a AND b are NULL/length-0, this will return TRUE; if}
\CommentTok{# just one of them is NULL/length-0, this will FALSE. This is for use in}
\CommentTok{# conditionals where `if(logical(0))` would cause an error. Similar to using}
\CommentTok{# identical(a,b), but less stringent about types: `equals(1, 1L)` is TRUE, but}
\CommentTok{# `identical(1, 1L)` is FALSE.}
\NormalTok{equals <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
\NormalTok{  alen <-}\StringTok{ }\KeywordTok{length}\NormalTok{(a)}
\NormalTok{  blen <-}\StringTok{ }\KeywordTok{length}\NormalTok{(b)}
  \ControlFlowTok{if}\NormalTok{ (alen}\OperatorTok{==}\DecValTok{0} \OperatorTok{&&}\StringTok{ }\NormalTok{blen}\OperatorTok{==}\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{return}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (alen }\OperatorTok{>}\StringTok{ }\DecValTok{1} \OperatorTok{||}\StringTok{ }\NormalTok{blen }\OperatorTok{>}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Can only compare objects of length 0 or 1"}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (alen}\OperatorTok{==}\DecValTok{0} \OperatorTok{||}\StringTok{ }\NormalTok{blen}\OperatorTok{==}\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \}}

\NormalTok{  a }\OperatorTok{==}\StringTok{ }\NormalTok{b}
\NormalTok{\}}


\CommentTok{# Return TRUE if a tag object matches a specific id, and/or tag name, and/or}
\CommentTok{# class, and or other arbitrary tag attributes. Put the args after ... so that}
\CommentTok{# caller must use named arguments.}
\NormalTok{tagMatches <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(item, ..., }\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{name =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{class =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{list}\NormalTok{(...)}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{inherits}\NormalTok{(item, }\StringTok{"shiny.tag"}\NormalTok{)) \{}
    \KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(id) }\OperatorTok{&&}\StringTok{ }\OperatorTok{!}\KeywordTok{equals}\NormalTok{(item}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id, id)) \{}
    \KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(name) }\OperatorTok{&&}\StringTok{ }\OperatorTok{!}\KeywordTok{equals}\NormalTok{(item}\OperatorTok{$}\NormalTok{name, name)) \{}
    \KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(class)) \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(item}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class)) \{}
      \KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{    classes <-}\StringTok{ }\KeywordTok{strsplit}\NormalTok{(item}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class, }\StringTok{" "}\NormalTok{)[[}\DecValTok{1}\NormalTok{]]}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\StringTok{ }\NormalTok{class }\OperatorTok{%in%}\StringTok{ }\NormalTok{classes) \{}
      \KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}

  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(dots)) \{}
\NormalTok{    arg     <-}\StringTok{ }\NormalTok{dots[[i]]}
\NormalTok{    argName <-}\StringTok{ }\KeywordTok{names}\NormalTok{(dots)[[i]]}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{equals}\NormalTok{(item}\OperatorTok{$}\NormalTok{attribs[[argName]], arg)) \{}
      \KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}

  \OtherTok{TRUE}
\NormalTok{\}}

\KeywordTok{tagMatches}\NormalTok{(myTag, }\DataTypeTok{id =} \StringTok{"d"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tagMatches}\NormalTok{(myTag, }\DataTypeTok{class =} \StringTok{"bg-blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\hypertarget{validating-css-units}{%
\subsubsection{Validating CSS units}\label{validating-css-units}}

The \texttt{validateCssUnit} belongs to the Shiny exported function. It is useful to validate any parameter involving a CSS unit like \texttt{width} and \texttt{height}.

There is no point to reuse what already exists and these tools will help you to be efficient for validating your template elements.

\hypertarget{testing-templates-elements}{%
\section{Testing templates elements}\label{testing-templates-elements}}

Imagine if one day, someone or yourself accidentaly remove the width validation function, after a significant refactoring. Later, you receive a new message from github, stating that someome opened a new issue. According to the report, the card is not properly displayed altough no error is thrown. Among the 400 lines of code provided, you hardly notice that the width parameter is set to 13, which is not in line with the Bootstrap 4 documentation, as it should remain between 1 and 12. You lost 10 minutes, so is your end user, which is even worse.

With a proper testing pipeline, this problem could have been avoided. Ironically, writing the corresponding test takes only 2 minutes.

A reference for testing functions is the \href{https://testthat.r-lib.org/index.html}{\{testthat\}} package. In short, a unit test consists in setting expectations about our function and check weither they fail or pass. For instance, with our \texttt{tabler\_card} example, the \texttt{validate\_width} must fail if the given width is not in the expected bounds or not numeric. We apply the \texttt{test\_that} function with a description of the test context, followed by the expectations inside the curly brackets.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{test_that}\NormalTok{(}\StringTok{"validate width works"}\NormalTok{, \{}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \DecValTok{-1}\NormalTok{))}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \DecValTok{13}\NormalTok{))}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \StringTok{"hello world"}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We then test \texttt{validate\_status} and \texttt{validate\_padding}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{test_that}\NormalTok{(}\StringTok{"validate status works"}\NormalTok{, \{}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{status =} \StringTok{"toto"}\NormalTok{))}
\NormalTok{\})}

\KeywordTok{test_that}\NormalTok{(}\StringTok{"validate padding works"}\NormalTok{, \{}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \StringTok{"xs"}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

So far so good. In few lines of code, we substantially increased the robustness of our function without increasing its complexity. Now, let's try to remove the \texttt{validate\_width} step from the \texttt{tabler\_card}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{stacked =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{padding =} \OtherTok{NULL}\NormalTok{) \{}
  
  \KeywordTok{validate_status}\NormalTok{(status)}
  \KeywordTok{validate_padding}\NormalTok{(padding)}
  
\NormalTok{  card_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"card"}\NormalTok{, }
    \ControlFlowTok{if}\NormalTok{ (stacked) }\StringTok{" card-stacked"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" card-"}\NormalTok{, padding)}
\NormalTok{  )}
  
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"col-md-"}\NormalTok{, width),}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ card_cl,}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
        \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"card-status-top bg-"}\NormalTok{, status))}
\NormalTok{      \},}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body"}\NormalTok{,}
        \CommentTok{# we could have a smaller title like h4 or h5...}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) \{}
          \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, title)}
\NormalTok{        \},}
\NormalTok{        ...}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{\}}


\KeywordTok{test_that}\NormalTok{(}\StringTok{"validate width works"}\NormalTok{, \{}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \DecValTok{-1}\NormalTok{))}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \DecValTok{13}\NormalTok{))}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \StringTok{"hello world"}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Notice how the 3 above tests elegantly fail. The provided context (``validate width works'') immediately indicates the culprit, which is a game changer for debugging.

\hypertarget{testing-javascript}{%
\section{Testing JavaScript}\label{testing-javascript}}

We could not finish this chapter without mentionning tools to validate JavaScript code. We will particularly focus on \href{https://jshint.com}{JSHint}, which has a R \href{https://github.com/dreamRs/jstools}{wrapper}, nicely provided by the dreamRs team. Below is an example of how to check all the \href{https://github.com/RinteRface/shinyMobile}{shinyMobile} JavaScript input bindings at once:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bindings <-}\StringTok{ }\KeywordTok{list.files}\NormalTok{(}
  \DataTypeTok{path =} \KeywordTok{system.file}\NormalTok{(}\StringTok{"framework7-5.5.0/input-bindings"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"shinyMobile"}\NormalTok{),}
  \DataTypeTok{recursive =} \OtherTok{TRUE}\NormalTok{,}
  \DataTypeTok{full.names =} \OtherTok{TRUE}
\NormalTok{)}
\KeywordTok{jshint_file}\NormalTok{(}\DataTypeTok{input =}\NormalTok{ bindings, }\DataTypeTok{options =} \KeywordTok{jshint_options}\NormalTok{(}\DataTypeTok{jquery =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{globals =} \KeywordTok{list}\NormalTok{(}\StringTok{"Shiny"}\NormalTok{, }\StringTok{"app"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## -- Checking actionSheetInputBinding.js ----------------------------------------- 
## No errors found. 
## -- Checking autoCompleteInputBinding.js ---------------------------------------- 
## No errors found. 
## -- Checking buttonInputBinding.js ---------------------------------------------- 
## No errors found. 
## -- Checking cardInputBinding.js ------------------------------------------------ 
## No errors found. 
## -- Checking collapsibleInputBinding.js ----------------------------------------- 
## No errors found. 
## -- Checking colorPickerInputBinding.js ----------------------------------------- 
## 9 errors found. 
##  - Line 11: 'colorPickerModules' is not defined. 
##  - Line 16: 'colorPickerSliderValue' is not defined. 
##  - Line 17: 'colorPickerSliderValueEditable' is not defined. 
##  - Line 18: 'colorPickerSliderLabel' is not defined. 
##  - Line 19: 'colorPickerHexLabel' is not defined. 
##  - Line 20: 'colorPickerHexValueEditable' is not defined. 
##  - Line 21: 'colorPickerGroupedModules' is not defined. 
##  - Line 24: 'colorPickerPalettes' is not defined. 
##  - Line 29: 'colorPickerValue' is not defined. 
## -- Checking dateInputBinding.js ------------------------------------------------ 
## 1 errors found. 
##  - Line 11: 'console' is not defined. 
## -- Checking datePickerInputBinding.js ------------------------------------------ 
## No errors found. 
## -- Checking fabsInputBinding.js ------------------------------------------------ 
## No errors found. 
## -- Checking gaugeInputBinding.js ----------------------------------------------- 
## 1 errors found. 
##  - Line 47: 'g' is defined but never used. 
## -- Checking loginInputBinding.js ----------------------------------------------- 
## No errors found. 
## -- Checking messageBarInputBinding.js ------------------------------------------ 
## No errors found. 
## -- Checking messagesInputBinding.js -------------------------------------------- 
## 2 errors found. 
##  - Line 70: 'responseInProgress' is not defined. 
##  - Line 85: 'responseInProgress' is not defined. 
## -- Checking panelInputBinding.js ----------------------------------------------- 
## No errors found. 
## -- Checking pickerInputBinding.js ---------------------------------------------- 
## No errors found. 
## -- Checking popupInputBinding.js ----------------------------------------------- 
## 1 errors found. 
##  - Line 20: 'p' is defined but never used. 
## -- Checking selectInputBinding.js ---------------------------------------------- 
## No errors found. 
## -- Checking sheetInputBinding.js ----------------------------------------------- 
## 1 errors found. 
##  - Line 34: 's' is defined but never used. 
## -- Checking sliderInputBinding.js ---------------------------------------------- 
## 1 errors found. 
##  - Line 35: 'r' is defined but never used. 
## -- Checking smartSelectBinding.js ---------------------------------------------- 
## No errors found. 
## -- Checking stepperInputBinding.js --------------------------------------------- 
## 1 errors found. 
##  - Line 33: 's' is defined but never used. 
## -- Checking tabsInputBinding.js ------------------------------------------------ 
## No errors found. 
## -- Checking toggleInputBinding.js ---------------------------------------------- 
## No errors found. 
## -- Checking virtualListBinding.js ---------------------------------------------- 
## 3 errors found. 
##  - Line 21: 'for of' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). 
##  - Line 107: 'template literal syntax' is only available in ES6 (use 'esversion: 6'). 
##  - Line 111: 'template literal syntax' is only available in ES6 (use 'esversion: 6').
\end{verbatim}

You may fine tune the \texttt{jshint\_file} behavior with the \href{https://jshint.com/docs/options/}{\texttt{jshint\_options}}. One is often tempted to call \texttt{eval} in JS code, which will result in a JSHint error. An option called \texttt{evil} exists to disable the corresponding test. However, we recommand to play the game, accept those error and try to fix them instead of cheating with options!

\hypertarget{custom-templates-inputs}{%
\chapter{Develop custom input widgets}\label{custom-templates-inputs}}

In the previous chapter, we built template dependencies, the page skeleton, as well as containers like cards. However, it would be nice to customize user interactions by integrating new inputs. In this chapter, we will apply knowledge from Chapter \ref{shiny-input-system} about creating new Shiny input.

\hypertarget{tabler-action-button}{%
\section{Tabler action button}\label{tabler-action-button}}

Let's start with a simple input: the action button. Tabler has built-in HTML buttons with a substantial amount of custom styles, compared to the classic Shiny action button.

\hypertarget{reminders-about-the-action-button}{%
\subsection{Reminders about the action button}\label{reminders-about-the-action-button}}

Below is the code of the \texttt{actionButton} input.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{actionButton <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (inputId, label, }\DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \OtherTok{NULL}\NormalTok{, ...)  \{}
\NormalTok{  value <-}\StringTok{ }\KeywordTok{restoreInput}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{default =} \OtherTok{NULL}\NormalTok{)}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{(}
    \DataTypeTok{id =}\NormalTok{ inputId, }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, }\KeywordTok{validateCssUnit}\NormalTok{(width), }\StringTok{";"}\NormalTok{), }
    \DataTypeTok{type =} \StringTok{"button"}\NormalTok{, }
    \DataTypeTok{class =} \StringTok{"btn btn-default action-button"}\NormalTok{, }
    \StringTok{`}\DataTypeTok{data-val}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{value, }
    \KeywordTok{list}\NormalTok{(}\KeywordTok{validateIcon}\NormalTok{(icon), label), ...}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The button tag has some attributes: id, style, type, class, \texttt{data-val}, label and children passed via \texttt{...}

When the app starts, the action button has the value 0 and each click will increment its value by 1. How is this behaviour created? For each Shiny input element (radio, slider), there is an associated JavaScript file, called input binding, which you can find \href{https://github.com/rstudio/shiny/tree/master/srcjs}{here}. In our case, we are only interested in the action button binding:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ actionButtonInputBinding }\OperatorTok{=} \KeywordTok{new} \AttributeTok{InputBinding}\NormalTok{()}\OperatorTok{;}
\VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(actionButtonInputBinding}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
    \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{".action-button"}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
    \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\NormalTok{) }\OperatorTok{||} \DecValTok{0}\OperatorTok{;}
  \OperatorTok{\},}
  \CommentTok{// ... other methods}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

What you see above is \textbf{not} the whole script since we focus on the first method, that is \texttt{find}. It will look for \textbf{all} elements having the class \texttt{action-button}, making it possible to define multiple action buttons at the same time.

Consequently, if we go back to the previous section, the \texttt{actionButton} has the class \texttt{action-button}, thereby making it visible to the binding. Interestingly, all elements having the class \texttt{action-button} will be considered by the same shiny input binding.

\hypertarget{application-to-tabler}{%
\subsection{Application to Tabler}\label{application-to-tabler}}

First of all, let's compare the tabler HTML button to the Shiny action button.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<button}\OtherTok{ class=}\StringTok{"btn btn-primary"}\KeywordTok{>}\NormalTok{Button}\KeywordTok{</button>}
\end{Highlighting}
\end{Shaded}

We convert it to R. The button API contains more style and leave the reader to add extra elements as an exercise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_button <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, label, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \OtherTok{NULL}\NormalTok{, ...) \{}
  
\NormalTok{  btn_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"btn action-button"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(status)) \{}
      \StringTok{" btn-primary"}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \KeywordTok{paste0}\NormalTok{(}\StringTok{" btn-"}\NormalTok{, status)}
\NormalTok{    \}}
\NormalTok{  )}
  
\NormalTok{  value <-}\StringTok{ }\KeywordTok{restoreInput}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{default =} \OtherTok{NULL}\NormalTok{)}
  
  \CommentTok{# custom right margin}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(icon)) icon}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
\NormalTok{    icon}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class, }\StringTok{" mr-1"}
\NormalTok{  )}
  
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{(}
    \DataTypeTok{id =}\NormalTok{ inputId, }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, }\KeywordTok{validateCssUnit}\NormalTok{(width), }\StringTok{";"}\NormalTok{), }
    \DataTypeTok{type =} \StringTok{"button"}\NormalTok{, }
    \DataTypeTok{class =}\NormalTok{ btn_cl, }
    \StringTok{`}\DataTypeTok{data-val}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{value, }
    \KeywordTok{list}\NormalTok{(icon, label), ...}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In Tabler, the button status is mandatory, which is the reason why it is a parameter of the function. Moreover, we need to add an horizontal right margin to the icon, if provided so that the label renders well (\texttt{mr-1}, where m stands for margin, r is the right direction and 1 is the margin value). We assume that by default, the button wil have a blue color, that is given by \texttt{btn-primary}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_button}\NormalTok{(}
      \StringTok{"btn"}\NormalTok{, }
      \KeywordTok{HTML}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{"Value"}\NormalTok{, }\KeywordTok{textOutput}\NormalTok{(}\StringTok{"val"}\NormalTok{), }\DataTypeTok{sep =} \StringTok{":"}\NormalTok{)), }
      \DataTypeTok{icon =} \KeywordTok{icon}\NormalTok{(}\StringTok{"thumbs-up"}\NormalTok{), }
      \DataTypeTok{width =} \StringTok{"25%"}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{val <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(input}\OperatorTok{$}\NormalTok{btn)}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

We easily check that clicking on the button increments the related input. Thus, one may see how easy it is to implement a custom Tabler input button, built on top of the Shiny action button. The output is shown in Figure \ref{fig:tabler-button}.

\begin{figure}
\includegraphics[width=3.92in]{images/practice/tabler-button} \caption{Tabler action button}\label{fig:tabler-button}
\end{figure}

As a general rule, don't try to reinvent the wheel and see whether any existing Shiny element may be reused/adapted!

\hypertarget{toggle-switch}{%
\section{Toggle Switch}\label{toggle-switch}}

We implement the toggle \href{https://preview-dev.tabler.io/docs/form-elements.html\#custom-selectboxes}{switch} component.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<label}\OtherTok{ class=}\StringTok{"form-check form-switch"}\KeywordTok{>}
  \KeywordTok{<input}\OtherTok{ class=}\StringTok{"form-check-input"}\OtherTok{ type=}\StringTok{"checkbox"}\OtherTok{ checked}\KeywordTok{>}
  \KeywordTok{<span}\OtherTok{ class=}\StringTok{"form-check-label"}\KeywordTok{>}\NormalTok{Option 1}\KeywordTok{</span>}
\KeywordTok{</label>}
\end{Highlighting}
\end{Shaded}

Notice that the tabler switch has the checkbox type, which is very similar to the Shiny checkbox (a switch is a checkbox with a different style)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{checkboxInput}\NormalTok{(}\StringTok{"test"}\NormalTok{, }\StringTok{"Test"}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

{Test}

Therefore, we should again be able to build on top of an existing input \href{https://github.com/rstudio/shiny/blob/master/srcjs/input_binding_checkbox.js}{binding}. We create the \texttt{tabler\_switch} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_switch <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, label, }\DataTypeTok{value =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{width =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  value <-}\StringTok{ }\KeywordTok{restoreInput}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{default =}\NormalTok{ value)}
\NormalTok{  input_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{input}\NormalTok{(}
    \DataTypeTok{id =}\NormalTok{ inputId, }
    \DataTypeTok{type =} \StringTok{"checkbox"}\NormalTok{,}
    \DataTypeTok{class =} \StringTok{"form-check-input"}
\NormalTok{  )}
  
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(value) }\OperatorTok{&&}\StringTok{ }\NormalTok{value) \{}
\NormalTok{    input_tag <-}\StringTok{ }\NormalTok{input_tag }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendAttributes}\NormalTok{(}\DataTypeTok{checked =} \StringTok{"checked"}\NormalTok{)}
\NormalTok{  \}}
  
\NormalTok{  input_wrapper <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{label}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"form-check form-switch"}\NormalTok{, }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) \{}
      \KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, }\KeywordTok{validateCssUnit}\NormalTok{(width), }\StringTok{";"}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  )}
  
\NormalTok{  input_wrapper }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChildren}\NormalTok{(}
\NormalTok{    input_tag,}
    \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"form-check-label"}\NormalTok{, label)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Besides, we may also create an \texttt{update\_tabler\_switch} function similar to the \texttt{updateCheckboxInput}. We will also need \texttt{dropNulls}, a function that removes all NULL elements from a list (this function is often used in all custom Shiny templates). If you remember, the \texttt{sendInputMessage} from R will be received by the \texttt{receiveMessage} method on the JavaScript side.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dropNulls <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x) \{}
\NormalTok{  x[}\OperatorTok{!}\KeywordTok{vapply}\NormalTok{(x, is.null, }\DataTypeTok{FUN.VALUE =} \KeywordTok{logical}\NormalTok{(}\DecValTok{1}\NormalTok{))]}
\NormalTok{\}}

\NormalTok{update_tabler_switch <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (session, inputId, }\DataTypeTok{label =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{value =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{dropNulls}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{label =}\NormalTok{ label, }\DataTypeTok{value =}\NormalTok{ value))}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In the following example, the action button toggles the switch input value when clicked, as shown in Figure \ref{fig:tabler-toggle}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Go!"}\NormalTok{, }\DataTypeTok{width =} \StringTok{"25%"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"mr-2"}\NormalTok{),}
      \KeywordTok{tabler_switch}\NormalTok{(}\StringTok{"toggle"}\NormalTok{, }\StringTok{"Switch"}\NormalTok{, }\DataTypeTok{value =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{width =} \StringTok{"25%"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(}\KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{toggle))}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
    \KeywordTok{update_tabler_switch}\NormalTok{(}
\NormalTok{      session, }
      \StringTok{"toggle"}\NormalTok{, }
      \DataTypeTok{value =} \OperatorTok{!}\NormalTok{input}\OperatorTok{$}\NormalTok{toggle}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=4.88in]{images/practice/tabler-toggle} \caption{Tabler action button updating a toggle input}\label{fig:tabler-toggle}
\end{figure}

Et voil! Two inputs in few minutes.

\hypertarget{navbar-menu-input}{%
\section{Navbar menu input}\label{navbar-menu-input}}

We saw in Chapter \ref{survival-kit-shiny} that it is quite straightforward to bind other elements than pure inputs (HTML elements with the input tag) to Shiny. As a reminder, we created a custom input binding to detect the state of a shinydashboard box (collapsed/uncollapsed).
In chapter \ref{custom-templates-skeleton}, we created the \texttt{tabler\_navbar} as well as the \texttt{tabler\_navbar\_menu} and \texttt{tabler\_navbar\_menu\_item}. As in shinydashboard, it would be nice to capture the currently selected tab to be able to perform actions on the server side, updating the selected tab based on a button click.

Where do we start? First of all, we add an id attribute to the \texttt{tabler\_navbar\_menu} so that it holds the corresponding \texttt{input\$id}. Whether to use \texttt{inputId} or \texttt{id} as a parameter name is up to you, but keep in mind that \texttt{inputId} does not exist in HTML.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{inputId =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{ul}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{class =} \StringTok{"nav nav-pills navbar-nav"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The next step is the \texttt{navbarMenuBinding} creation. We decide to look for the \texttt{navbar-nav} class in the \texttt{find} method. Below, we describe the binding step by step. You may find the whole working code at the end of this example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
  \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{'.navbar-nav'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

In the \texttt{initialize} method, we ensure that if no tab is selected at start, the first tab will be selected by default. Otherwise, we select the activated tab. We use the string interpolation to ease the insertion of JS code in strings (\texttt{\$\{menuId\}\ .nav-link.active}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{initialize}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ menuId }\OperatorTok{=} \StringTok{'#'} \OperatorTok{+} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ .nav-link.active`}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// if multiple items are found}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{activeTab}\NormalTok{.}\AttributeTok{length} \OperatorTok{>} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{let}\NormalTok{ tabId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{tabId}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{addClass}\NormalTok{(}\StringTok{'show active'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ .nav-link`}\NormalTok{)}
\NormalTok{      .}\AttributeTok{first}\NormalTok{()}
\NormalTok{      .}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The role of \texttt{getValue} is to return the currently selected tab. As a reminder, here is the \texttt{tabler\_navbar\_menu\_item} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(text, tabName, }\DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{selected =} \OtherTok{FALSE}\NormalTok{) \{}
  
\NormalTok{  item_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"nav-link"}\NormalTok{, }\ControlFlowTok{if}\NormalTok{(selected) }\StringTok{" active"}\NormalTok{)}
  
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"nav-item"}\NormalTok{,}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ item_cl,}
      \DataTypeTok{href =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, tabName),}
      \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "pill"}\NormalTok{, }\CommentTok{# see https://getbootstrap.com/docs/4.0/components/navs/}
      \StringTok{`}\DataTypeTok{data-value}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{tabName,}
      \DataTypeTok{role =} \StringTok{"tab"}\NormalTok{,}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav-link-icon d-md-none d-lg-inline-block"}\NormalTok{, icon),}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav-link-title"}\NormalTok{, text)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

From that function, the active item has is the \texttt{a} element with the classes \texttt{nav-link\ active}. We recover the tab value stored in the \texttt{data-value} attribute. A bit of jQuery will do the trick!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{find}\NormalTok{(}\StringTok{'a'}\NormalTok{).}\AttributeTok{filter}\NormalTok{(}\StringTok{'nav-link active'}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{setValue} is the function allowing to update the active tab. Bootstrap 4 already has
predefined methods to \href{https://getbootstrap.com/docs/4.0/components/navs/\#via-javascript}{activate} tabs. The easiest way is to select the tab by name like \texttt{\$(\textquotesingle{}\#tabMenu\ a{[}href="\#tab1"{]}\textquotesingle{}).tab(\textquotesingle{}show\textquotesingle{})}. The \texttt{receiveMessage} is simply applying the \texttt{setValue} method.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ value) }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ hrefVal }\OperatorTok{=} \StringTok{'#'} \OperatorTok{+}\NormalTok{ value}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ menuId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
  \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ a[href="}\SpecialCharTok{$\{}\NormalTok{hrefVal}\SpecialCharTok{\}}\VerbatimStringTok{"]`}\NormalTok{).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}

\NormalTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{setValue}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Besides, we have to create the \texttt{update\_tabler\_tab\_item} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{update_tabler_tab_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, value, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, }\DataTypeTok{message =}\NormalTok{ value)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{subscribe} will tell Shiny when to change the current input value and made it available
in the whole app. We may listen to multiple events, keeping in mind that events occur in the following order:

\begin{itemize}
\tightlist
\item
  hide.bs.tab (on the current active tab)
\item
  show.bs.tab (on the to-be-shown tab)
\item
  hidden.bs.tab (on the previous active tab, the same one as for the hide.bs.tab event)
\item
  shown.bs.tab (on the newly-active just-shown tab, the same one as for the show.bs.tab event)
\end{itemize}

Hence, it makes more sense to listen to \texttt{shown.bs.tab} (wait the current tab to be shown).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
  \CommentTok{// important to use shown.bs.tab and not show.bs.tab!}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'shown.bs.tab.navbarMenuBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
    \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\},}
  
\NormalTok{unsubscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{off}\NormalTok{(}\StringTok{'.navbarMenuBinding'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Below is a recap of the binding with the creation and registration included:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// Input binding}
  \KeywordTok{let}\NormalTok{ navbarMenuBinding }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{InputBinding}\NormalTok{()}
  \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(navbarMenuBinding}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
      \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{'.navbar-nav'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{initialize}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
      \KeywordTok{let}\NormalTok{ menuId }\OperatorTok{=} \StringTok{'#'} \OperatorTok{+} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
      \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ .nav-link.active`}\NormalTok{)}\OperatorTok{;}
      \CommentTok{// if multiple items are found}
      \ControlFlowTok{if}\NormalTok{ (}\VariableTok{activeTab}\NormalTok{.}\AttributeTok{length} \OperatorTok{>} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
        \KeywordTok{let}\NormalTok{ tabId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
        \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
        \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{tabId}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{addClass}\NormalTok{(}\StringTok{'show active'}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
        \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ .nav-link`}\NormalTok{)}
\NormalTok{          .}\AttributeTok{first}\NormalTok{()}
\NormalTok{          .}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\},}
    \CommentTok{// Given the DOM element for the input, return the value}
    \DataTypeTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
      \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{find}\NormalTok{(}\StringTok{'a'}\NormalTok{).}\AttributeTok{filter}\NormalTok{(}\StringTok{'nav-link active'}\NormalTok{)}\OperatorTok{;}
      \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{setValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ value) }\OperatorTok{\{}
      \KeywordTok{let}\NormalTok{ hrefVal }\OperatorTok{=} \StringTok{'#'} \OperatorTok{+}\NormalTok{ value}\OperatorTok{;}
      \KeywordTok{let}\NormalTok{ menuId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
      \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ a[href="}\SpecialCharTok{$\{}\NormalTok{hrefVal}\SpecialCharTok{\}}\VerbatimStringTok{"]`}\NormalTok{).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
      \KeywordTok{this}\NormalTok{.}\AttributeTok{setValue}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
      \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'shown.bs.tab.navbarMenuBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
        \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{unsubscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
      \AttributeTok{$}\NormalTok{(el).}\AttributeTok{off}\NormalTok{(}\StringTok{'.navbarMenuBinding'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  
  \VariableTok{Shiny}\NormalTok{.}\VariableTok{inputBindings}\NormalTok{.}\AttributeTok{register}\NormalTok{(navbarMenuBinding}\OperatorTok{,} \StringTok{'text'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We test the new \texttt{navbar\_menu} binding below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \KeywordTok{HTML}\NormalTok{(}
        \StringTok{"$(function() \{}
\StringTok{          // Input binding}
\StringTok{          let navbarMenuBinding = new Shiny.InputBinding()}
\StringTok{          $.extend(navbarMenuBinding, \{}
\StringTok{            find: function(scope) \{}
\StringTok{              return $(scope).find('.navbar-nav');}
\StringTok{            \},}
\StringTok{            initialize: function(el) \{}
\StringTok{              let menuId = '#' + $(el).attr('id');}
\StringTok{              let activeTab = $(`$\{menuId\} .nav-link.active`);}
\StringTok{              // if multiple items are found}
\StringTok{              if (activeTab.length > 0) \{}
\StringTok{                let tabId = $(activeTab).attr('data-value');}
\StringTok{                $(activeTab).tab('show');}
\StringTok{                $(`#$\{tabId\}`).addClass('show active');}
\StringTok{              \} else \{}
\StringTok{                $(`$\{menuId\} .nav-link`)}
\StringTok{                  .first()}
\StringTok{                  .tab('show');}
\StringTok{              \}}
\StringTok{            \},}
\StringTok{            // Given the DOM element for the input, return the value}
\StringTok{            getValue: function(el) \{}
\StringTok{              let currentTab = $(el).find('a').filter('.nav-link.active');}
\StringTok{              return $(currentTab).attr('data-value');}
\StringTok{            \},}
\StringTok{            setValue: function(el, value) \{}
\StringTok{              let hrefVal = '#' + value;}
\StringTok{              let menuId = $(el).attr('id');}
\StringTok{              $(`#$\{menuId\} a[href=}\CharTok{\textbackslash{}"}\StringTok{$\{hrefVal\}}\CharTok{\textbackslash{}"}\StringTok{]`).tab('show');}
\StringTok{            \},}
\StringTok{            receiveMessage: function(el, data) \{}
\StringTok{              this.setValue(el, data);}
\StringTok{            \},}
\StringTok{            subscribe: function(el, callback) \{}
\StringTok{              $(el).on('shown.bs.tab.navbarMenuBinding', function(event) \{}
\StringTok{                callback();}
\StringTok{              \});}
\StringTok{            \},}
\StringTok{            unsubscribe: function(el) \{}
\StringTok{              $(el).off('.navbarMenuBinding');}
\StringTok{            \}}
\StringTok{          \});}
\StringTok{          }
\StringTok{          Shiny.inputBindings.register(navbarMenuBinding, 'text');}
\StringTok{        \});}
\StringTok{        "}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \KeywordTok{tabler_navbar_menu}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"current_tab"}\NormalTok{,}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 1"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{      ),}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 2"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab2"}
\NormalTok{      )}
\NormalTok{    ),}
    \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Change tab"}\NormalTok{, }\DataTypeTok{icon =} \KeywordTok{icon}\NormalTok{(}\StringTok{"exchange-alt"}\NormalTok{))}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_tab_items}\NormalTok{(}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \KeywordTok{sliderInput}\NormalTok{(}
          \StringTok{"obs"}\NormalTok{, }
          \StringTok{"Number of observations:"}\NormalTok{,}
          \DataTypeTok{min =} \DecValTok{0}\NormalTok{,}
          \DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }
          \DataTypeTok{value =} \DecValTok{500}
\NormalTok{        ),}
        \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{      ),}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Second Tab"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{current_tab, \{}
    \KeywordTok{showNotification}\NormalTok{(}
      \KeywordTok{paste}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, input}\OperatorTok{$}\NormalTok{current_tab), }
      \DataTypeTok{type =} \StringTok{"message"}\NormalTok{,}
      \DataTypeTok{duration =} \DecValTok{1}
\NormalTok{    )}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
\NormalTok{    newTab <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (input}\OperatorTok{$}\NormalTok{current_tab }\OperatorTok{==}\StringTok{ "tab1"}\NormalTok{) }\StringTok{"tab2"} \ControlFlowTok{else} \StringTok{"tab1"}
    \KeywordTok{update_tabler_tab_item}\NormalTok{(}\StringTok{"current_tab"}\NormalTok{, newTab)}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Here we are!

\hypertarget{custom-templates-interactivity}{%
\chapter{Adding more interactivity}\label{custom-templates-interactivity}}

In this part, we are going to add more life to the template element. We first see how
to enhance an existing static HTML component. Then we will explore complex feedback mechanisms to provide more interactivity to your app.

\hypertarget{custom-progress-bars}{%
\section{Custom progress bars}\label{custom-progress-bars}}

Progress bars are a good way to display metric related to a progress, for instance tracking the number of remaining tasks for a project. In general, those
elements are static HTML. Hence, it would be interesting to be able to update the current
value from the server side. Since it is not an proper input element, implementing an input binding is inapropriate and we decide to proceed with the \texttt{sendCustomMessage}/\texttt{addCustomMessageHandler} pair. We first create the \texttt{tabler\_progress}
tag which is mainly composed of:

\begin{itemize}
\tightlist
\item
  \texttt{style} gives the current progress value. This is the main element
\item
  \texttt{min} and \texttt{max} are bounds, in general between 0 and 100
\item
  \texttt{id} ensures the progress bar uniqueness, thereby avoiding conflicts
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_progress <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, value) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"progress"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{id =}\NormalTok{ id, }
      \DataTypeTok{class =} \StringTok{"progress-bar"}\NormalTok{,}
      \DataTypeTok{style =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, value, }\StringTok{"%"}\NormalTok{),}
      \DataTypeTok{role =} \StringTok{"progressbar"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{aria-valuenow}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{as.character}\NormalTok{(value),}
      \StringTok{`}\DataTypeTok{aria-valuemin}\StringTok{`}\NormalTok{ =}\StringTok{ "0"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{aria-valuemax}\StringTok{`}\NormalTok{ =}\StringTok{ "100"}\NormalTok{,}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"sr-only"}\NormalTok{, }\StringTok{"38% Complete"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{update_tabler_progress <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, value, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(id), }\DataTypeTok{value =}\NormalTok{ value)}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"update-progress"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The next element is the \texttt{update\_tabler\_progress} function which send 2 elements from R to JS:

\begin{itemize}
\tightlist
\item
  The progress \texttt{id}
\item
  The new value
\end{itemize}

On the JS side, we have a basic \texttt{addCustomMessageHandler}. As mentionned in Chapter \ref{survival-kit-javascript}, \texttt{sendCustomMessage} and \texttt{addCustomMessageHandler} are connected by the \texttt{type} parameter. This is crucial! Moreover, as the sent message is a R list, it becomes an JSON, meaning that elements must be accessed with a \texttt{.} in JS:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update-progress'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{).}\AttributeTok{css}\NormalTok{(}\StringTok{'width'}\OperatorTok{,} \VariableTok{message}\NormalTok{.}\AttributeTok{value} \OperatorTok{+}\StringTok{'%'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We finally test these components in a simple app:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \StringTok{"$(function() \{}
\StringTok{        Shiny.addCustomMessageHandler('update-progress', function(message) \{}
\StringTok{          $('#' + message.id).css('width', message.value +'%');}
\StringTok{        \});}
\StringTok{      \});}
\StringTok{      "}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{sliderInput}\NormalTok{(}
      \StringTok{"progress_value"}\NormalTok{, }
      \StringTok{"Progress value:"}\NormalTok{,}
      \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }
      \DataTypeTok{max =} \DecValTok{100}\NormalTok{, }
      \DataTypeTok{value =} \DecValTok{50}
\NormalTok{    ),}
    \KeywordTok{tabler_progress}\NormalTok{(}\DataTypeTok{id =} \StringTok{"progress1"}\NormalTok{, }\DecValTok{12}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{progress_value, \{}
    \KeywordTok{update_tabler_progress}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"progress1"}\NormalTok{, }
\NormalTok{      input}\OperatorTok{$}\NormalTok{progress_value}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

NOTE: How to handle custom messages in shiny modules? Well, it is pretty straightforward: we wrap any id with the module namespace given by \texttt{session\$ns()} before sending it to JS. You may even do it by default (without modules) like in the previous example since \texttt{session\$ns()} will be \texttt{""}.

\hypertarget{user-feedback-toasts}{%
\section{User feedback: toasts}\label{user-feedback-toasts}}

Toasts are components to send discrete user feedback, contrary to modals which open in the middle of the page. Toasts may open on all sides of the window and are similar to the Shiny notifications (see \href{https://shiny.rstudio.com/reference/shiny/0.14/showNotification.html}{here}). The tabler toast component is built on top of \href{https://getbootstrap.com/docs/4.3/components/toasts/}{Bootstrap 4}. Therefore, we will rely on this documentation.

\hypertarget{toast-skeleton}{%
\subsection{Toast skeleton}\label{toast-skeleton}}

The skeleton is the HTML structure of the toast:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"toast show"}\OtherTok{ role=}\StringTok{"alert"}\OtherTok{ aria-live=}\StringTok{"assertive"}\OtherTok{ aria-atomic=}\StringTok{"true"}\OtherTok{ data-autohide=}\StringTok{"false"}\OtherTok{ data-toggle=}\StringTok{"toast"}\KeywordTok{>}
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"toast-header"}\KeywordTok{>}
\KeywordTok{<span}\OtherTok{ class=}\StringTok{"avatar mr-2"}\OtherTok{ style=}\StringTok{"background-image: url(...)"}\KeywordTok{></span>}
\KeywordTok{<strong}\OtherTok{ class=}\StringTok{"mr-auto"}\KeywordTok{>}\NormalTok{Mallory Hulme}\KeywordTok{</strong>}
\KeywordTok{<small>}\NormalTok{11 mins ago}\KeywordTok{</small>}
\KeywordTok{<button}\OtherTok{ type=}\StringTok{"button"}\OtherTok{ class=}\StringTok{"ml-2 close"}\OtherTok{ data-dismiss=}\StringTok{"toast"}\OtherTok{ aria-label=}\StringTok{"Close"}\KeywordTok{>}
\KeywordTok{<span}\OtherTok{ aria-hidden=}\StringTok{"true"}\KeywordTok{>}\DecValTok{&times;}\KeywordTok{</span>}
\KeywordTok{</button>}
\KeywordTok{</div>}
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"toast-body"}\KeywordTok{>}
\NormalTok{Hello, world! This is a toast message.}
\KeywordTok{</div>}
\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

Toasts are mainly composed of a header and a body. There might be a close button in case the toast does not hide itself. If multiple toasts appear one after each others, they are stacked, the latest being at the bottom of the stack. The position is controled with the style attribute like \texttt{style="position:\ absolute;\ top:\ 0;\ right:\ 0;"} for a top-right placement. Accessibility parameters like \texttt{aria-live} are detailed \href{https://getbootstrap.com/docs/4.3/components/toasts/\#accessibility}{here}.

\hypertarget{the-toast-api}{%
\subsection{The toast API}\label{the-toast-api}}

Toasts have a JS API to control their behaviour, \texttt{\$(\textquotesingle{}\textless{}toast\_selector\textgreater{}\textquotesingle{}).toast(option)}, where option stend for:

\begin{itemize}
\tightlist
\item
  animation applies a CSS fade transition to the toast and is TRUE by default
\item
  autohide automatically hides the toast (TRUE by default)
\item
  delay is the delay to hide the toast (500 ms)
\end{itemize}

There are 3 methods: hide, show and dispose (dispose ensures the toast does not appear anymore). Finally, we may fine tune the toast behavior with 4 events: show.bs.toast, shown.bs.toast, hide.bs.toast, hide.bs.toast, hidden.bs.toast (like for tabs).

\hypertarget{r-implementation}{%
\subsection{R implementation}\label{r-implementation}}

We first create the toast skeleton. We assume our toast will hide automatically, so that we may remove the delete button as well as the \texttt{data-autohide="false} attribute. All parameters are optional except the toast id, which is required to toggle the toast:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_toast <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{subtitle =} \OtherTok{NULL}\NormalTok{, ..., }\DataTypeTok{img =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{id =}\NormalTok{ id,}
    \DataTypeTok{class =} \StringTok{"toast"}\NormalTok{,}
    \DataTypeTok{role =} \StringTok{"alert"}\NormalTok{,}
    \DataTypeTok{style =} \StringTok{"position: absolute; top: 0; right: 0;"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{aria-live}\StringTok{`}\NormalTok{ =}\StringTok{ "assertive"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{aria-atomic}\StringTok{`}\NormalTok{ =}\StringTok{ "true"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "toast"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"toast-header"}\NormalTok{,}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(img)) \{}
        \KeywordTok{span}\NormalTok{(}
          \DataTypeTok{class =} \StringTok{"avatar mr-2"}\NormalTok{, }
          \DataTypeTok{style =} \KeywordTok{sprintf}\NormalTok{(}\StringTok{"background-image: url(%s)"}\NormalTok{, img)}
\NormalTok{        )}
\NormalTok{      \},}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) }\KeywordTok{strong}\NormalTok{(}\DataTypeTok{class =} \StringTok{"mr-auto"}\NormalTok{, title),}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(subtitle)) tags}\OperatorTok{$}\KeywordTok{small}\NormalTok{(subtitle)}
\NormalTok{    ),}
    \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"toast-body"}\NormalTok{, ...)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We create the \texttt{show\_tabler\_toast} function. Since the toast automatically hides, it does not make sense to create the hide function, as well as the dispose.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_tabler_toast <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  message <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{:::}\KeywordTok{dropNulls}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{id =}\NormalTok{ id,}
      \DataTypeTok{options =}\NormalTok{ options}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"tabler-toast"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The corresponding JS handler is given by:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'tabler-toast'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
\AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}
\NormalTok{.}\AttributeTok{toast}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{options}\NormalTok{)}
\NormalTok{.}\AttributeTok{toast}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}

\CommentTok{// add custom Shiny input to listen to the toast state}
\AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'hidden.bs.toast'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \KeywordTok{true}\OperatorTok{,} \OperatorTok{\{}\DataTypeTok{priority}\OperatorTok{:} \StringTok{'event'}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We first configure the toast and ask him to show. Notice how we chained jQuery methods! We optionally add an event listener to capture the \texttt{hidden.bs.toast} event, so that we may trigger an action when the toast is closed. The \texttt{input\$id} will be used for that purpose in combination with the \texttt{Shiny.setInputValue}. Notice the extra parameter \texttt{\{priority:\ \textquotesingle{}event\textquotesingle{}\}}: basically, once the toast is closed, \texttt{input\$id} will always be TRUE, thereby breaking the reactivity. Adding this extra parameter forces the evaluation of the input, although constant over time.

\hypertarget{wrap-up}{%
\subsection{Wrap up}\label{wrap-up}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \StringTok{"$(function() \{}
\StringTok{        Shiny.addCustomMessageHandler('tabler-toast', function(message) \{}
\StringTok{          $(`#$\{message.id\}`)}
\StringTok{            .toast(message.options)}
\StringTok{            .toast('show');}
\StringTok{          }
\StringTok{          // add custom Shiny input to listen to the toast state}
\StringTok{          $(`#$\{message.id\}`).on('hidden.bs.toast', function() \{}
\StringTok{            Shiny.setInputValue(message.id, true, \{priority: 'event'\});}
\StringTok{          \})}
\StringTok{        \});}
\StringTok{      \});}
\StringTok{      "}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_toast}\NormalTok{(}
    \DataTypeTok{id =} \StringTok{"toast"}\NormalTok{, }
    \DataTypeTok{title =} \StringTok{"Hello"}\NormalTok{, }
    \DataTypeTok{subtitle =} \StringTok{"now"}\NormalTok{, }
    \StringTok{"Toast body"}\NormalTok{,}
    \DataTypeTok{img =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}
\NormalTok{  ),}
  \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"launch"}\NormalTok{, }\StringTok{"Go!"}\NormalTok{, }\DataTypeTok{width =} \StringTok{"25%"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(}\KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{toast))}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{launch, \{}
    \KeywordTok{show_tabler_toast}\NormalTok{(}
      \StringTok{"toast"}\NormalTok{, }
      \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{animation =} \OtherTok{FALSE}\NormalTok{,}
        \DataTypeTok{delay =} \DecValTok{2000}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{toast, \{}
    \KeywordTok{showNotification}\NormalTok{(}
      \StringTok{"Toast was closed"}\NormalTok{, }
      \DataTypeTok{type =} \StringTok{"warning"}\NormalTok{,}
      \DataTypeTok{duration =} \DecValTok{1}\NormalTok{,}
      
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{transform-an-element-in-a-custom-action-button}{%
\section{Transform an element in a custom action button}\label{transform-an-element-in-a-custom-action-button}}

As seen in Chapter \ref{custom-templates-inputs}, any \texttt{\textless{}button\textgreater{}}, \texttt{\textless{}a\textgreater{}} element holding the \texttt{action-button} class may eventually become an action button. The tabler template has dropdown menus in the navbar and we would like to transform dropdown items in action buttons. The \texttt{tabler\_dropdown} functions takes the following parameters:

\begin{itemize}
\tightlist
\item
  id is required by the \texttt{show\_tabler\_dropdown} (see below) function which opens the menu
\item
  title is the dropdown menu name
\item
  subtitle is optional text
\item
  img is an optional image
\item
  \ldots{} hosts the \texttt{tabler\_dropdown\_item} (see below)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_dropdown <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, title, }\DataTypeTok{subtitle =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{img =} \OtherTok{NULL}\NormalTok{) \{}
  
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"nav-item dropdown"}\NormalTok{,}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
      \DataTypeTok{id =}\NormalTok{ id, }
      \DataTypeTok{class =} \StringTok{"nav-link d-flex lh-1 text-reset p-0"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "dropdown"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{aria-expanded}\StringTok{`}\NormalTok{ =}\StringTok{ "false"}\NormalTok{,}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(img)) \{}
        \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"avatar"}\NormalTok{, }\DataTypeTok{style =} \KeywordTok{sprintf}\NormalTok{(}\StringTok{"background-image: url(%s)"}\NormalTok{, img))}
\NormalTok{      \},}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"d-none d-xl-block pl-2"}\NormalTok{,}
        \KeywordTok{div}\NormalTok{(title),}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(subtitle)) \{}
          \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"mt-1 small text-muted"}\NormalTok{, subtitle)}
\NormalTok{        \}}
\NormalTok{      )}
\NormalTok{    ),}
    \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"dropdown-menu dropdown-menu-right"}\NormalTok{, }\StringTok{`}\DataTypeTok{aria-labelledby}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{id, ...)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To convert a dropdown item in an action button , we add the \texttt{action-button} class as well
as the \texttt{id} parameter to recover the corresponding input id.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_dropdown_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{a}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ id, }\DataTypeTok{class =} \StringTok{"dropdown-item action-button"}\NormalTok{, }\DataTypeTok{href =} \StringTok{"#"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We finally create the \texttt{show\_tabler\_dropdown} as well as the corresponding Shiny message handler.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_tabler_dropdown <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"show-dropdown"}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ id)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To show the dropdown, we use the \texttt{dropdown} method which is linked to the \texttt{data-toggle="dropdown"} of \texttt{tabler\_dropdown}.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'show-dropdown'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
\AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{message}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{dropdown}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Let's play with it!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \StringTok{"$(function() \{}
\StringTok{        Shiny.addCustomMessageHandler('show-dropdown', function(message) \{}
\StringTok{          $(`#$\{message\}`).dropdown('show');}
\StringTok{        \});}
\StringTok{      \});}
\StringTok{      "}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \OtherTok{NULL}\NormalTok{, }
    \KeywordTok{tabler_dropdown}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"mydropdown"}\NormalTok{,}
      \DataTypeTok{title =} \StringTok{"Dropdown"}\NormalTok{,}
      \DataTypeTok{subtitle =} \StringTok{"click me"}\NormalTok{,}
      \KeywordTok{tabler_dropdown_item}\NormalTok{(}
        \DataTypeTok{id =} \StringTok{"item1"}\NormalTok{,}
        \StringTok{"Show Notification"}
\NormalTok{      ),}
      \KeywordTok{tabler_dropdown_item}\NormalTok{(}
        \StringTok{"Do nothing"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"show"}\NormalTok{, }\StringTok{"Open dropdown"}\NormalTok{, }\DataTypeTok{width =} \StringTok{"25%"}\NormalTok{),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{show, \{}
    \KeywordTok{show_tabler_dropdown}\NormalTok{(}\StringTok{"mydropdown"}\NormalTok{)}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{item1, \{}
    \KeywordTok{showNotification}\NormalTok{(}
      \StringTok{"Success"}\NormalTok{, }
      \DataTypeTok{type =} \StringTok{"message"}\NormalTok{,}
      \DataTypeTok{duration =} \DecValTok{2}\NormalTok{,}
      
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{tab-events}{%
\section{Tab events}\label{tab-events}}

Do you remember about the navbar element and the tabsetpanel system of Chapter \ref{custom-templates-skeleton}? Navs allow to organize any app into several tabs, acting like pages. This is a powerful tool for Shiny since it is currently not straightforward to create \href{https://community.rstudio.com/t/shiny-app-composed-of-many-many-pages/7698}{multi-pages} Shiny apps like anyone would do with a website. Navs relie on the Bootstrap4 API but we only used few JS functions.

\hypertarget{insert-tabs}{%
\subsection{Insert/Remove tabs in tabsetpanel}\label{insert-tabs}}

How about dynamically inserting/removing tabs from a \texttt{tabler\_navbar}? I chose this example since it involves extra technical details about Shiny.

How do we proceed? if you remember about the \texttt{tabler\_navbar\_menu\_item} and \texttt{tabler\_tab\_item} coupling, inserting a tab implies to insert the trigger in the navigation menu as well as the content in the dashboard body. Therefore, we need to know the structure of what we insert. Below is a reminder:

\begin{itemize}
\tightlist
\item
  \texttt{tabler\_navbar\_menu\_item} are \texttt{\textless{}li\textgreater{}} elements
\item
  \texttt{tabler\_navbar\_menu\_item} is a \texttt{\textless{}div\textgreater{}} element with specific classes
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<li}\OtherTok{ class=}\StringTok{"nav-item"}\KeywordTok{>}
\KeywordTok{<a}\OtherTok{ class=}\StringTok{"nav-link"}\OtherTok{ href=}\StringTok{"#ww"}\OtherTok{ data-toggle=}\StringTok{"pill"}\OtherTok{ data-value=}\StringTok{"ww"}\OtherTok{ role=}\StringTok{"tab"}\KeywordTok{>}
\KeywordTok{<span}\OtherTok{ class=}\StringTok{"nav-link-icon d-md-none d-lg-inline-block"}\KeywordTok{></span>}
\KeywordTok{<span}\OtherTok{ class=}\StringTok{"nav-link-title"}\KeywordTok{>}\NormalTok{ww}\KeywordTok{</span>}
\KeywordTok{</a>}
\KeywordTok{</li>}

\KeywordTok{<div}\OtherTok{ role=}\StringTok{"tabpanel"}\OtherTok{ class=}\StringTok{"tab-pane fade container-fluid"}\OtherTok{ id=}\StringTok{"ww"}\KeywordTok{></div>}
\end{Highlighting}
\end{Shaded}

We design the \texttt{insert\_tabler\_tab} function similar to the Shiny \texttt{insertTab}.
To handle shiny modules, we wrap the inputId in the session namespace. We create the menu item element based on the provided new tab.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{insert_tabler_tab <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, tab, target, }\DataTypeTok{position =} \KeywordTok{c}\NormalTok{(}\StringTok{"before"}\NormalTok{, }\StringTok{"after"}\NormalTok{),}
                              \DataTypeTok{select =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
  
\NormalTok{  inputId <-}\StringTok{ }\NormalTok{session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(inputId)}
\NormalTok{  position <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(position)}
\NormalTok{  navbar_menu_item <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"nav-item"}\NormalTok{,}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"nav-link"}\NormalTok{,}
      \DataTypeTok{href =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id)),}
      \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "pill"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{data-value}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id,}
      \DataTypeTok{role =} \StringTok{"tab"}\NormalTok{,}
\NormalTok{      tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{  tab <-}\StringTok{ }\KeywordTok{force}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(tab))}
\NormalTok{  navbar_menu_item <-}\StringTok{ }\KeywordTok{force}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(navbar_menu_item))}
  
\NormalTok{  message <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{:::}\KeywordTok{dropNulls}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{inputId =}\NormalTok{ inputId,}
      \DataTypeTok{content =}\NormalTok{ tab,}
      \DataTypeTok{link =}\NormalTok{ navbar_menu_item,}
      \DataTypeTok{target =}\NormalTok{ target,}
      \DataTypeTok{position =}\NormalTok{ position,}
      \DataTypeTok{select =}\NormalTok{ select}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"insert-tab"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'insert-tab'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
\CommentTok{// define div and li targets}
\KeywordTok{let}\NormalTok{ $divTag }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{content}\NormalTok{)}\OperatorTok{;}
\KeywordTok{let}\NormalTok{ $liTag }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{link}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{position} \OperatorTok{===} \StringTok{'after'}\NormalTok{) }\OperatorTok{\{}
\VariableTok{$divTag}\NormalTok{.}\AttributeTok{insertAfter}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target}\NormalTok{))}\OperatorTok{;}
\VariableTok{$liTag}\NormalTok{.}\AttributeTok{insertAfter}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'[href ="#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target} \OperatorTok{+} \StringTok{'"]'}\NormalTok{).}\AttributeTok{parent}\NormalTok{())}\OperatorTok{;}
\OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{position} \OperatorTok{===} \StringTok{'before'}\NormalTok{) }\OperatorTok{\{}
\VariableTok{$divTag}\NormalTok{.}\AttributeTok{insertBefore}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target}\NormalTok{))}\OperatorTok{;}
\VariableTok{$liTag}\NormalTok{.}\AttributeTok{insertBefore}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'[href ="#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target} \OperatorTok{+} \StringTok{'"]'}\NormalTok{).}\AttributeTok{parent}\NormalTok{())}\OperatorTok{;}
\OperatorTok{\}}

\ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{select}\NormalTok{) }\OperatorTok{\{}
\CommentTok{// trigger a click on corresponding the new tab button. }
\KeywordTok{let}\NormalTok{ newTabId }\OperatorTok{=} \VariableTok{$divTag}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{inputId} \OperatorTok{+} \StringTok{' a[href="#'} \OperatorTok{+}\NormalTok{ newTabId }\OperatorTok{+}\StringTok{'"]'}\NormalTok{).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \KeywordTok{HTML}\NormalTok{(}
        \StringTok{"$(function() \{}
\StringTok{          Shiny.addCustomMessageHandler('insert-tab', function(message) \{}
\StringTok{            // define div and li targets}
\StringTok{            let $divTag = $(message.content);}
\StringTok{            let $liTag = $(message.link);}
\StringTok{            }
\StringTok{            if (message.position === 'after') \{}
\StringTok{              $divTag.insertAfter($('#' + message.target));}
\StringTok{              $liTag.insertAfter($('[href =}\CharTok{\textbackslash{}"}\StringTok{#' + message.target + '}\CharTok{\textbackslash{}"}\StringTok{]').parent());}
\StringTok{            \} else if (message.position === 'before') \{}
\StringTok{              $divTag.insertBefore($('#' + message.target));}
\StringTok{              $liTag.insertBefore($('[href =}\CharTok{\textbackslash{}"}\StringTok{#' + message.target + '}\CharTok{\textbackslash{}"}\StringTok{]').parent());}
\StringTok{            \}}
\StringTok{            }
\StringTok{            if (message.select) \{}
\StringTok{              // trigger a click on corresponding the new tab button. }
\StringTok{              let newTabId = $divTag.attr('id');}
\StringTok{              $('#' + message.inputId + ' a[href=}\CharTok{\textbackslash{}"}\StringTok{#' + newTabId +'}\CharTok{\textbackslash{}"}\StringTok{]').tab('show');}
\StringTok{            \}}
\StringTok{          \});}
\StringTok{        \});}
\StringTok{        "}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \KeywordTok{tabler_navbar_menu}\NormalTok{(}
      \DataTypeTok{inputId =} \StringTok{"tabmenu"}\NormalTok{,}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 1"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{      ),}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 2"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab2"}
\NormalTok{      )}
\NormalTok{    ),}
    \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"insert"}\NormalTok{, }\StringTok{"Insert Tab"}\NormalTok{)}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_tab_items}\NormalTok{(}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{      ),}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Second Tab"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{insert, \{}
    \KeywordTok{insert_tabler_tab}\NormalTok{(}
      \DataTypeTok{inputId =} \StringTok{"tabmenu"}\NormalTok{,}
      \DataTypeTok{tab =} \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab3"}\NormalTok{,}
        \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
                    \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{        ),}
        \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{      ),}
      \DataTypeTok{target =} \StringTok{"tab2"}\NormalTok{,}
      \DataTypeTok{position =} \StringTok{"before"}\NormalTok{,}
      \DataTypeTok{select =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

If the tab is well inserted, we notice that the slider and the plot are not properly shown. How could we explain that? It is a dependency issue: the slider input relies on a specific JS \href{http://ionden.com/a/plugins/ion.rangeSlider/}{library} as depicted in Figure \ref{fig:slider-deps}. In our previous example, If you open the HTML inspector, the dependency is not included in the page.

\begin{figure}
\includegraphics[width=36.03in]{images/practice/slider-deps} \caption{Slider dependencies.}\label{fig:slider-deps}
\end{figure}

Even stranger, when we use \texttt{renderUI} to conditionally render the slider (note: this is a dummy example), the dependency is only included when the go button is pressed. How does Shiny includes them?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"go"}\NormalTok{, }\StringTok{"Go!"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"btn-success"}\NormalTok{),}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"slider"}\NormalTok{),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{)}

\CommentTok{# Server logic}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{slider <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
    \KeywordTok{req}\NormalTok{(input}\OperatorTok{$}\NormalTok{go }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{)}
    \KeywordTok{sliderInput}\NormalTok{(}
      \StringTok{"obs"}\NormalTok{, }
      \StringTok{"Number of observations:"}\NormalTok{,}
      \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }
      \DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }
      \DataTypeTok{value =} \DecValTok{500}
\NormalTok{    )}
\NormalTok{  \})}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{req}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs)}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}

\CommentTok{# Complete app with UI and server components}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Let's look at \texttt{renderUI}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{renderUI <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (expr, }\DataTypeTok{env =} \KeywordTok{parent.frame}\NormalTok{(), }\DataTypeTok{quoted =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{outputArgs =} \KeywordTok{list}\NormalTok{()) \{}
    \KeywordTok{installExprFunction}\NormalTok{(expr, }\StringTok{"func"}\NormalTok{, env, quoted)}
    \KeywordTok{createRenderFunction}\NormalTok{(func, }\ControlFlowTok{function}\NormalTok{(result, shinysession, }
\NormalTok{        name, ...) \{}
        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(result) }\OperatorTok{||}\StringTok{ }\KeywordTok{length}\NormalTok{(result) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }
            \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
        \CommentTok{#shiny:::processDeps(result, shinysession)}
\NormalTok{      result}
\NormalTok{    \}, uiOutput, outputArgs)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The last line returned is \texttt{processDeps(result,\ shinysession)}. This function is responsible to handle dependencies during runtime. \texttt{processDeps} (R side) works with \texttt{Shiny.renderContent} (JS side).
The latter takes a tag element as well as an object containing its HTML code and dependencies, for instance:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{exports}\NormalTok{.}\AttributeTok{renderContent}\NormalTok{($tag[}\DecValTok{0}\NormalTok{]}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{html}\OperatorTok{:} \VariableTok{$tag}\NormalTok{.}\AttributeTok{html}\NormalTok{()}\OperatorTok{,}
  \DataTypeTok{deps}\OperatorTok{:} \VariableTok{message}\NormalTok{.}\VariableTok{tag}\NormalTok{.}\AttributeTok{deps}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;} 
\end{Highlighting}
\end{Shaded}

In the following, we modify the \texttt{insert\_tabler\_tab} to include the dependencies processing step.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{insert_tabler_tab <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, tab, target, }\DataTypeTok{position =} \KeywordTok{c}\NormalTok{(}\StringTok{"before"}\NormalTok{, }\StringTok{"after"}\NormalTok{),}
                              \DataTypeTok{select =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
  
\NormalTok{  inputId <-}\StringTok{ }\NormalTok{session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(inputId)}
\NormalTok{  position <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(position)}
\NormalTok{  navbar_menu_item <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"nav-item"}\NormalTok{,}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"nav-link"}\NormalTok{,}
      \DataTypeTok{href =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id)),}
      \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "pill"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{data-value}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id,}
      \DataTypeTok{role =} \StringTok{"tab"}\NormalTok{,}
\NormalTok{      tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{  message <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{:::}\KeywordTok{dropNulls}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{inputId =}\NormalTok{ inputId,}
      \DataTypeTok{content =}\NormalTok{ shiny}\OperatorTok{:::}\KeywordTok{processDeps}\NormalTok{(tab, session),}
      \DataTypeTok{link =}\NormalTok{ shiny}\OperatorTok{:::}\KeywordTok{processDeps}\NormalTok{(navbar_menu_item, session),}
      \DataTypeTok{target =}\NormalTok{ target,}
      \DataTypeTok{position =}\NormalTok{ position,}
      \DataTypeTok{select =}\NormalTok{ select}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"insert-tab"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We then apply the \texttt{Shiny.renderContent} method to the tab content and navigation item.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'insert-tab'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \CommentTok{// define div and li targets}
    \KeywordTok{let}\NormalTok{ $divTag }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VariableTok{message}\NormalTok{.}\VariableTok{content}\NormalTok{.}\AttributeTok{html}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{let}\NormalTok{ $liTag }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VariableTok{message}\NormalTok{.}\VariableTok{link}\NormalTok{.}\AttributeTok{html}\NormalTok{)}\OperatorTok{;}
    
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{position} \OperatorTok{===} \StringTok{'after'}\NormalTok{) }\OperatorTok{\{}
      \VariableTok{$divTag}\NormalTok{.}\AttributeTok{insertAfter}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target}\NormalTok{))}\OperatorTok{;}
      \VariableTok{$liTag}\NormalTok{.}\AttributeTok{insertAfter}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'[href ="#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target} \OperatorTok{+}   \StringTok{'"]'}\NormalTok{).}\AttributeTok{parent}\NormalTok{())}\OperatorTok{;}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{position} \OperatorTok{===} \StringTok{'before'}\NormalTok{) }\OperatorTok{\{}
      \VariableTok{$divTag}\NormalTok{.}\AttributeTok{insertBefore}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target}\NormalTok{))}\OperatorTok{;}
      \VariableTok{$liTag}\NormalTok{.}\AttributeTok{insertBefore}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'[href ="#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target} \OperatorTok{+}   \StringTok{'"]'}\NormalTok{).}\AttributeTok{parent}\NormalTok{())}\OperatorTok{;}
    \OperatorTok{\}}
  
      \CommentTok{// needed to render input/output in newly added tab. It takes the possible}
      \CommentTok{// deps and add them to the tag. Indeed, if we insert a tab, its deps are not}
      \CommentTok{// included in the page so it can't render properly}
      \VariableTok{Shiny}\NormalTok{.}\AttributeTok{renderContent}\NormalTok{($liTag[}\DecValTok{0}\NormalTok{]}\OperatorTok{,} \OperatorTok{\{}\DataTypeTok{html}\OperatorTok{:} \VariableTok{$liTag}\NormalTok{.}\AttributeTok{html}\NormalTok{()}\OperatorTok{,} \DataTypeTok{deps}\OperatorTok{:} \VariableTok{message}\NormalTok{.}\VariableTok{link}\NormalTok{.}\AttributeTok{deps}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
      \VariableTok{Shiny}\NormalTok{.}\AttributeTok{renderContent}\NormalTok{($divTag[}\DecValTok{0}\NormalTok{]}\OperatorTok{,} \OperatorTok{\{}\DataTypeTok{html}\OperatorTok{:} \VariableTok{$divTag}\NormalTok{.}\AttributeTok{html}\NormalTok{()}\OperatorTok{,} \DataTypeTok{deps}\OperatorTok{:} \VariableTok{message}\NormalTok{.}\VariableTok{content}\NormalTok{.}\AttributeTok{deps}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{select}\NormalTok{) }\OperatorTok{\{}
    \CommentTok{// trigger a click on corresponding the new tab button. }
    \KeywordTok{let}\NormalTok{ newTabId }\OperatorTok{=} \VariableTok{$divTag}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
      \AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{inputId} \OperatorTok{+} \StringTok{' a[href="#'} \OperatorTok{+}\NormalTok{ newTabId   }\OperatorTok{+}\StringTok{'"]'}\NormalTok{).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We check if our approach works as expected.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \KeywordTok{HTML}\NormalTok{(}
        \StringTok{"$(function() \{}
\StringTok{          Shiny.addCustomMessageHandler('insert-tab', function(message) \{}
\StringTok{            console.log(message.content.deps);}
\StringTok{            // define div and li targets}
\StringTok{            let $divTag = $(message.content.html);}
\StringTok{            let $liTag = $(message.link.html);}
\StringTok{            }
\StringTok{            if (message.position === 'after') \{}
\StringTok{              $divTag.insertAfter($('#' + message.target));}
\StringTok{              $liTag.insertAfter($('[href =}\CharTok{\textbackslash{}"}\StringTok{#' + message.target + '}\CharTok{\textbackslash{}"}\StringTok{]').parent());}
\StringTok{            \} else if (message.position === 'before') \{}
\StringTok{              $divTag.insertBefore($('#' + message.target));}
\StringTok{              $liTag.insertBefore($('[href =}\CharTok{\textbackslash{}"}\StringTok{#' + message.target + '}\CharTok{\textbackslash{}"}\StringTok{]').parent());}
\StringTok{            \}}
\StringTok{            }
\StringTok{            // needed to render input/output in newly added tab. It takes the possible}
\StringTok{            // deps and add them to the tag. Indeed, if we insert a tab, its deps are not}
\StringTok{            // included in the page so it can't render properly}
\StringTok{            Shiny.renderContent($liTag[0], \{html: $liTag.html(), deps: message.link.deps\});}
\StringTok{            Shiny.renderContent($divTag[0], \{html: $divTag.html(), deps: message.content.deps\});}
\StringTok{            }
\StringTok{            if (message.select) \{}
\StringTok{              // trigger a click on corresponding the new tab button. }
\StringTok{              let newTabId = $divTag.attr('id');}
\StringTok{              $('#' + message.inputId + ' a[href=}\CharTok{\textbackslash{}"}\StringTok{#' + newTabId +'}\CharTok{\textbackslash{}"}\StringTok{]').tab('show');}
\StringTok{            \}}
\StringTok{          \});}
\StringTok{        \});}
\StringTok{        "}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \KeywordTok{tabler_navbar_menu}\NormalTok{(}
      \DataTypeTok{inputId =} \StringTok{"tabmenu"}\NormalTok{,}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 1"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{      ),}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 2"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab2"}
\NormalTok{      )}
\NormalTok{    ),}
    \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"insert"}\NormalTok{, }\StringTok{"Insert Tab"}\NormalTok{)}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_tab_items}\NormalTok{(}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{      ),}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Second Tab"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{insert, \{}
    \KeywordTok{insert_tabler_tab}\NormalTok{(}
      \DataTypeTok{inputId =} \StringTok{"tabmenu"}\NormalTok{,}
      \DataTypeTok{tab =} \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab3"}\NormalTok{,}
        \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
                    \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{        ),}
        \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{      ),}
      \DataTypeTok{target =} \StringTok{"tab2"}\NormalTok{,}
      \DataTypeTok{position =} \StringTok{"before"}\NormalTok{,}
      \DataTypeTok{select =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=36.03in]{images/practice/process-deps} \caption{processDeps and Shiny.renderContent in action.}\label{fig:process-deps}
\end{figure}

Et voila! As shown in Figure \ref{fig:process-deps}, everything is properly displayed.

\hypertarget{more-events}{%
\subsection{More events}\label{more-events}}

There exists \href{https://getbootstrap.com/docs/4.0/components/navs/\#events}{events} that trigger after/before showing/hiding a tabs, that is \texttt{hidden.bs.tab} and \texttt{shown.bs.tab} (\texttt{hide.bs.tab} and \texttt{show.bs.tab} are triggered before). For instance, we may recover
the previously selected tab, namely \texttt{e.relatedTarget}, and store it in a shiny input with \texttt{Shiny.setInputValue}:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
\AttributeTok{$}\NormalTok{(}\StringTok{'a[data-toggle="tab"]'}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'shown.bs.tab'}\OperatorTok{,} \KeywordTok{function}\NormalTok{ (e) }\OperatorTok{\{}
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\StringTok{'previous_tab'}\OperatorTok{,} \VariableTok{e}\NormalTok{.}\AttributeTok{relatedTarget}\NormalTok{)}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

TO FINISH

\hypertarget{part-beautify-with-css-and-sass}{%
\part*{Beautify with CSS and SASS}\label{part-beautify-with-css-and-sass}}
\addcontentsline{toc}{part}{Beautify with CSS and SASS}

This part will introduce you to tools like \href{https://dreamrs.github.io/fresh/index.html}{\{fresh\}} and \href{https://rstudio.github.io/bootstraplib/index.html}{\{bootstraplib\}}

\hypertarget{beautify-with-fresh}{%
\chapter{Beautify with fresh}\label{beautify-with-fresh}}

\href{https://github.com/dreamRs/fresh}{\{fresh\}} is an R package developed by the dreamRs team, also authors of \href{https://github.com/dreamRs/shinyWidgets}{shinyWidget} and \href{https://github.com/dreamRs/esquisse}{esquisse}. All dreamRs projects are clearly a great source of inspiration to design oustansding Shiny apps, I recommend the reader to explore!

\hypertarget{fresh-the-big-picture}{%
\section{\{fresh\}, the big picture}\label{fresh-the-big-picture}}

CSS is probably the poor sibling of this book, which is mainly focused on R and JavaScript interactions. Nevertheless, it remains important to develop consistant themes. One of the main problem with CSS is to handle the growing number of files and the code repetition. Nowadays, web developers mainly use \href{https://sass-lang.com/guide}{SASS}, which provides access to variables, mathematical operators, nesting, thereby reducing the code complexicity and extending the possibilities. \href{https://rstudio.com}{Rstudio} developed the \href{https://rstudio.github.io/sass/articles/sass.html}{\{sass\}} package, which makes it possible to use in Shiny apps or Rmarkdown documents. \{fresh\} is built on top of \{sass\} and wat you see in Figure \ref{fig:bs4Dash-fresh} may be done in few minutes!

\begin{figure}
\includegraphics[width=34.22in]{images/beautify/bs4Dash-fresh} \caption{Few lines of code to create a bs4Dash dark theme!}\label{fig:bs4Dash-fresh}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(bs4Dash)}
\CommentTok{# Theme -------------------------------------------------------------------}

\NormalTok{bs4DashTheme <-}\StringTok{ }\KeywordTok{create_theme}\NormalTok{(}
  \KeywordTok{bs4dash_vars}\NormalTok{(}
    \DataTypeTok{navbar_dark_color =} \StringTok{"#bec5cb"}\NormalTok{,}
    \DataTypeTok{navbar_dark_active_color =} \StringTok{"#FFF"}\NormalTok{,}
    \DataTypeTok{navbar_dark_hover_color =} \StringTok{"#FFF"}
\NormalTok{  ),}
  \KeywordTok{bs4dash_yiq}\NormalTok{(}\DataTypeTok{contrasted_threshold =} \DecValTok{10}\NormalTok{, }\DataTypeTok{text_dark =} \StringTok{"#FFF"}\NormalTok{, }\DataTypeTok{text_light =} \StringTok{"#272c30"}\NormalTok{),}
  \KeywordTok{bs4dash_layout}\NormalTok{(}\DataTypeTok{main_bg =} \StringTok{"#353c42"}\NormalTok{),}
  \KeywordTok{bs4dash_sidebar_dark}\NormalTok{(}
    \DataTypeTok{bg =} \StringTok{"#272c30"}\NormalTok{, }\DataTypeTok{color =} \StringTok{"#bec5cb"}\NormalTok{, }\DataTypeTok{hover_color =} \StringTok{"#FFF"}\NormalTok{,}
    \DataTypeTok{submenu_bg =} \StringTok{"#272c30"}\NormalTok{, }\DataTypeTok{submenu_color =} \StringTok{"#FFF"}\NormalTok{, }\DataTypeTok{submenu_hover_color =} \StringTok{"#FFF"}
\NormalTok{  ),}
  \KeywordTok{bs4dash_status}\NormalTok{(}\DataTypeTok{dark =} \StringTok{"#272c30"}\NormalTok{),}
  \KeywordTok{bs4dash_color}\NormalTok{(}\DataTypeTok{gray_900 =} \StringTok{"#FFF"}\NormalTok{, }\DataTypeTok{white =} \StringTok{"#272c30"}\NormalTok{)}
\NormalTok{)}



\CommentTok{# App ---------------------------------------------------------------------}


\NormalTok{ui <-}\StringTok{ }\KeywordTok{bs4DashPage}\NormalTok{(}
  \DataTypeTok{title =} \StringTok{"bs4Dash Dark Mode"}\NormalTok{,}
  \CommentTok{# sidebar_collapsed = FALSE,}
  \DataTypeTok{navbar =} \KeywordTok{bs4DashNavbar}\NormalTok{(}\DataTypeTok{skin =} \StringTok{"dark"}\NormalTok{),}
  \DataTypeTok{controlbar =} \KeywordTok{bs4DashControlbar}\NormalTok{(}
    \DataTypeTok{skin =} \StringTok{"dark"}\NormalTok{,}
    \StringTok{"This is the control bar"}
\NormalTok{  ),}
  \DataTypeTok{sidebar =} \KeywordTok{bs4DashSidebar}\NormalTok{(}
    \DataTypeTok{title =} \StringTok{"bs4Dash Dark Mode"}\NormalTok{,}
    \DataTypeTok{skin =} \StringTok{"dark"}\NormalTok{,}
    \KeywordTok{bs4SidebarMenu}\NormalTok{(}
      \KeywordTok{bs4SidebarHeader}\NormalTok{(}\StringTok{"Menu:"}\NormalTok{),}
      \KeywordTok{bs4SidebarMenuItem}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \DataTypeTok{text =} \StringTok{"UI components"}\NormalTok{,}
        \DataTypeTok{icon =} \StringTok{"home"}
\NormalTok{      ),}
      \KeywordTok{bs4SidebarMenuItem}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
        \DataTypeTok{text =} \StringTok{"Tab 2"}
\NormalTok{      ),}
      \KeywordTok{bs4SidebarMenuItem}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Item List"}\NormalTok{,}
        \DataTypeTok{icon =} \StringTok{"bars"}\NormalTok{,}
        \DataTypeTok{startExpanded =} \OtherTok{TRUE}\NormalTok{,}
        \KeywordTok{bs4SidebarMenuSubItem}\NormalTok{(}
          \DataTypeTok{text =} \StringTok{"Item 1"}\NormalTok{,}
          \DataTypeTok{tabName =} \StringTok{"item1"}\NormalTok{,}
          \DataTypeTok{icon =} \StringTok{"circle-thin"}
\NormalTok{        ),}
        \KeywordTok{bs4SidebarMenuSubItem}\NormalTok{(}
          \DataTypeTok{text =} \StringTok{"Item 2"}\NormalTok{,}
          \DataTypeTok{tabName =} \StringTok{"item2"}\NormalTok{,}
          \DataTypeTok{icon =} \StringTok{"circle-thin"}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{body =} \KeywordTok{bs4DashBody}\NormalTok{(}

    \KeywordTok{use_theme}\NormalTok{(bs4DashTheme),}

    \KeywordTok{bs4TabItems}\NormalTok{(}
      \KeywordTok{bs4TabItem}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{h2}\NormalTok{(}\StringTok{"UI components"}\NormalTok{),}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{h4}\NormalTok{(}\StringTok{"bs4ValueBox"}\NormalTok{),}
        \KeywordTok{fluidRow}\NormalTok{(}
          \KeywordTok{bs4ValueBox}\NormalTok{(}
            \DataTypeTok{value =} \DecValTok{150}\NormalTok{,}
            \DataTypeTok{subtitle =} \StringTok{"ValueBox with primary status"}\NormalTok{,}
            \DataTypeTok{status =} \StringTok{"primary"}\NormalTok{,}
            \DataTypeTok{icon =} \StringTok{"shopping-cart"}\NormalTok{,}
            \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{4}
\NormalTok{          ),}
          \KeywordTok{bs4ValueBox}\NormalTok{(}
            \DataTypeTok{value =} \DecValTok{150}\NormalTok{,}
            \DataTypeTok{subtitle =} \StringTok{"ValueBox with secondary status"}\NormalTok{,}
            \DataTypeTok{status =} \StringTok{"secondary"}\NormalTok{,}
            \DataTypeTok{icon =} \StringTok{"shopping-cart"}\NormalTok{,}
            \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{4}
\NormalTok{          ),}
          \KeywordTok{bs4ValueBox}\NormalTok{(}
            \DataTypeTok{value =} \StringTok{"53%"}\NormalTok{,}
            \DataTypeTok{subtitle =} \StringTok{"ValueBox with danger status"}\NormalTok{,}
            \DataTypeTok{status =} \StringTok{"danger"}\NormalTok{,}
            \DataTypeTok{icon =} \StringTok{"cogs"}\NormalTok{,}
            \DataTypeTok{footer =} \StringTok{"Hello World"}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{4}
\NormalTok{          )}
\NormalTok{        ),}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{h4}\NormalTok{(}\StringTok{"bs4InfoBox"}\NormalTok{),}
        \KeywordTok{fluidRow}\NormalTok{(}
          \KeywordTok{bs4InfoBox}\NormalTok{(}
            \DataTypeTok{value =} \DecValTok{150}\NormalTok{,}
            \DataTypeTok{title =} \StringTok{"InfoBox with primary status"}\NormalTok{,}
            \DataTypeTok{iconStatus =} \StringTok{"primary"}\NormalTok{,}
            \DataTypeTok{icon =} \StringTok{"shopping-cart"}\NormalTok{,}
            \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{4}
\NormalTok{          ),}
          \KeywordTok{bs4InfoBox}\NormalTok{(}
            \DataTypeTok{value =} \DecValTok{150}\NormalTok{,}
            \DataTypeTok{title =} \StringTok{"InfoBox with secondary status"}\NormalTok{,}
            \DataTypeTok{iconStatus =} \StringTok{"secondary"}\NormalTok{,}
            \DataTypeTok{icon =} \StringTok{"shopping-cart"}\NormalTok{,}
            \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{4}
\NormalTok{          ),}
          \KeywordTok{bs4InfoBox}\NormalTok{(}
            \DataTypeTok{value =} \StringTok{"53%"}\NormalTok{,}
            \DataTypeTok{title =} \StringTok{"InfoBox with danger status"}\NormalTok{,}
            \DataTypeTok{iconStatus =} \StringTok{"danger"}\NormalTok{,}
            \DataTypeTok{icon =} \StringTok{"cogs"}\NormalTok{,}
            \DataTypeTok{footer =} \StringTok{"Hello World"}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{4}
\NormalTok{          )}
\NormalTok{        ),}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{h4}\NormalTok{(}\StringTok{"bs4Card"}\NormalTok{),}
        \KeywordTok{fluidRow}\NormalTok{(}
          \KeywordTok{bs4Card}\NormalTok{(}
            \DataTypeTok{title =} \StringTok{"Card with primary status"}\NormalTok{,}
            \DataTypeTok{closable =} \OtherTok{FALSE}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
            \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
            \DataTypeTok{status =} \StringTok{"primary"}\NormalTok{,}
            \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
            \KeywordTok{p}\NormalTok{(}\StringTok{"Box Content"}\NormalTok{)}
\NormalTok{          ),}
          \KeywordTok{bs4Card}\NormalTok{(}
            \DataTypeTok{title =} \StringTok{"Card with secondary status"}\NormalTok{,}
            \DataTypeTok{closable =} \OtherTok{FALSE}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
            \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
            \DataTypeTok{status =} \StringTok{"secondary"}\NormalTok{,}
            \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
            \KeywordTok{p}\NormalTok{(}\StringTok{"Box Content"}\NormalTok{)}
\NormalTok{          ),}
          \KeywordTok{bs4Card}\NormalTok{(}
            \DataTypeTok{title =} \StringTok{"Card with danger status"}\NormalTok{,}
            \DataTypeTok{closable =} \OtherTok{FALSE}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
            \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
            \DataTypeTok{status =} \StringTok{"danger"}\NormalTok{,}
            \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
            \KeywordTok{p}\NormalTok{(}\StringTok{"Box Content"}\NormalTok{)}
\NormalTok{          ),}
          \KeywordTok{bs4Card}\NormalTok{(}
            \DataTypeTok{title =} \StringTok{"Card with warning status"}\NormalTok{,}
            \DataTypeTok{closable =} \OtherTok{FALSE}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
            \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
            \DataTypeTok{status =} \StringTok{"warning"}\NormalTok{,}
            \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
            \KeywordTok{p}\NormalTok{(}\StringTok{"Box Content"}\NormalTok{)}
\NormalTok{          ),}
          \KeywordTok{bs4Card}\NormalTok{(}
            \DataTypeTok{title =} \StringTok{"Card with info status"}\NormalTok{,}
            \DataTypeTok{closable =} \OtherTok{FALSE}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
            \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
            \DataTypeTok{status =} \StringTok{"info"}\NormalTok{,}
            \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
            \KeywordTok{p}\NormalTok{(}\StringTok{"Box Content"}\NormalTok{)}
\NormalTok{          ),}
          \KeywordTok{bs4Card}\NormalTok{(}
            \DataTypeTok{title =} \StringTok{"Card with success status"}\NormalTok{,}
            \DataTypeTok{closable =} \OtherTok{FALSE}\NormalTok{,}
            \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
            \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
            \DataTypeTok{status =} \StringTok{"success"}\NormalTok{,}
            \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
            \KeywordTok{p}\NormalTok{(}\StringTok{"Box Content"}\NormalTok{)}
\NormalTok{          )}
\NormalTok{        )}
\NormalTok{      ),}
      \KeywordTok{bs4TabItem}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
        \StringTok{"Nothing to see here"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}


\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}

\NormalTok{\}}


\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\bibliography{book.bib,packages.bib}

\end{document}
