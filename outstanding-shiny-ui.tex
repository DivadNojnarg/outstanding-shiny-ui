% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[
  10pt,
]{krantz}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
  \setmonofont[Scale=0.7]{Source Code Pro}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Outstanding User Interfaces with Shiny},
  pdfauthor={David Granjon},
  colorlinks=true,
  linkcolor=Maroon,
  filecolor=Maroon,
  citecolor=Blue,
  urlcolor=Blue,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.33,0.33,0.33}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.61,0.61,0.61}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.14,0.14,0.14}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.43,0.43,0.43}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage[bf,singlelinecheck=off]{caption}

\usepackage{framed,color}
\definecolor{shadecolor}{RGB}{248,248,248}

\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\renewenvironment{quote}{\begin{VF}}{\end{VF}}
\let\oldhref\href
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}

\makeatletter
\newenvironment{kframe}{%
\medskip{}
\setlength{\fboxsep}{.8em}
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\renewenvironment{Shaded}{\begin{kframe}}{\end{kframe}}

\usepackage{makeidx}
\makeindex

\urlstyle{tt}

\usepackage{awesomebox}

\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother

\frontmatter
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Outstanding User Interfaces with Shiny}
\author{David Granjon}
\date{2021-03-01}

\begin{document}
\maketitle

% you may need to leave a few empty pages before the dedication page

%\cleardoublepage\newpage\thispagestyle{empty}\null
%\cleardoublepage\newpage\thispagestyle{empty}\null
%\cleardoublepage\newpage
\thispagestyle{empty}

\begin{center}
To my daughter, my wife and my family,

who gave me the inspiration to write this book
%\includegraphics{images/dedication.pdf}
\end{center}

\setlength{\abovedisplayskip}{-5pt}
\setlength{\abovedisplayshortskip}{-5pt}

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\listoftables
\listoffigures
\hypertarget{welcome}{%
\chapter*{Welcome}\label{welcome}}


This book is still under active development and intended for a 2021 Q2 release in the \href{https://www.routledge.com/go/the-r-series}{R Series} by Chapman
\& Hall.

\hypertarget{is-this-book-for-me}{%
\section*{Is this book for me?}\label{is-this-book-for-me}}


Before going further, the reader must:

\begin{itemize}
\tightlist
\item
  Be comfortable with basic R structures and concepts, functional and object oriented programming (\href{https://r6.r-lib.org/}{R6})
\item
  Have solid knowledge of \href{https://mastering-shiny.org}{Shiny}
\end{itemize}

Basic knowledge in HTML and JavaScript is a plus but not mandatory.

If you fulfill the above prerequisites, you should read this book if you answer yes to the following questions:

\begin{itemize}
\tightlist
\item
  Do you want to know how to develop shiny apps with a more professional look and feel?
\item
  Have you ever wondered how to design new input widgets to unleash interactivity?
\item
  Are you simply curious about what happens under the hood?
\end{itemize}

\hypertarget{learning-objectives}{%
\section*{Learning objectives}\label{learning-objectives}}


This book will help you to:

\begin{itemize}
\tightlist
\item
  Manipulate Shiny tags from R to create custom layouts
\item
  Harness the power of CSS and JavaScript to quickly design apps standing out from the pack
\item
  Discover the steps to import and convert existing web frameworks like \href{https://getbootstrap.com/}{Bootstrap 4}, \href{https://framework7.io/}{framework7}
\item
  Learn how Shiny internally deals with inputs
\item
  Learn more about less documented Shiny mechanisms (websockets, sessions, \ldots)
\end{itemize}

\hypertarget{why-this-book}{%
\section{Why another Shiny related book?}\label{why-this-book}}

There are various Shiny focused resources introducing \href{https://shiny.rstudio.com/tutorial/}{basic} as well as advanced topics such as \href{https://shiny.rstudio.com/articles/\#modules}{modules} and \href{https://js4shiny.com}{Javascript/R} interactions, however, handling advanced user interfaces design was never an emphasis. Clients often desire custom templates, yet this generally exceeds core features of Shiny (not out of the box).

Generally, R App developers lack a significant background in web development and often find this requirement overwhelming. It was this sentiment that motivated writing this book, namely to provide readers the necessary knowledge to extend Shiny's layout, input widgets and output elements. This project officially started at the end of 2018 but was stopped when Joe Cheng revealed the upcoming \href{https://mastering-shiny.org}{Mastering Shiny Book}. Fortunately, the later, does not cover a lot about the customization of Shiny user interfaces. Besides, this book may constitute a good complement to the work in progress \href{https://engineering-shiny.org}{Engineering Production-Grade Shiny Apps} by the ThinkR team, where the link between Shiny and CSS/JavaScript is covered. For a deep dive into JavaScript and R interactions, the \href{https://javascript-for-r.com/}{upcoming book} by John Coene covers topics like htmlWidgets, interactive documents and computations.

\hypertarget{book-structure}{%
\section*{Book structure}\label{book-structure}}


This book is organized into eight parts.

\begin{itemize}
\tightlist
\item
  Part 1 demonstrates the link between Shiny and the classic web languages like HTML, CSS and JavaScript. We gradually introduce
  necessary web development knowledge to be able to read the book. We finish by exploring the web dependencies behind Shiny such as Bootstrap and jQuery.
\item
  In part 2, we dive into the \texttt{\{htmltools\}} \citep{R-htmltools} package, providing functions to create and manipulate HTML tags from R as well as manage web dependencies.
\item
  Part 3 focuses on CSS and Sass. We provide the reader with basic CSS knowledge to get the most out of Sass, a powerful tool to seamlessly alter Shiny apps style, in a more reproducible manner. All along this part, we showcase examples from the R community like \texttt{\{fresh\}} \citep{R-fresh} and \texttt{\{bslib\}} \citep{R-bslib}, to significantly beautify apps with only few lines of code.
\item
  Part 4 contains chapters dedicated to the Shiny input system. This part starts with a JavaScript hands on, then exposes how Shiny works under the hood by introducing the websockets which allows the communication between R and JavaScript. We explore the Shiny input life cycle, that is how they are created and updated. We expose JS techniques to get rid of unnecessary \texttt{renderUI} patterns that may speed up Shiny apps. This part contains many hidden gems to significantly and quickly enhance apps.
\item
  Part 5 focuses on the development of a new template for Shiny by demonstrating examples from the \texttt{\{tablerDash\}} \citep{R-tablerDash} package. These, and more may be explored further as part of the \href{https://rinterface.com/}{RinteRface} project. This case study mobilizes all knowledge acquired in the previous parts.
\item
  Part 6 introduces a new opinionated package, \texttt{\{charpente\}} \citep{R-charpente}, that substantially reduce the burden of JavaScript management during the development of Shiny extensions.
\item
  Part 7 dives into mobile web development through a practical study involving a rework of \texttt{\{shinyMobile\}} \citep{R-shinyMobile}. We give a brief introduction to the progressive web application world with some patterns to get started like service workers, web manifests,
  offline pages.
\item
  Part 8 exposes other alternatives like React, taking examples from the \texttt{\{reactR\}} \citep{R-reactR} package.
\end{itemize}

Parts are sorted by difficulty level, the last one being the most technical. However, this does not mean the reader
must read all chapters. Given the very heterogeneous background of the community, some people may focus on the JavaScript section, while
others will read the Sass part or the mobile development examples. Some patterns exposed in this book may apply
to classic Shiny apps projects, that are not necessarily meant to extend Shiny per se, but may need a highly customized experience.
Beyond the aesthetic aspect, this book tries to expose best practices to develop optimized shiny apps!

By the end of that book, the reader should be able to entirely customize Shiny in a reasonable amount of time.

\hypertarget{welcome-code-structure}{%
\section{Code structure}\label{welcome-code-structure}}

This book has a side package containing all the necessary material to run the code without having to reload each previous snippet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{remotes}\OperatorTok{::}\KeywordTok{install_github}\NormalTok{(}\StringTok{"DivadNojnarg/outstanding-shiny-ui-code}
\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

It covers Chapters \ref{shiny-input-system}, \ref{shiny-custom-handler} and the whole Practice section.

There is another good reason for this package: provide a robust method to bundle JavaScript/CSS code along side any shiny app. Indeed, it is quite tempting to proceed as below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      Shiny.addCustomMessageHandler('hello', function(message) \{     }
\StringTok{        alert(message); }
\StringTok{      \});}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"go"}\NormalTok{, }\StringTok{"Send"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{go, \{}
\NormalTok{    session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\StringTok{"hello"}\NormalTok{, }\DataTypeTok{message =} \StringTok{"plop"}\NormalTok{)}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

It is fine if the app purpose is a simple demonstration. In our case, since we aim at providing reusable template elements, we need a better approach, that will be described later.

\hypertarget{preliminary-exercices}{%
\section*{Preliminary exercices}\label{preliminary-exercices}}


Before starting with technical details, we propose to play a little game. Among all the images shown, what are the ones corresponding to shiny apps?

\includegraphics[width=0.5\linewidth]{images/intro/nifty} \includegraphics[width=0.5\linewidth]{images/intro/virtual_patient}

\includegraphics[width=0.5\linewidth]{images/intro/covid-tracker} \includegraphics[width=0.5\linewidth]{images/intro/tabler}

\hypertarget{extra-material}{%
\section*{Extra material}\label{extra-material}}


This book may serve as material for workshops. See below a list of recent events.

\hypertarget{e-rum-2020}{%
\subsection*{e-Rum 2020}\label{e-rum-2020}}


\href{https://www.novartis.com}{Novartis} associates Mustapha Larbaoui and David Granjon gave a workshop entitled ``Advanced User Interfaces for Shiny Developers'' at the latest 2020 virtual \href{https://2020.erum.io/program/workshops/}{e-Rum} conference whose detailed agenda is available \href{https://github.com/Novartis/Advanced-User-Interfaces-for-Shiny-Developers}{here}. This two hours workshop takes a lot of inspiration on this book. An \href{https://rstudio.cloud}{RStudio Cloud} dedicated project is deployed \href{https://rstudio.cloud/project/1395473}{here} and slides are located \href{https://rinterface.com/shiny/talks/eRum2020/dg/index.html}{here}.

\hypertarget{rpharma-2020}{%
\subsection*{R/Pharma 2020}\label{rpharma-2020}}


This books served as resource for the 2020 \href{https://rinpharma.com/workshops/}{R/Pharma} \textbf{Unleash Shiny} workshop held by John Coene, Colin Fay and David Granjon. Slides are available \href{https://rinterface.com/shiny/talks/RPharma2020/}{here} and exercises accessible from \href{https://github.com/RinteRface/Unleash-Shiny}{here}. This workshop expects an higher level than the e-Rum one.

\hypertarget{about-rinterface}{%
\section*{About RinteRface}\label{about-rinterface}}


The \href{https://rinterface.com/}{RinteRface} project is an initiative aiming to provide one of the most famous HTML \href{https://github.com/RinteRface}{templates} to Shiny. Everything started by the collaboration of \href{https://john-coene.com/}{John Coene} and \href{https://divadnojnarg.github.io/}{David Granjon} early 2018 on \texttt{\{shinybulma\}} \citep{R-shinybulma} to officially release RinteRface November 2018 with \texttt{\{shinydashboardPlus\}} \citep{R-shinydashboardPlus}, \texttt{\{bs4Dash\}} \citep{R-bs4Dash} as line-up packages.

\begin{figure}
\includegraphics[width=1\linewidth]{images/intro/rinterface_release} \caption{Official release of RinteRface, November 28 2018}\label{fig:rinterface-release}
\end{figure}

The biggest RinteRface accomplishment is probably the work in progress \texttt{\{shinyMobile\}} package, which was initially called \texttt{\{shinyF7\}}, in collaboration with the \href{https://www.dreamrs.fr/}{dreamRs} team.

Since 2019, RinteRface has been involved in various R related events like local R meetups or conferences (\href{https://www.meetup.com/fr-FR/Zurich-R-User-Group/}{Zurich R User Group}, \href{https://www.meetup.com/BaselR/}{baselR}, \href{https://user2019.r-project.org/}{useR2019}, \href{https://neuchatel2020.satrdays.org/}{satRdayNeuchatel2020}, \href{https://2020.erum.io/}{e-Rum2020}, \href{https://rinpharma.com/}{RPharma2020}).

RinteRface is a contributor in the \href{https://shinydevseries.com/post/episode-4-rinterface/}{Shiny Developers Series}, hosted by Eric Nantz, also known as the \href{https://r-podcast.org/}{theRcast}.

RinteRface work has been awarded several times at the 2 latest shiny contests (2019 and 2020), through contributions like:

\begin{itemize}
\tightlist
\item
  A virtual \href{https://community.rstudio.com/t/shiny-contest-submission-a-virtual-lab-for-teaching-physiology/25348}{lab} for teaching physiology (2019), the Apps.Physiol \href{https://rinterface.com/AppsPhysiol.html}{plateform}, fuelled by \texttt{\{bs4Dash\}} and hosted in \texttt{\{CaPO4Sim\}} \citep{R-CaPO4Sim}
\end{itemize}

\begin{figure}
\includegraphics[width=1\linewidth]{images/intro/virtual_patient_mobile} \caption{The virtual patient simulator of {CaPO4Sim}}\label{fig:virtual-patient}
\end{figure}

\begin{itemize}
\tightlist
\item
  \texttt{\{deminR\}} \citep{R-deminR}, a \href{https://community.rstudio.com/t/deminr-a-minesweeper-for-r-2020-shiny-contest-submission/56356}{minesweeper} for R (2020), powered by \texttt{\{shinyMobile\}}
\end{itemize}

\begin{figure}
\includegraphics[width=1\linewidth]{images/intro/deminR_light} \caption{{deminR}, a minesweeper for R}\label{fig:deminR}
\end{figure}

RinteRface is very grateful to the R community and this book is a sort of acknowledgment!

\hypertarget{acknowledgements}{%
\section*{Acknowledgements}\label{acknowledgements}}


\begin{itemize}
\tightlist
\item
  I am very grateful to Douglas Robinson for proof reading the book and fixing many typos it contained
\item
  A special thanks to my friends John and Victor for contributing to \href{https://rinterface.com/}{RinteRface}
\item
  Thanks to the eRum organizers for inviting me to the virtual \href{https://2020.erum.io}{e-Rum2020} conference
\item
  RinteRface and this book won't exist without the amazing R community. Thanks for their valuable feedback
\end{itemize}

\hypertarget{packages}{%
\section*{Packages}\label{packages}}


This book was built with R version 3.6.1 (2019-07-05) and the following packages:

\begin{longtable}[]{@{}lll@{}}
\toprule
package & version & source\tabularnewline
\midrule
\endhead
apexcharter & 0.1.8 & CRAN (R 3.6.2)\tabularnewline
blogdown & 1.1 & CRAN (R 3.6.2)\tabularnewline
bs4Dash & 2.0.0.9000 & local\tabularnewline
bslib & 0.2.4 & CRAN (R 3.6.1)\tabularnewline
CaPO4Sim & 0.2.0.9000 & local\tabularnewline
charpente & 0.0.0.9000 & local\tabularnewline
deminR & 0.0.0.9000 & Github (DivadNojnarg/deminR@e0bf665)\tabularnewline
dplyr & 1.0.3 & CRAN (R 3.6.2)\tabularnewline
fresh & 0.2.0.9010 & Github (dreamRs/fresh@bf1e00a)\tabularnewline
ggplot2 & 3.3.3 & CRAN (R 3.6.2)\tabularnewline
golem & 0.3.0 & Github (ThinkR-open/golem@558a715)\tabularnewline
htmltools & 0.5.1.9000 & Github (rstudio/htmltools@e7f0393)\tabularnewline
httpuv & 1.5.5 & CRAN (R 3.6.2)\tabularnewline
jstools & 0.1.0 & Github (dreamRs/jstools@5689973)\tabularnewline
magrittr & 2.0.1 & CRAN (R 3.6.2)\tabularnewline
purrr & 0.3.4 & CRAN (R 3.6.2)\tabularnewline
reactR & 0.4.3 & Github (react-R/reactR@da3e6af)\tabularnewline
scales & 1.1.1 & CRAN (R 3.6.2)\tabularnewline
shiny & 1.6.0 & CRAN (R 3.6.2)\tabularnewline
shinybulma & 0.0.2.9000 & local\tabularnewline
shinydashboard & 0.7.1 & CRAN (R 3.6.0)\tabularnewline
shinydashboardPlus & 2.0.0.9000 & local\tabularnewline
shinyjs & 2.0.0 & CRAN (R 3.6.1)\tabularnewline
shinyMobile & 1.0.0.9000 & local\tabularnewline
shinyWidgets & 0.5.6 & CRAN (R 3.6.2)\tabularnewline
tablerDash & 0.1.5 & Github (RinteRface/tablerDash@341efde)\tabularnewline
testthat & 3.0.1 & CRAN (R 3.6.2)\tabularnewline
thematic & 0.1.1.9000 & Github (rstudio/thematic@45454fa)\tabularnewline
websocket & 1.3.1 & CRAN (R 3.6.2)\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{foreword}{%
\chapter*{Foreword}\label{foreword}}


\begin{quote}
By Kenton Russel aka @timelyportfolio
\end{quote}

Since the initial commit (\url{https://github.com/rstudio/shiny/commit/e28b3da1badfecb34235e74a43aac4e8da1641bc}) of Shiny in June 2012, the project has grown rapidly with users around the world across nearly every domain. Strangely though there are nearly zero comprehensive resources collecting the scattered wisdom and experience of thousands of Shiny users and developers into a single definitive resource. Fortunately, this book addresses the gap offering a detailed up-to-date compilation on Shiny to benefit users of all skill levels from beginner to advanced. As I read through the early drafts, I kept saying to myself with a smile, ``Yes, finally''. This book fills a void covering some topics for which an Internet search might yield no useful results.

Successful open source requires skillful developers, active engaged users, and helpful supporters. In the R/Shiny community, David Granjon, PhD fulfills all three roles as a prolific R package creator, educated and thoughtful user with domain expertise, and educator (workshops, posts, and forum responses). I cannot think of anyone more qualified to write a book on Shiny, and I am so happy that David has spent the time to generously share his wisdom and experience in this excellent resource.

\hypertarget{part-introduction}{%
\part*{Introduction}\label{part-introduction}}


In this part, we show the deep link between Shiny and the web languages.

\mainmatter

\hypertarget{web-intro}{%
\chapter{Shiny and the Web}\label{web-intro}}

\begin{quote}
Shiny is designed so that, as an R user, you don't need to learn about the details of HTML \ldots{}
\hfill --- Hadley Wickham
\end{quote}

\texttt{\{shiny\}} \citep{R-shiny} allows the development of web applications with R in minutes. Let's face it: this is quite mind blowing! While this may not be a production ready app, it will still be a fully functional, working prototype. Believe me, doing a web application with pure HTML/CSS and JavaScript is more difficult, especially for someone with a non-web developer background.

We first load \texttt{\{shiny\}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\end{Highlighting}
\end{Shaded}

\hypertarget{shiny-generates-html-code-from-r}{%
\section{Shiny generates HTML code from R}\label{shiny-generates-html-code-from-r}}

Let's start with a little exercise:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run the following code:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Copy and paste this code to the R console. What do you observe?
\end{enumerate}

Notice the output format is an example of an HTML tag. The \texttt{p} function generates HTML (see chapter \ref{htmltools-overview}). The main difference between HTML tags and Shiny tags is the absence of closing tag for Shiny. For instance, in raw HTML, we expect \texttt{\textless{}p\textgreater{}} to be closed by \texttt{\textless{}/p\textgreater{}}. In Shiny, we only call \texttt{p(...)}, where \texttt{...} may be attributes like class/id or children tags. For a R developer, being able to generate HTML code from R allows to remain focused on the main task instead of the web development burdens.
As stated in the general introduction \ref{why-this-book}, a production app sometimes needs to custom elements that are not contained or hidden in Shiny's core.

Is a Shiny app less customizable than a classic web app? Not at all! Under the hood, Shiny has its own engine to build HTML tags, through R, meaning that all HTML elements are available. You may also include any custom \href{https://shiny.rstudio.com/articles/packaging-javascript.html}{JavaScript} code.

\hypertarget{web-intro-html}{%
\section{HTML 101}\label{web-intro-html}}

This chapter provides a short introduction to the 3 main web languages, namely HTML, CSS and JavaScript.
The following content is crucial to understand part \ref{htmltools-overview} about HTML generation from R.

\hypertarget{html-basics}{%
\subsection{HTML Basics}\label{html-basics}}

HTML (Hypertext Markup Language) is derived from SGML (Standard Generalized markup Language). An HTML file contains tags that may be divided into 2 categories:

\begin{itemize}
\tightlist
\item
  paired-tags: the text is inserted between the opening and the closing tag
\item
  closing-tags
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{<!-- paired-tags -->}
\KeywordTok{<p></p>}
\KeywordTok{<div></div>}

\CommentTok{<!-- self-closing tags -->}
\KeywordTok{<iframe/>}
\KeywordTok{<img/>}
\KeywordTok{<input/>}
\KeywordTok{<br/>}
\end{Highlighting}
\end{Shaded}

Tags may be divided into 3 categories, based on their role:

\begin{itemize}
\tightlist
\item
  structure tags: they constitute the skeleton of the HTML page (\texttt{\textless{}title\textgreater{}\textless{}/title\textgreater{}}, \texttt{\textless{}head\textgreater{}\textless{}/head\textgreater{}}, \texttt{\textless{}body\textgreater{}\textless{}/body\textgreater{}})
\item
  control tags: script, inputs and buttons (and more). Their role is to include external resources, provide interactivity with the user
\item
  formatting tags: to control the size, font of the wrapped text
\end{itemize}

Finally, we distinguish block and inline elements:

\begin{itemize}
\tightlist
\item
  block elements may contain other tags and take the full width (block or inline). \texttt{\textless{}div\textgreater{}\textless{}/div\textgreater{}} is the most commonly used block element. All elements of a block are printed on top of each others
\item
  inline elements (for instance \texttt{\textless{}span\textgreater{}\textless{}/span\textgreater{}}, \texttt{\textless{}a\textgreater{}\textless{}/a\textgreater{}}) are printed on the same line. They can not contain block tags but may contain other nested inline tags. In practice, we often see \texttt{\textless{}a\textgreater{}\textless{}span\textgreater{}\textless{}/span\textgreater{}\textless{}/a\textgreater{}}
\item
  inline-block elements allow to insert block element in an inline
\end{itemize}

Consider the following example. This is clearly a bad use of HTML conventions since an inline tag can not host block elements.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<span>}
  \KeywordTok{<div><p>}\NormalTok{Hello World}\KeywordTok{</p></div>}
  \KeywordTok{<div></div>}
\KeywordTok{</span>}
\end{Highlighting}
\end{Shaded}

Importantly, \texttt{\textless{}div\textgreater{}} and \texttt{\textless{}span\textgreater{}} don't have any semantic meaning, contrary to \texttt{\textless{}header\textgreater{}} and \texttt{\textless{}footer\textgreater{}}, which allow to structure the HTML page.

\hypertarget{tag-attributes}{%
\subsection{Tag attributes}\label{tag-attributes}}

Attributes are text elements allowing to specify some properties of the tag. For instance for a link tag (\texttt{\textless{}a\textgreater{}\textless{}/a\textgreater{}}), we actually expect more than just the tag itself: a target url and how to open the new page \ldots{} In all previous examples, tags don't have any attributes. Yet, there exist a large range of attributes and we will only see 2 of them for now (the reason is that these are the most commonly used in CSS and JavaScript):

\begin{itemize}
\tightlist
\item
  class: may be shared between multiple tags
\item
  id: each must be unique
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"awesome-item"}\OtherTok{ id=}\StringTok{"myitem"}\KeywordTok{></div>}
\CommentTok{<!-- the class awesome-item may be applied to multiple tags -->}
\KeywordTok{<span}\OtherTok{ class=}\StringTok{"awesome-item"}\KeywordTok{></span>}
\end{Highlighting}
\end{Shaded}

Both attributes are widely used by CSS and JavaScript (see Chapter \ref{survival-kit-javascript} with the jQuery selectors) to apply a custom style to a web page. Class attributes apply to multiple elements, however the id attribute is restricted to only one item.

Interestingly, there exists another attribute category, know as non-standard attributes like \texttt{data-toggle}. We will see them later in the book (see Chapter \ref{custom-templates-skeleton}).

\hypertarget{the-simplest-html-skeleton}{%
\subsection{The simplest HTML skeleton}\label{the-simplest-html-skeleton}}

An HTML page is a collection of tags which will be interpreted by the web browser step by step. The simplest HTML page may be defined as follows:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
  \CommentTok{<!-- head content here -->}
    \KeywordTok{<title>}\NormalTok{A title}\KeywordTok{</title>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
  \CommentTok{<!-- body content here -->}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{\textless{}html\textgreater{}} is the may wrapper
\item
  \texttt{\textless{}head\textgreater{}} and \texttt{\textless{}body\textgreater{}} are the 2 main children

  \begin{itemize}
  \tightlist
  \item
    \texttt{\textless{}head\textgreater{}} contains dependencies like styles and JavaScript files (but not only),
  \item
    \texttt{\textless{}body\textgreater{}} contains the page content and it is displayed on the screen. We will see later that JavaScript files are often added just before the end of the \texttt{\textless{}body\textgreater{}}.
  \end{itemize}
\end{itemize}

\begin{warningbox}
Only the \textbf{body} content is \textbf{displayed} on the screen! W3C \href{https://validator.w3.org/\#validate_by_input}{validation} imposes at list a \texttt{title} tag in the \texttt{head} section and a \texttt{lang} attribute to the \texttt{html} tag!

\end{warningbox}

Let's write the famous Hello World in HTML:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
    \CommentTok{<!-- head content here -->}
    \KeywordTok{<title>}\NormalTok{A title}\KeywordTok{</title>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<p>}\NormalTok{Hello World}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

In order to preview this page in a web browser, you need to save the above snippet to a script \texttt{hello-world.html} and double-click on it. It will open with your default web browser.

Below is how we would do with a Shiny app, only for demonstration purpose (static HTML would be enough if no user interaction is required).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}\KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{))}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

From outside, it looks identical even though we'll see in Chapter \ref{web-dependencies} that this simple app actually contains much more HTML than our previous example.

\hypertarget{about-the-document-object-model-dom}{%
\subsection{About the Document Object Model (DOM)}\label{about-the-document-object-model-dom}}

The DOM stands for ``Document Object Model'' and is a convenient representation of the html document. There actually exists multiple DOM types, namely DOM-XML and DOM-HTML but we will only focus on the latter. If we consider the last example (Hello World), the associated DOM tree may be inspected in Figure \ref{fig:html-dom}.

\hypertarget{visualizing-the-dom-with-the-html-inspector}{%
\subsubsection{Visualizing the DOM with the HTML inspector}\label{visualizing-the-dom-with-the-html-inspector}}

Below, we introduce a tool that will facilitate our exploration of beautiful shiny user interfaces. In this section, we restrict the description to the first panel of the HTML inspector \footnote{As shown in Figure \ref{fig:html-dom}, the inspector also has tools to debug JavaScript code as demonstrated in \ref{shiny-js-inspector}, inspect files, run performances audit, inspect websocket activity (see section \ref{shiny-websocket}).}. This feature is available in all web browsers, however for demonstration purposes, we will only focus on the \href{https://developers.google.com/web/tools/chrome-devtools}{Chrome DevTools}. It may be opened:

\begin{itemize}
\tightlist
\item
  After a right click and selecting inspect
\item
  After clicking on F12 (windows), fn + F12 on Mac (or Command+Option+C)
\end{itemize}

In the following:

\begin{itemize}
\tightlist
\item
  Open the hello-world.html example with Chrome
\item
  Right-click to open the HTML inspector (developer tools must be enabled if it is not the case)
\end{itemize}

The HTML inspector is a convenient tool to explore the structure of the current HTML page. On the left-hand side, the DOM tree is displayed where we clearly see that \texttt{\textless{}html\textgreater{}} is the parent of \texttt{\textless{}head\textgreater{}} and \texttt{\textless{}body\textgreater{}}. \texttt{\textless{}body\textgreater{}} has also 1 child, that is \texttt{\textless{}p\textgreater{}}. We may preview any style (CSS) associated with the selected element on the right panel as well as Event Listeners (JavaScript), which will be discussed later in the book.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/dom} \caption{Inspection of the DOM in the Hello World example}\label{fig:html-dom}
\end{figure}

\hypertarget{html-inspector-101}{%
\subsubsection{HTML Inspector 101}\label{html-inspector-101}}

In the following, we enumerate key features of the inspector \texttt{Elements} tab. In addition to explore the HTML \href{https://developers.google.com/web/tools/chrome-devtools/dom}{structure}, the inspector allows to:

\begin{itemize}
\tightlist
\item
  Dynamically change CSS at run time
\item
  Debug JavaScript code (put break points, \ldots)
\item
  Run JavaScript code from the console.
\item
  Monitor any error or warning that may prevent your app or website from properly working
\end{itemize}

Another important feature is the ability to switch between different devices, especially mobile platforms and to do a global performance audit with \href{https://developers.google.com/web/tools/lighthouse}{Google LightHouse}. The \href{https://engineering-shiny.org/when-optimize.html\#tools-for-profiling}{book} from Colin Fay et al.~details the most relevant elements for Shiny app development.

We propose at set of quick exercises to review the most important HTML inspector capabilities that are commonly needed during Shiny app customization. We consider the app already defined above:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}\KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{))}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercise-altering-the-dom-structure}{%
\paragraph{Exercise: Altering the DOM structure}\label{exercise-altering-the-dom-structure}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run the \texttt{Hello\ World} app, right click on the only text element and click on inspect
\item
  Notice we could have done similarly by clicking on the very top left corner \texttt{Inspect} icon (Command + maj + C for Mac) and hovering over the \texttt{Hello\ World} text
\end{enumerate}

You should see a result similar to Figure \ref{fig:html-dom-inspect}, the \texttt{Inspect} icon being in blue. The selected element is highlighted and a white box displays the main CSS properties like \texttt{text-color}, \texttt{font-size}, margins, as well as accessibility parameters.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/survival-kit/dom-inspect} 

}

\caption{Inspection of the p element in the Hello World example}\label{fig:html-dom-inspect}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  In the \texttt{Elements} panel, double click between the \texttt{\textless{}p\textgreater{}} and \texttt{\textless{}/p\textgreater{}} tags to edit the current text. Press enter when finished
\item
  Let's add some children to our \texttt{p} tag. Right click and select the \texttt{Edit\ as\ HTML} option. You may enter any valid HTML code inside. Don't forget about some rules relative to inline and block tags (inline tags cannot contain block tags!!!)
\end{enumerate}

As depicted in Figure \ref{fig:html-dom-edit}, we could have done a right click on the \texttt{p} tag to display more options like:

\begin{itemize}
\tightlist
\item
  Add/edit an attribute. You may try to add it a class \texttt{class="awesome-text"} and an id \texttt{id="only-text"}
\item
  Delete the current tag (the \texttt{return} key would do it as well)
\item
  Copy the element with all nested elements
\item
  Only copy the outside HTML (ignore nested elements)
\item
  Extract the CSS selector or JavaScript path (code to select the element): \texttt{body\ \textgreater{}\ div\ \textgreater{}\ p} and \texttt{document.querySelector("body\ \textgreater{}\ div\ \textgreater{}\ p")}, respectively. These 2 features are extremely powerful as they save you time. Try to copy and paste \texttt{document.querySelector("body\ \textgreater{}\ div\ \textgreater{}\ p")} in the JavaScript console at the bottom of the inspector window. It returns the selected HTML element, as shown in Figure \ref{fig:html-dom-js-path}! Amazing isn' it?
\item
  Hide the element
\item
  Force a specific state. For instance buttons may be \texttt{active}, \texttt{inactive}
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/survival-kit/dom-edit} 

}

\caption{Modifications of the p element in the Hello World example}\label{fig:html-dom-edit}
\end{figure}

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/survival-kit/dom-js-path} 

}

\caption{Extract the JavaScript path to select the p element}\label{fig:html-dom-js-path}
\end{figure}

Whenever you are looking for a specific tag in a more complex page, the \texttt{search\ tag} option is a game changer (Ctrl + F on Windows, command + F within the Elements tab on a Mac). See Figure \ref{fig:html-dom-search}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/survival-kit/dom-search} 

}

\caption{Search for element having the "awesome-text" class}\label{fig:html-dom-search}
\end{figure}

Finally, the inspector toolkit allows to reorder DOM elements with a rather intuitive drag and drop feature. I invite the reader to carefully explore those features as they will be crucial in the next chapters.

\hypertarget{preliminary-introduction-to-css-and-javascript}{%
\subsection{Preliminary introduction to CSS and JavaScript}\label{preliminary-introduction-to-css-and-javascript}}

To introduce this section, I propose to look at the very first website, early in the 90's (August 1991 exactly). From an aesthetic point of view (see Figure \ref{fig:www-first}), this is far from what we can observe today as shown in Figure \ref{fig:www-rinterface}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/www-first} \caption{World wide web website}\label{fig:www-first}
\end{figure}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/www-rinterface} \caption{RinteRface website: https://rinterface.com}\label{fig:www-rinterface}
\end{figure}

How can we explain that difference? One of the main reason is the absence of CSS (Cascading Style Sheet) since the first CSS release only appeared in December 1996, that is 5 years later than the first web site publication. CSS allows to deeply customize the appearance of any web page by changing colors, fonts, margins and much more. We acknowledge, the role of JavaScript cannot be demonstrated through the previous example. Yet its impact is as important as CSS, so that it is now impossible to dissociate HTML, CSS and JavaScript.

\hypertarget{html-and-css}{%
\subsubsection{HTML and CSS}\label{html-and-css}}

CSS (Cascading Style Sheets) changes the style of HTML tags by targeting specific classes or ids. For instance, if we want all \texttt{p} tags to have red color we will use:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \{}
  \KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To include CSS in an HTML page, we use the \texttt{\textless{}style\textgreater{}} tag as follows:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
    \KeywordTok{<style}\OtherTok{ type=}\StringTok{"text/css"}\KeywordTok{>}
\NormalTok{      p \{}
        \KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{      \}}
    \KeywordTok{</style>}
    \KeywordTok{<title>}\NormalTok{A title}\KeywordTok{</title>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<p>}\NormalTok{Hello World}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

You may update the hello-world.html script and run it in your web-browser to see the difference. The example may be slight, but shows how we may control the look and feel of the display. In a development context, we will see later that css files may so big that it is better to include them in external files.

Let's build a shiny app that does similar things. As a reminder, you may use \texttt{tags\$style} to include small pieces of CSS in your app:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}\StringTok{"p \{ color: red;\}"}\NormalTok{),}
  \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{html-and-javascript}{%
\subsubsection{HTML and JavaScript}\label{html-and-javascript}}

You will see how quickly/seamlessly you may add awesome features to your shiny app.

In the following example, we defined the \texttt{changeColor} function that targets the element
having \texttt{hello} id and change its color property to green. The HTML element has an \texttt{onClick} attribute
that triggers the \texttt{changeColor} function each time the button is clicked.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
    \KeywordTok{<style}\OtherTok{ type=}\StringTok{"text/css"}\KeywordTok{>}
\NormalTok{      p \{}
        \KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{      \}}
    \KeywordTok{</style>}
    \KeywordTok{<script}\OtherTok{ language=}\StringTok{"javascript"}\KeywordTok{>}
      \CommentTok{// displays an alert }
      \AttributeTok{alert}\NormalTok{(}\StringTok{'Click on the Hello World text!'}\NormalTok{)}\OperatorTok{;}
      \CommentTok{// change text color}
      \KeywordTok{function} \AttributeTok{changeColor}\NormalTok{(color)}\OperatorTok{\{}
        \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{'hello'}\NormalTok{).}\VariableTok{style}\NormalTok{.}\AttributeTok{color} \OperatorTok{=} \StringTok{"green"}\OperatorTok{;}
      \OperatorTok{\}}
    \KeywordTok{</script>}
    \KeywordTok{<title>}\NormalTok{A title}\KeywordTok{</title>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \CommentTok{<!-- onclick attributes applies the JavaScript function changeColor define above -->}
    \KeywordTok{<p}\OtherTok{ id=}\StringTok{"hello"}\OtherTok{ onclick=}\StringTok{"changeColor('green')"}\KeywordTok{>}\NormalTok{Hello World}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

In few lines of code, you can change the color of the text. This is only the beginning!

We see below that the process is not dramatically different in a Shiny app. We wrap our custom JavaScript in the \texttt{tags\$script} function (prefer external scripts to add more code), as below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"alert('Click on the Hello World text!');}
\StringTok{     // change text color}
\StringTok{     function changeColor(color)\{}
\StringTok{       document.getElementById('hello').style.color = 'green';}
\StringTok{     \}}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{p}\NormalTok{(}\DataTypeTok{id =} \StringTok{"hello"}\NormalTok{, }\DataTypeTok{onclick=}\StringTok{"changeColor('green')"}\NormalTok{, }\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

As demonstrated above, developing a shiny app is basically building a website from R and is completely compatible with the web languages, that is CSS and JavaScript. Sections \ref{htmltools-dependencies} and \ref{shiny-input-system} present more robust tools and concepts to extend Shiny.

\begin{quote}
\ldots{} However, if you already know HTML (or want to learn!) you can also work directly with HTML tags to achieve any level of customization you want
\hfill --- Hadley Wickham
\end{quote}

\hypertarget{web-dependencies}{%
\chapter{Discover Shiny dependencies}\label{web-dependencies}}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

If Shiny creates HTML code for us, it is not enough to design a beautiful working app with user interactions. As shown earlier, all modern web sites and apps have a lot of CSS and JavaScript under the hood. Let's explore these elements in the following exercise.

The simplest Shiny layout is the \texttt{fluidPage}. The \texttt{shinyapp} predefined Rstudio snippet creates a basic app skeleton (type \texttt{shinyapp} in a new script or the console in your RStudio IDE, Figure \ref{fig:shinyapp-snippet}).

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shinyapp-snippet} \caption{shinyapp code snippet}\label{fig:shinyapp-snippet}
\end{figure}

We add some text inside and remove the \texttt{session} parameter from the serve function, as
we don't use any update function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

At first glance, the page only contains text. Wait \ldots{} are you sure about this? Let's run the above example and open the HTML inspector introduced in \ref{web-intro-html}. Results are displayed on Figure \ref{fig:shiny-deps}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-deps} \caption{Shiny dependencies}\label{fig:shiny-deps}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Click on ``Open in Browser''
\item
  Open the HTML inspector
\item
  Locate the \texttt{\textless{}head\textgreater{}} tag
\item
  Uncollapse it and search for the script containing \texttt{application/html-dependencies}
\item
  List all dependencies
\end{enumerate}

We see in the head section (delimited by \texttt{\textless{}head\textgreater{}\textless{}/head\textgreater{}}) that Shiny has four dependencies:

\begin{itemize}
\tightlist
\item
  json2
\item
  jQuery 3.4.1
\item
  shiny (custom JavaScript and CSS)
\item
  Bootstrap 3.4.1 (JavaScript and CSS) + other files (html5shiv, respond)
\end{itemize}

\hypertarget{bootstrap}{%
\section{Bootstrap}\label{bootstrap}}

According to the \href{https://gitstar-ranking.com/}{gitstar} ranking, which is an unofficial Github star ranking website, \href{https://getbootstrap.com}{Bootstrap} comes at the 7th place (144563 stars) and 22th place for repositories and organization, respectively. It has been first released in 2011 and will welcome the fifth \href{https://v5.getbootstrap.com/}{version} in few months. It provides plug and play layout and interactive elements such as tabs, navigation bars, tooltips, popovers and many input (forms), which is rather convenient since it avoids writing a large amount of CSS/JavaScript that would bring more complexity. The first release of Shiny was shipped with \href{https://github.com/rstudio/shinybootstrap2}{Bootstrap 2}. Shiny currently relies on Bootstrap 3 since v0.11, while a lot of efforts are being made to provide a Bootstrap 4 compatibility, essentially through the \href{https://github.com/rstudio/bootstraplib}{bootstraplib} R package.

One of the great advantage of using Bootstrap is the responsiveness of the design that can work either on desktop or mobile, even though advanced user likely prefer other specialized libraries like \href{https://framework7.io/}{Framework7} or \href{https://onsen.io/}{onsenUI} to develop native looking apps.

Bootstrap 3 relies on the grid layout \href{https://getbootstrap.com/docs/3.4/examples/grid/}{system} that allows to efficiently organize the content in row and columns. For instance the \texttt{fluidRow} and \texttt{column} Shiny functions leverage the Bootstrap grid to control how elements are displayed in a page.

How does Shiny attach the Bootstrap dependencies? The well know \texttt{fluidPage} layout is actually hiding a lower level function, that is \texttt{bootstrapPage}. The latter is also called in many other high level layout functions for instance \texttt{fixedPage}, \texttt{fillPage} and \texttt{navbarPage}. It simply attaches \texttt{bootstraplib} as well as any Bootstrap compatible theme css files that one can pass with the \texttt{\{shinythemes\}} \href{https://github.com/rstudio/shinythemes}{package}.

The interested reader will have a look at the following \href{https://github.com/rstudio/shiny/blob/master/R/bootstrap-layout.R}{script}.

\hypertarget{jquery-dom-manipulation}{%
\section{jQuery, DOM manipulation}\label{jquery-dom-manipulation}}

\href{https://jquery.com/}{jQuery} allows to perform DOM manipulation, that is interacting with HMTL elements, in a more user-friendly manner than with pure JavaScript. At that step, you might not be familiar with JavaScript nor jQuery. Don't worry chapter \ref{survival-kit-javascript} will expose the basics. Below is a comparison on how you would select a button HTML element with both technologies. I am sure you'll notice how jQuery\footnote{The next iteration of Bootstrap, namely \href{https://blog.getbootstrap.com/2020/06/16/bootstrap-5-alpha/}{Bootstrap 5} completely abandons jQuery for vanilla JavaScript. The main reason is to lighten the Bootstrap code.} is more intuitive than JavaScript.

Javascript:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ btn }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{'mybutton'}\NormalTok{)}\OperatorTok{;} \CommentTok{// select the button}
\VariableTok{btn}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{} \CommentTok{// action + consequences}
  \AttributeTok{alert}\NormalTok{(}\StringTok{'You clicked me!'}\NormalTok{)}\OperatorTok{;} \CommentTok{// action}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

jQuery:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\StringTok{'#mybutton'}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \AttributeTok{alert}\NormalTok{(}\StringTok{'You clicked me!'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Interestingly, the work in progress \texttt{\{jquerylib\}} will provide \href{https://github.com/rstudio/jquerylib}{support} for \texttt{\{shiny\}} in future releases.

\hypertarget{data-formating}{%
\section{Data formating}\label{data-formating}}

json2 is a library to handle the \href{https://www.json.org/json-en.html}{JSON} data format (JavaScript Object Notation). We will see in section \ref{shiny-websocket} of Chapter \ref{shiny-intro} that the R / JS communication involves data exchange and given that data structures are not the same in R and JS, there must be a way to ensure the translation. This is done through the \href{https://cran.r-project.org/web/packages/jsonlite/index.html}{jsonlite} package that allows to transform JSON objects in R objects with \texttt{jsonlite::fromJSON} and inversely with \texttt{jsonlite::toJSON}. Shiny automatically handles the process and it works well most of the time!

\hypertarget{custom-dependencies}{%
\section{Custom dependencies}\label{custom-dependencies}}

The last dependency contains custom JS and CSS code necessary for Shiny to work, that is:

\begin{itemize}
\tightlist
\item
  Fine tuning the layout
\item
  Registering input/output
\item
  Handling every single input/output action
\item
  Initializing and controlling the R/JS communication
\item
  Handling alerts/modals/notifications
\item
  \ldots{}
\end{itemize}

Part \ref{shiny-js-object}, \ref{shiny-input-system}, \ref{shiny-custom-handler} and \ref{custom-templates-interactivity} showcase the most important elements of those custom files.

TO DO: link to CSS part

The interested reader will have a look at the following \href{https://github.com/rstudio/shiny/blob/master/R/shinyui.R}{script}.

\hypertarget{exercise}{%
\section{Exercise}\label{exercise}}

In the following exercise, we consider a more complex app with a slider as well as a plot output.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run the app \texttt{runExample("01\_hello")}
\item
  Open the HTML inspector
\item
  Delete the bootstrap.min.css and ion.rangeSlider.css
\item
  Conclusions
\end{enumerate}

To sump up, all these libraries are necessary to make Shiny what it is!

In Chapter \ref{htmltools-dependencies}, we explore tools to manage HTML dependencies. In Chapter \ref{insert-tabs}, we study a special case to insert dependencies during the app runtime.

Let's move to the next part to discover the internal engine that creates HTML code from R!

\hypertarget{part-from-r-to-html-discover-and-master-htmltools}{%
\part*{From R to HTML: discover and master \{htmltools\}:}\label{part-from-r-to-html-discover-and-master-htmltools}}


While building a custom HTML template, you will need to know more about the wonderful \href{https://github.com/rstudio/htmltools}{htmltools}. It has the same spirit as devtools, that is, making your web developer life easier. What follows does not have the pretention to be an exhaustive guide about this package. Yet, it will provide you with the main tools to be more efficient.

\hypertarget{htmltools-overview}{%
\chapter{htmltools overview}\label{htmltools-overview}}

\texttt{\{htmltools\}} \citep{R-htmltools} is a R package designed to:

\begin{itemize}
\tightlist
\item
  Generate HTML tags from R
\item
  Handle web dependencies (see chapter \ref{htmltools-dependencies})
\end{itemize}

Historically, \texttt{\{htmltools\}} was extracted out of \texttt{\{shiny\}} \citep{R-shiny} to be able to extend it, that is developing custom HTML tags, importing extra dependencies from the web. That's why, both packages have many common functions! At the moment, \texttt{\{htmltools\}} does not have any user guide, although being a key package for all web things!

\hypertarget{writing-html-tags-from-r}{%
\section{Writing HTML Tags from R}\label{writing-html-tags-from-r}}

\texttt{\{htmltools\}} provides the necessary functions to write HTML tags that were introduced in Chapter \ref{web-intro-html}. In R, it is even more convenient than raw HTML since there is no opening/closing tag, a simple function call instead:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(htmltools)}
\NormalTok{tag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{tag}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(tag)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "<div>Hello World</div>"
\end{verbatim}

Inside the function call, all named elements will become \texttt{attributes}, whereas unnamed elements will become children. In some cases, tags may have empty attributes like \texttt{\textless{}input\ disabled\textgreater{}}. In that case,
the corresponding R code is \texttt{input(disabled\ =\ NA)}. Since tag functions produce shiny tags, that is HTML elements, we can capture the HTML output by converting it to a character with \texttt{as.character}, as shown above.

\hypertarget{notations}{%
\section{Notations}\label{notations}}

Whether to use \texttt{tags\$div} or \texttt{div} depends if the tag is exported by default.
For instance, you could use \texttt{htmltools::div} but not \texttt{htmltools::nav} since nav does not have a dedicated function (only for \texttt{p}, \texttt{h1}, \texttt{h2}, \texttt{h3}, \texttt{h4}, \texttt{h5}, \texttt{h6}, \texttt{a}, \texttt{br}, \texttt{div}, \texttt{span}, \texttt{pre}, \texttt{code}, \texttt{img}, \texttt{strong}, \texttt{em}, \texttt{hr}).
Rather prefer \texttt{htmltools::tags\$nav}. Alternatively, there exists a function (in shiny and htmltools)
called \texttt{withTags}. Wrapping your code in this function allows code like this \texttt{withTags(nav(),\ ...)} instead of \texttt{tags\$nav()}, thereby omitting the \texttt{tags\$} prefixes.
If you had to gather multiple tags together, choose \texttt{tagList()} over \texttt{list()}, although the HTML output is the same. The first has the \texttt{shiny.tag.list} class in addition to \texttt{list}. Package like \texttt{\{golem\}} \citep{R-golem} (see also \url{http://golemverse.org}) allows to test if an R object is a tag list. In this case, using a list would cause the test fail.

\hypertarget{adding-new-tags}{%
\section{Adding new tags}\label{adding-new-tags}}

The \texttt{tag} function allows to add extra HTML tags not already defined. You may use it as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{customTag <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"test"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}\DataTypeTok{class =} \StringTok{"test"}\NormalTok{, }\KeywordTok{p}\NormalTok{(}\StringTok{"Custom Tag"}\NormalTok{)))}
\KeywordTok{str}\NormalTok{(customTag)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 3
##  $ name    : chr "test"
##  $ attribs :List of 1
##   ..$ class: chr "test"
##  $ children:List of 1
##   ..$ :List of 3
##   .. ..$ name    : chr "p"
##   .. ..$ attribs : Named list()
##   .. ..$ children:List of 1
##   .. .. ..$ : chr "Custom Tag"
##   .. ..- attr(*, "class")= chr "shiny.tag"
##  - attr(*, "class")= chr "shiny.tag"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{customTag}
\end{Highlighting}
\end{Shaded}

Good practice is to check whether the created tag is in line with the HTML validation \href{https://validator.w3.org/}{rules}.

\hypertarget{alternative-way-to-write-tags}{%
\section{Alternative way to write tags}\label{alternative-way-to-write-tags}}

\texttt{\{htmltools\}} comes with the \texttt{HTML()} function that you can feed with raw HTML:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{HTML}\NormalTok{(}\StringTok{'<div>Blabla</div>'}\NormalTok{)}
\CommentTok{# will render exactly like}
\KeywordTok{div}\NormalTok{(}\StringTok{"Blabla"}\NormalTok{)}

\CommentTok{# but their classes are different}
\KeywordTok{class}\NormalTok{(}\KeywordTok{HTML}\NormalTok{(}\StringTok{'<div>Blabla</div>'}\NormalTok{))}
\KeywordTok{class}\NormalTok{(}\KeywordTok{div}\NormalTok{(}\StringTok{"Blabla"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

You will not be able to use tag related functions, as in the following parts.
Therefore, I strongly recommend using R and not mixing HTML in R. Interestingly, if
you want to convert raw HTML to R code, there is a Shiny App developed by Alan
Dipert from RStudio, namely \href{https://github.com/alandipert/html2r}{html2R}, shown Figure \ref{fig:htmltools-html2R}. There
are some issues, non standard attributes (like \texttt{data-toggle}) are not correctly processed but there are \href{https://github.com/alandipert/html2r/issues/2}{solutions}. This will save you precious time! A more recent approach is developed in section \ref{workflow-charpente} and has be internally used to develop some of the RinteRface \href{https://github.com/RinteRface}{templates}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/htmltools/htmltools-html2R} \caption{Illustration of the html2R App}\label{fig:htmltools-html2R}
\end{figure}

\hypertarget{playing-with-tags}{%
\section{Playing with tags}\label{playing-with-tags}}

\hypertarget{tags-structure}{%
\subsection{Tags structure}\label{tags-structure}}

A tag is defined by:

\begin{itemize}
\tightlist
\item
  A name such as span, div, h1 \ldots{} \texttt{tag\$name}
\item
  Some attributes, which can be accessed with \texttt{tag\$attribs}
\item
  Children, which you can be accessed with \texttt{tag\$children}
\item
  A class, namely \texttt{shiny.tag}
\end{itemize}

For instance:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# create the tag}
\NormalTok{myTag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
  \DataTypeTok{class =} \StringTok{"divclass"}\NormalTok{, }
  \DataTypeTok{id =} \StringTok{"first"}\NormalTok{,}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"Here comes your baby"}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"child"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"baby"}\NormalTok{, }\StringTok{"Crying"}\NormalTok{)}
\NormalTok{)}
\CommentTok{# access its name}
\NormalTok{myTag}\OperatorTok{$}\NormalTok{name}
\CommentTok{# access its attributes (id and class)}
\NormalTok{myTag}\OperatorTok{$}\NormalTok{attribs}
\CommentTok{# access children (returns a list of 2 elements)}
\NormalTok{myTag}\OperatorTok{$}\NormalTok{children}
\CommentTok{# access its class}
\KeywordTok{class}\NormalTok{(myTag)}
\end{Highlighting}
\end{Shaded}

How to modify the class of the second child?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{second_children <-}\StringTok{ }\NormalTok{myTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]]}
\NormalTok{second_children}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ "adult"}
\NormalTok{myTag}
\CommentTok{# This is not working ...}
\end{Highlighting}
\end{Shaded}

Why is this not working? By assigning \texttt{myTag\$children{[}{[}2{]}{]}} to second\_children, \texttt{second\_children\$attribs\$class\ \textless{}-\ "adult"} modifies the class of the copy and not the original object. Thus we do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]]}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ "adult"}
\NormalTok{myTag}
\end{Highlighting}
\end{Shaded}

\hypertarget{useful-functions-for-tags}{%
\subsection{Useful functions for tags}\label{useful-functions-for-tags}}

\texttt{\{htmltools\}} and \texttt{\{shiny\}} have powerful functions to seamlessly manipulate tags.

\hypertarget{add-attributes}{%
\subsubsection{Add attributes}\label{add-attributes}}

\begin{itemize}
\tightlist
\item
  \texttt{tagAppendAttributes}: this function allows to add a new attribute to the current tag.
\end{itemize}

For instance, assuming we created a div without any id attribute:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\StringTok{"Where is my brain"}\NormalTok{)}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagAppendAttributes}\NormalTok{(mydiv, }\DataTypeTok{id =} \StringTok{"here_it_is"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can pass as many attributes as you want, including non standard attributes such as \texttt{data-toggle} (see Bootstrap 3 \href{https://www.w3schools.com/bootstrap/bootstrap_ref_js_collapse.asp}{tabs} for instance):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagAppendAttributes}\NormalTok{(mydiv, }\KeywordTok{list}\NormalTok{(}\StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "tabs"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"myclass"}\NormalTok{))}
\CommentTok{# even though you could proceed as follows but this requires 2 steps}
\NormalTok{mydiv}\OperatorTok{$}\NormalTok{attribs[[}\StringTok{"data-toggle"}\NormalTok{]] <-}\StringTok{ "tabs"}
\NormalTok{mydiv}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ "myclass"}
\end{Highlighting}
\end{Shaded}

\hypertarget{check-if-tag-has-specific-attribute}{%
\subsubsection{Check if tag has specific attribute}\label{check-if-tag-has-specific-attribute}}

\begin{itemize}
\tightlist
\item
  \texttt{tagHasAttribute}: to check if a tag has a specific attribute
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# I want to know if div has a class}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"myclass"}\NormalTok{)}
\NormalTok{has_class <-}\StringTok{ }\KeywordTok{tagHasAttribute}\NormalTok{(mydiv, }\StringTok{"class"}\NormalTok{)}
\NormalTok{has_class}
\CommentTok{# if you are familiar with %>%}
\NormalTok{has_class <-}\StringTok{ }\NormalTok{mydiv }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagHasAttribute}\NormalTok{(}\StringTok{"class"}\NormalTok{)}
\NormalTok{has_class}
\end{Highlighting}
\end{Shaded}

In practice, this function is useful when testing tag elements as shown in chapter \ref{custom-templates-testing}.

\hypertarget{get-all-attributes}{%
\subsubsection{Get all attributes}\label{get-all-attributes}}

\begin{itemize}
\tightlist
\item
  \texttt{tagGetAttribute}: to get the value of the targeted attributes, if it exists, otherwise NULL.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"test"}\NormalTok{)}
\CommentTok{# returns the class}
\KeywordTok{tagGetAttribute}\NormalTok{(mydiv, }\StringTok{"class"}\NormalTok{)}
\CommentTok{# returns NULL}
\KeywordTok{tagGetAttribute}\NormalTok{(mydiv, }\StringTok{"id"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{set-childchildren}{%
\subsubsection{Set child/children}\label{set-childchildren}}

\begin{itemize}
\tightlist
\item
  \texttt{tagSetChildren} allows to create children for a given tag. For instance:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"parent"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"mother"}\NormalTok{, }\StringTok{"Not the mama!!!"}\NormalTok{)}
\CommentTok{# mydiv has 1 child "Not the mama!!!"}
\NormalTok{mydiv }
\NormalTok{children <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, span)}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagSetChildren}\NormalTok{(mydiv, children)}
\CommentTok{# mydiv has 3 children, the first one was removed}
\NormalTok{mydiv }
\end{Highlighting}
\end{Shaded}

Notice that \texttt{tagSetChildren} removes all existing children. Below we see another set of functions to add children while conserving existing ones.

\hypertarget{add-child-or-children}{%
\subsubsection{Add child or children}\label{add-child-or-children}}

\begin{itemize}
\tightlist
\item
  \texttt{tagAppendChild} and \texttt{tagAppendChildren}: add other tags to an existing tag.
  Whereas \texttt{tagAppendChild} only takes one tag, you can pass a list of tags to \texttt{tagAppendChildren}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"parent"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"mother"}\NormalTok{, }\StringTok{"Not the mama!!!"}\NormalTok{)}
\NormalTok{otherTag <-}\StringTok{ }\KeywordTok{span}\NormalTok{(}\StringTok{"I am your child"}\NormalTok{)}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagAppendChild}\NormalTok{(mydiv, otherTag)}
\end{Highlighting}
\end{Shaded}

\hypertarget{build-your-own-functions}{%
\subsubsection{Build your own functions}\label{build-your-own-functions}}

You might wonder why there is no \texttt{tagRemoveChild} or \texttt{tagRemoveAttributes}.
Let's look at the \texttt{tagAppendChild}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tagAppendChild <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (tag, child) \{}
\NormalTok{  tag}\OperatorTok{$}\NormalTok{children[[}\KeywordTok{length}\NormalTok{(tag}\OperatorTok{$}\NormalTok{children) }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\NormalTok{child}
\NormalTok{  tag}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Below we write the \texttt{tagRemoveChild}, where tag is the target and n is the position to remove in the list of children:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"parent"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"mother"}\NormalTok{, }\StringTok{"Not the mama!!!"}\NormalTok{, }\KeywordTok{span}\NormalTok{(}\StringTok{"Hey!"}\NormalTok{))}

\CommentTok{# we create the tagRemoveChild function}
\NormalTok{tagRemoveChild <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, n) \{}
  \CommentTok{# check if the list is empty}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(tag}\OperatorTok{$}\NormalTok{children) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{stop}\NormalTok{(}\KeywordTok{paste}\NormalTok{(tag}\OperatorTok{$}\NormalTok{name, }\StringTok{"does not have any children!"}\NormalTok{))}
\NormalTok{  \}}
\NormalTok{  tag}\OperatorTok{$}\NormalTok{children[n] <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{  tag}
\NormalTok{\}}
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{tagRemoveChild}\NormalTok{(mydiv, }\DecValTok{1}\NormalTok{)}
\NormalTok{mydiv}
\end{Highlighting}
\end{Shaded}

When defining the \texttt{tagRemoveChild}, we choose \texttt{{[}} instead of \texttt{{[}{[}} to allow to select multiple list elements:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"parent"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"mother"}\NormalTok{, }\StringTok{"Not the mama!!!"}\NormalTok{, }\StringTok{"Hey!"}\NormalTok{)}
\CommentTok{# fails}
\StringTok{`}\DataTypeTok{[[}\StringTok{`}\NormalTok{(mydiv}\OperatorTok{$}\NormalTok{children, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\CommentTok{# works}
\StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{(mydiv}\OperatorTok{$}\NormalTok{children, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Alternatively, we could also create a \texttt{tagRemoveChildren} function. Also notice that the function raises an error if the provided tag does not have children.

The \texttt{tagAppendChild} is not able to insert at a specific position. We could draft the \texttt{tagInsertChild} building on top of the base R \texttt{append} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tagInsertChild <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, child, position) \{}
\NormalTok{  tag}\OperatorTok{$}\NormalTok{children <-}\StringTok{ }\KeywordTok{append}\NormalTok{(tag}\OperatorTok{$}\NormalTok{children, }\KeywordTok{list}\NormalTok{(child), position }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\NormalTok{  tag}
\NormalTok{\}}

\KeywordTok{tagInsertChild}\NormalTok{(}\KeywordTok{p}\NormalTok{(}\KeywordTok{span}\NormalTok{(}\StringTok{"hello"}\NormalTok{)), }\KeywordTok{a}\NormalTok{(), }\DecValTok{1}\NormalTok{)}
\KeywordTok{tagInsertChild}\NormalTok{(}\KeywordTok{p}\NormalTok{(}\KeywordTok{span}\NormalTok{(}\StringTok{"hello"}\NormalTok{)), }\KeywordTok{a}\NormalTok{(), }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{other-functions}{%
\subsection{Other functions}\label{other-functions}}

The \href{https://github.com/ThinkR-open/golem/blob/dev/inst/utils/golem_utils_ui.R}{golem} package written by \href{https://thinkr.fr}{thinkr} contains neat functions to edit your tags.

Particularly, the \texttt{tagRemoveAttributes}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tagRemoveAttributes <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, ...) \{}
\NormalTok{  attrs <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(}\KeywordTok{list}\NormalTok{(...))}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(attrs)) \{}
\NormalTok{    tag}\OperatorTok{$}\NormalTok{attribs[[ attrs[i] ]] <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{  \}}
\NormalTok{  tag}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydiv <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"test"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"coucou"}\NormalTok{, }\StringTok{"Hello"}\NormalTok{)}
\KeywordTok{tagRemoveAttributes}\NormalTok{(mydiv, }\StringTok{"class"}\NormalTok{, }\StringTok{"id"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{conditionally-set-attributes}{%
\subsection{Conditionally set attributes}\label{conditionally-set-attributes}}

Sometimes, you only want to set attributes under specific conditions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_button <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{color =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{( }
    \DataTypeTok{style =} \KeywordTok{paste}\NormalTok{(}\StringTok{"color:"}\NormalTok{, color),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{my_button}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

This example will not fail but having \texttt{style="color:\ "} is not clean. We may use conditions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_button <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{color =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{( }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(color)) }\KeywordTok{paste}\NormalTok{(}\StringTok{"color:"}\NormalTok{, color),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{my_button}\NormalTok{(}\StringTok{"blue"}\NormalTok{)}
\KeywordTok{my_button}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

In this example, style won't be available if color is not specified.

\hypertarget{using}{%
\subsection{Using \%\textgreater\%}\label{using}}

While doing a lot of manipulation for a tag, if you don't need to create intermediate
objects, this is a good idea to use \texttt{\%\textgreater{}\%} from \href{https://magrittr.tidyverse.org}{magrittr}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"cl"}\NormalTok{, }\KeywordTok{h1}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{tagAppendAttributes}\NormalTok{(}\DataTypeTok{id =} \StringTok{"myid"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{tagAppendChild}\NormalTok{(}\KeywordTok{p}\NormalTok{(}\StringTok{"some extra text here!"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

The pipe syntax is overall easier to follow and read.

\hypertarget{programmatically-create-children-elements}{%
\subsection{Programmatically create children elements}\label{programmatically-create-children-elements}}

Assume you want to create a tag with three children inside:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{div}\NormalTok{(}
  \KeywordTok{span}\NormalTok{(}\DecValTok{1}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DecValTok{2}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DecValTok{3}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DecValTok{4}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The structure is correct but imagine if you had to create 1000 \texttt{span} or fancier tag. The previous approach is not consistent with DRY programming. \texttt{lapply} function will be useful here (or the purrr \texttt{map} family):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# base R}
\KeywordTok{div}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) }\KeywordTok{span}\NormalTok{(i)))}
\CommentTok{# purrr + %>%}
\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) }\KeywordTok{span}\NormalTok{(i)) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{div}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{practical-examples}{%
\section{Practical examples}\label{practical-examples}}

Below we give concrete example on how to customize tags in the real life. There exists a
nice RPG HTML template, that is \href{http://ronenness.github.io/RPGUI/}{rpgui}. It provides
the necessary elements to get started developing nice RPG looking user interfaces, as depicted by Figure \ref{fig:rpgui-select}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/htmltools/rpgui-select} \caption{rpgui select input}\label{fig:rpgui-select}
\end{figure}

In the following, we consider the select input, which does not have exactly the same
structure as the original shiny tag. However, it is convenient to reuse the shiny function
to limit our amount of work. We therefore start to write our custom input:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rpgSelect <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, label, choices, }\DataTypeTok{selected =} \OtherTok{NULL}\NormalTok{,}
                      \DataTypeTok{multiple =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{size =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  shiny}\OperatorTok{::}\KeywordTok{selectInput}\NormalTok{(}
\NormalTok{    inputId,}
\NormalTok{    label,}
\NormalTok{    choices,}
\NormalTok{    selected,}
\NormalTok{    multiple,}
    \DataTypeTok{selectize =} \OtherTok{FALSE}\NormalTok{,}
    \DataTypeTok{width =} \OtherTok{NULL}\NormalTok{,}
\NormalTok{    size}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

According to the rpgui documentation, a select tag is composed of the following HTML elements:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<select}\OtherTok{ class=}\StringTok{"rpgui-dropdown"}\KeywordTok{>}
    \KeywordTok{<option}\OtherTok{ value=}\StringTok{"option1"}\KeywordTok{>}\NormalTok{option1}\KeywordTok{</option>}
    \KeywordTok{<option}\OtherTok{ value=}\StringTok{"option2"}\KeywordTok{>}\NormalTok{option2}\KeywordTok{</option>}
\NormalTok{    ...}
\KeywordTok{</select>}
\end{Highlighting}
\end{Shaded}

Adding a label tag on top of the slider, this is what we would like to get:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div>}
  \KeywordTok{<label}\OtherTok{ id=}\StringTok{"variable-label"}\OtherTok{ for=}\StringTok{"variable"}\KeywordTok{>}\NormalTok{Variable:}\KeywordTok{</label>}
  \KeywordTok{<select}\OtherTok{ id=}\StringTok{"variable"}\OtherTok{ class=}\StringTok{"rpgui-dropdown"}\KeywordTok{><option}\OtherTok{ value=}\StringTok{"cyl"}\OtherTok{ selected}\KeywordTok{>}\NormalTok{Cylinders}\KeywordTok{</option>}
    \KeywordTok{<option}\OtherTok{ value=}\StringTok{"am"}\KeywordTok{>}\NormalTok{Transmission}\KeywordTok{</option>}
    \KeywordTok{<option}\OtherTok{ value=}\StringTok{"gear"}\KeywordTok{>}\NormalTok{Gears}\KeywordTok{</option>}
  \KeywordTok{</select>}
\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

We compare with our own \texttt{rpgSelect} function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rpgSelect}\NormalTok{(}
  \StringTok{"variable"}\NormalTok{, }
  \StringTok{"Variable:"}\NormalTok{,}
  \KeywordTok{c}\NormalTok{(}\StringTok{"Cylinders"}\NormalTok{ =}\StringTok{ "cyl"}\NormalTok{,}
    \StringTok{"Transmission"}\NormalTok{ =}\StringTok{ "am"}\NormalTok{,}
    \StringTok{"Gears"}\NormalTok{ =}\StringTok{ "gear"}\NormalTok{)}
\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{as.character}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "<div class=\"form-group shiny-input-container\">\n  <label class=\"control-label\" id=\"variable-label\" for=\"variable\">Variable:</label>\n  <div>\n    <select id=\"variable\" class=\"form-control\"><option value=\"cyl\" selected>Cylinders</option>\n<option value=\"am\">Transmission</option>\n<option value=\"gear\">Gears</option></select>\n  </div>\n</div>"
\end{verbatim}

As shown in the above output, this is not exactly matching:

\begin{itemize}
\tightlist
\item
  The outer div should not have any class.
\item
  The label should not have any class.
\item
  The input tag is wrapped inside a div container. It should not.
\item
  The input tag should have the \texttt{rpgui-dropdown} or \texttt{rpgui-list} class,
  depending on the size value.
\end{itemize}

To fix the first problem we target the outer tag (\texttt{selectTag}), that is the tag returned by our \texttt{rpgSelect} function. The second row cleans the label class. The third row removes the extra outer div and only keeps its children, corresponding to the input tag. The last instruction ensure to set the appropriate class, depending on the size value:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Modify tag}
\NormalTok{selectTag}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ }\OtherTok{NULL}
\CommentTok{# Clean extra label class}
\NormalTok{selectTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{1}\NormalTok{]]}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ }\OtherTok{NULL}
\CommentTok{# Remove extra outer div}
\NormalTok{selectTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]] <-}\StringTok{ }\NormalTok{selectTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]]}\OperatorTok{$}\NormalTok{children[[}\DecValTok{1}\NormalTok{]]}

\CommentTok{# Add good class for rppgui binding}
\NormalTok{selectTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]]}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(size)) \{}
  \StringTok{"rpgui-dropdown"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \StringTok{"rpgui-list"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The final version is shown below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rpgSelect <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, label, choices, }\DataTypeTok{selected =} \OtherTok{NULL}\NormalTok{,}
                      \DataTypeTok{multiple =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{size =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  selectTag <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\KeywordTok{selectInput}\NormalTok{(}
\NormalTok{    inputId,}
\NormalTok{    label,}
\NormalTok{    choices,}
\NormalTok{    selected,}
\NormalTok{    multiple,}
    \DataTypeTok{selectize =} \OtherTok{FALSE}\NormalTok{,}
    \DataTypeTok{width =} \OtherTok{NULL}\NormalTok{,}
\NormalTok{    size}
\NormalTok{  )}

  \CommentTok{# Modify tag}
\NormalTok{  selectTag}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ }\OtherTok{NULL}
  \CommentTok{# Clean extra label class}
\NormalTok{  selectTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{1}\NormalTok{]]}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ }\OtherTok{NULL}
  \CommentTok{# Remove extra outer div}
\NormalTok{  selectTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]] <-}\StringTok{ }\NormalTok{selectTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]]}\OperatorTok{$}\NormalTok{children[[}\DecValTok{1}\NormalTok{]]}

  \CommentTok{# Add good class for rppgui binding}
\NormalTok{  selectTag}\OperatorTok{$}\NormalTok{children[[}\DecValTok{2}\NormalTok{]]}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(size)) \{}
    \StringTok{"rpgui-dropdown"}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \StringTok{"rpgui-list"}
\NormalTok{  \}}

\NormalTok{  selectTag}
\NormalTok{\}}

\KeywordTok{rpgSelect}\NormalTok{(}
  \StringTok{"variable"}\NormalTok{, }
  \StringTok{"Variable:"}\NormalTok{,}
  \KeywordTok{c}\NormalTok{(}\StringTok{"Cylinders"}\NormalTok{ =}\StringTok{ "cyl"}\NormalTok{,}
    \StringTok{"Transmission"}\NormalTok{ =}\StringTok{ "am"}\NormalTok{,}
    \StringTok{"Gears"}\NormalTok{ =}\StringTok{ "gear"}\NormalTok{)}
\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{as.character}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "<div>\n  <label id=\"variable-label\" for=\"variable\">Variable:</label>\n  <select id=\"variable\" class=\"rpgui-dropdown\"><option value=\"cyl\" selected>Cylinders</option>\n<option value=\"am\">Transmission</option>\n<option value=\"gear\">Gears</option></select>\n</div>"
\end{verbatim}

\hypertarget{exercises}{%
\section{Exercises}\label{exercises}}

\hypertarget{exercise-1-tags-structure-5-minutes}{%
\subsection{Exercise 1: tags structure (5 minutes)}\label{exercise-1-tags-structure-5-minutes}}

Consider the following shiny tag:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myTag <-}\StringTok{ }\KeywordTok{a}\NormalTok{(}
  \DataTypeTok{class =} \StringTok{"btn btn-large"}\NormalTok{,}
  \DataTypeTok{type =} \StringTok{"button"}\NormalTok{,}
  \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"child1"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"super-span"}\NormalTok{, }\DecValTok{1}\NormalTok{),}
  \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"child2"}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{)}

\NormalTok{myTag}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Inspect its structure. Hint: you may use \texttt{str}.
\item
  Access its class using \texttt{tagGetAttribute} and another method of your choice.
\item
  Modify the first child class to \texttt{custom\ class}.
\end{enumerate}

\hypertarget{exercise-2-modifiying-tags-5-minutes}{%
\subsection{Exercise 2: modifiying tags (5 minutes)}\label{exercise-2-modifiying-tags-5-minutes}}

Let us consider the following tag:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temp <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

(You may chain functions with \texttt{\%\textgreater{}\%})

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Replace its unique child by \texttt{a(href\ =\ "http://www.google.com",\ "click\ me!")}. Hint: \texttt{tagSetChildren} is your friend.
\item
  Add 10 other \texttt{span}. Hint: tags may be programmatically generated with \texttt{lapply} or \texttt{purrr::map}.
\end{enumerate}

\hypertarget{htmltools-dependencies}{%
\chapter{Dependency utilities}\label{htmltools-dependencies}}

When creating a new template, you have to import custom HTML dependencies that are not available in shiny. Fortunately, this is not a problem with \texttt{\{htmltools\}} \citep{R-htmltools}!

\hypertarget{the-dirty-approach}{%
\section{The dirty approach}\label{the-dirty-approach}}

Let's consider the following example. Since Bootstrap is one of the most popular HTML/CSS/JS framework to develop websites and web apps, we want to include a bootstrap 4 card in a shiny app. This case study is taken from a RStudio Community \href{https://community.rstudio.com/t/create-a-div-using-htmltools-withtags/22439/2}{question}. The naive approach would be to include the HTML code directly in the app code. This approach is dirty since it is not easily re-usable by others.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\CommentTok{# we create the card function before}
\NormalTok{my_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{withTags}\NormalTok{(}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"card border-success mb-3"}\NormalTok{,}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-header bg-transparent border-success"}\NormalTok{),}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body text-success"}\NormalTok{,}
        \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, }\StringTok{"title"}\NormalTok{),}
        \KeywordTok{p}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-text"}\NormalTok{, ...)}
\NormalTok{      ),}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-footer bg-transparent border-success"}\NormalTok{, }\StringTok{"footer"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# we build our app}
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{fluidPage}\NormalTok{(}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{column}\NormalTok{(}
        \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
        \DataTypeTok{align =} \StringTok{"center"}\NormalTok{,}
        \KeywordTok{br}\NormalTok{(),}
        \KeywordTok{my_card}\NormalTok{(}\StringTok{"Card Content"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/htmltools/bs4-card-dirty} \caption{Attempt to display a Bootstrap 4 card without dependencies}\label{fig:bs4-card-dirty}
\end{figure}

As depicted by Figure \ref{fig:bs4-card-dirty}, nothing is displayed which was expected since \texttt{\{shiny\}} \citep{R-shiny} does not contain Bootstrap 4 dependencies and this card is a bootstrap 4 element. Don't panic! We load the necessary css to display this card (if required, we could include the javascript as well). We could use either \texttt{includeCSS()}, \texttt{tags\$head(tags\$link(rel\ =\ "stylesheet",\ type\ =\ "text/css",\ href\ =\ "custom.css"))}, as described in the shiny documentation \href{https://shiny.rstudio.com/articles/css.html}{here}. Web development best practice recommend to point to external file rather than including CSS in the head or directly on a tag (inline CSS). In the below example, we use a CDN (content delivery network) but that could be a local file located in the \texttt{www/} folder:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{fluidPage}\NormalTok{(}
    \CommentTok{# load the css code}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}\DataTypeTok{rel =} \StringTok{"stylesheet"}\NormalTok{, }\DataTypeTok{type =} \StringTok{"text/css"}\NormalTok{, }\DataTypeTok{href =} \StringTok{"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"}\NormalTok{)}
\NormalTok{    ),}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{column}\NormalTok{(}
        \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
        \DataTypeTok{align =} \StringTok{"center"}\NormalTok{,}
        \KeywordTok{br}\NormalTok{(),}
        \KeywordTok{my_card}\NormalTok{(}\StringTok{"Card Content"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The card may seem ugly but at least it is displayed as shown on Figure \ref{fig:bs4-card-deps}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/htmltools/bs4-card-deps} \caption{Bootstrap 4 card within a simple app}\label{fig:bs4-card-deps}
\end{figure}

\hypertarget{the-clean-approach}{%
\section{The clean approach}\label{the-clean-approach}}

The best approach consists in leveraging the \texttt{htmlDependency} and \texttt{attachDependencies} functions from \texttt{\{htmltools\}}.
The \texttt{htmlDependency} function takes the following main parameters:

\begin{itemize}
\tightlist
\item
  the dependency name
\item
  the version (useful to remember on which version it is built upon)
\item
  a path to the dependency (can be a CDN or a local folder)
\item
  script and stylesheet to respectively pass css and scripts
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# handle dependency}
\NormalTok{card_css <-}\StringTok{ "bootstrap.min.css"}
\NormalTok{bs4_card_dep <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{htmlDependency}\NormalTok{(}
    \DataTypeTok{name =} \StringTok{"bs4_card"}\NormalTok{,}
    \DataTypeTok{version =} \StringTok{"1.0"}\NormalTok{,}
    \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/"}\NormalTok{),}
    \DataTypeTok{stylesheet =}\NormalTok{ card_css}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If you are not pointing to a CDN and use local files, this is crucial to wrap the \texttt{htmlDependency} in a function since the path has to be determined at run time and not when the package builds. It means that if you are developing a package with dependencies, forgetting this step might prevent other users to get the dependency working on their own machine (the differences between Unix and Windows OS paths is clearly a good example).

We create the card tag and give it the bootstrap 4 dependency through the \texttt{attachDependencies} function. In recent version of \texttt{\{htmltools\}}, we may simply use \texttt{tagList(tag,\ deps)} instead. Importantly, \texttt{attachDependencies} has an \texttt{append} parameter FALSE by default. Ensure to set it to TRUE if you want to keep already attached dependencies!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# create the card}
\NormalTok{my_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  cardTag <-}\StringTok{ }\KeywordTok{withTags}\NormalTok{(}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"card border-success mb-3"}\NormalTok{,}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-header bg-transparent border-success"}\NormalTok{),}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body text-success"}\NormalTok{,}
        \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, }\StringTok{"title"}\NormalTok{),}
        \KeywordTok{p}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-text"}\NormalTok{, ...)}
\NormalTok{      ),}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-footer bg-transparent border-success"}\NormalTok{, }\StringTok{"footer"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
  
  \CommentTok{# attach dependencies (old way)}
  \CommentTok{# htmltools::attachDependencies(cardTag, bs4_card_dep())}
  
  \CommentTok{# simpler way}
  \KeywordTok{tagList}\NormalTok{(cardTag, }\KeywordTok{bs4_card_dep}\NormalTok{())}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We finally run our app:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# run shiny app }
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{title =} \StringTok{"Hello Shiny!"}\NormalTok{,}
  \KeywordTok{fluidRow}\NormalTok{(}
    \KeywordTok{column}\NormalTok{(}
      \DataTypeTok{width =} \DecValTok{6}\NormalTok{,}
      \DataTypeTok{align =} \StringTok{"center"}\NormalTok{,}
      \KeywordTok{br}\NormalTok{(),}
      \KeywordTok{my_card}\NormalTok{(}\StringTok{"Card Content"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\KeywordTok{shinyApp}\NormalTok{(ui, }\DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{ \})}
\end{Highlighting}
\end{Shaded}

With this approach, you can develop a package of custom dependencies that people
could use when they need to add custom elements in shiny.

\hypertarget{htmldeps-import}{%
\section{Importing HTML dependencies from other packages}\label{htmldeps-import}}

The \texttt{\{shinydashboard\}} \citep{R-shinydashboard} package helps to design dashboards with shiny. In the following, we would like to integrate the box component in a classic Shiny App (without the dashboard layout). However, if you try to include the box tag, you will notice that nothing is displayed since \texttt{\{shiny\}} does not have \texttt{\{shinydashboard\}} dependencies. \texttt{\{htmltools\}} contains a function, namely \texttt{findDependencies} that looks for all dependencies attached to a tag. Before going further, let's define the basic skeleton of a dashboard:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shinydashboard)}
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{dashboardPage}\NormalTok{(}
    \KeywordTok{dashboardHeader}\NormalTok{(),}
    \KeywordTok{dashboardSidebar}\NormalTok{(),}
    \KeywordTok{dashboardBody}\NormalTok{(),}
    \DataTypeTok{title =} \StringTok{"Dashboard example"}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{ \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

There are numerous details associated with shinydashboard that we will not go into. If you are interested in learning more, please \href{https://rstudio.github.io/shinydashboard/}{help yourself}. The key point here is the main wrapper function \texttt{dashboardPage}. The \texttt{fluidPage} is another wrapper function that most are already familiar with. We apply \texttt{findDependencies} on \texttt{dashboardPage}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(htmltools)}
\NormalTok{deps <-}\StringTok{ }\KeywordTok{findDependencies}\NormalTok{(}
  \KeywordTok{dashboardPage}\NormalTok{(}
    \DataTypeTok{header =} \KeywordTok{dashboardHeader}\NormalTok{(), }
    \DataTypeTok{sidebar =} \KeywordTok{dashboardSidebar}\NormalTok{(), }
    \DataTypeTok{body =} \KeywordTok{dashboardBody}\NormalTok{()}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{deps[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 10
##  $ name      : chr "font-awesome"
##  $ version   : chr "5.13.0"
##  $ src       :List of 1
##   ..$ file: chr "www/shared/fontawesome"
##  $ meta      : NULL
##  $ script    : NULL
##  $ stylesheet: chr [1:2] "css/all.min.css" "css/v4-shims.min.css"
##  $ head      : NULL
##  $ attachment: NULL
##  $ package   : chr "shiny"
##  $ all_files : logi TRUE
##  - attr(*, "class")= chr "html_dependency"
\end{verbatim}

For space reasons, we only printed the first dependency output but deps is a list containing four dependencies:

\begin{itemize}
\tightlist
\item
  \href{https://fontawesome.com}{Font Awesome} handles icons. Interestingly, this dependency is provided by \texttt{dashboardHeader}, especially the \texttt{shiny::icon("bars")} that collapses the left sidebar
\item
  \href{https://getbootstrap.com/docs/3.3/}{Bootstrap} is the main HTML/CSS/JS template. Importantly,
  please note the version 3.3.7, whereas the current is 4.5.2
\item
  \href{https://adminlte.io}{AdminLTE} is the dependency containing HTML/CSS/JS related to the admin template.
  It is closely linked to Bootstrap 3
\item
  shinydashboard, the CSS and javascript necessary for our dashboard to work properly. In practice,
  integrating custom HTML templates to shiny does not usually work out of the box for many reasons and some modifications are necessary. For instance, here is a list of \href{https://github.com/rstudio/shinydashboard/blob/master/srcjs/AdminLTE/README-shiny-mods.md}{changes} to optimize adminLTE for shiny. This has major consequences on the template maintenance such that upgrading to another AdminLTE version would require to modify all these elements by hand. You may understand why template maintainers are quite often reluctant to upgrade their dependencies as it might brake the whole package, quite easily.
\end{itemize}

Below, we attach the dependencies to the \texttt{box} with \texttt{tagList}, as shown above. Notice that our custom \texttt{box} does not contain all parameters as in the official \texttt{\{shinydashboard\}} version, which is actually ok at this time. For a better contrast with the body,
we add a custom color to the background, as depicted by Figure \ref{fig:shiny-import-box}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_box <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(title, status) \{}
  \KeywordTok{tagList}\NormalTok{(}\KeywordTok{box}\NormalTok{(}\DataTypeTok{title =}\NormalTok{ title, }\DataTypeTok{status =}\NormalTok{ status), deps)}
\NormalTok{\}}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}\StringTok{"body \{ background-color: gainsboro; \}"}\NormalTok{),}
  \KeywordTok{titlePanel}\NormalTok{(}\StringTok{"Shiny with a box"}\NormalTok{),}
  \KeywordTok{my_box}\NormalTok{(}\DataTypeTok{title =} \StringTok{"My box"}\NormalTok{, }\DataTypeTok{status =} \StringTok{"danger"}\NormalTok{),}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/htmltools/shiny-import-box} \caption{AdminLTE2 box inside classic shiny app}\label{fig:shiny-import-box}
\end{figure}

You now have limitless possibilities! Interestingly, this same approach is the basis of \href{https://github.com/dreamRs/shinyWidgets/blob/master/R/useBs4Dash.R}{shinyWidgets} for the \texttt{useBs4Dash} function and other related tools.

\hypertarget{suppress-dependencies}{%
\section{Suppress dependencies}\label{suppress-dependencies}}

In rare cases, you may need to remove an existing conflicting dependency. The \texttt{suppressDependencies} function allows users to perform this. For instance, \href{https://github.com/Appsilon/shiny.semantic}{shiny.semantic} built on top of
semantic ui is not compatible with Bootstrap, as illustrated by Figure \ref{fig:semantic-suppress-bootstrap}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/htmltools/semantic-suppress-bootstrap} \caption{Deletion of Bootstrap inside semanticPage}\label{fig:semantic-suppress-bootstrap}
\end{figure}

Below, we remove the AdminLTE2 dependency
from a \texttt{\{shinydashboard\}} page and nothing is displayed (as expected):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{dashboardPage}\NormalTok{(}
    \KeywordTok{dashboardHeader}\NormalTok{(),}
    \KeywordTok{dashboardSidebar}\NormalTok{(),}
    \KeywordTok{dashboardBody}\NormalTok{(}\KeywordTok{suppressDependencies}\NormalTok{(}\StringTok{"AdminLTE"}\NormalTok{)),}
    \DataTypeTok{title =} \StringTok{"Dashboard example"}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{ \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{resolve-dependencies}{%
\section{Resolve dependencies}\label{resolve-dependencies}}

Imagine a situation in which we would like to use the very last version of fontawesome icons, that is currently 5.15.1 according to \href{https://www.jsdelivr.com/package/npm/@fortawesome/fontawesome-free}{jsdelivr}. We recall that \texttt{\{shiny\}} already provides version 5.13.0 through the \texttt{icon} function. Including another version would probably cause conflicts and we would like to avoid that case. \texttt{\{htmltools\}} has a \texttt{resolveDependencies} tool that consists in removing any redundant element, taking the last version if dependencies names are identical.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_icon_dep <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"font-awesome"}\NormalTok{, }
  \DataTypeTok{version =} \StringTok{"5.15.1"}\NormalTok{, }
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/"}\NormalTok{),}
  \DataTypeTok{stylesheet =} \StringTok{"css/all.min.css"}
\NormalTok{)}

\NormalTok{icon_deps <-}\StringTok{ }\KeywordTok{list}\NormalTok{(new_icon_dep, }\KeywordTok{findDependencies}\NormalTok{(shiny}\OperatorTok{::}\KeywordTok{icon}\NormalTok{(}\StringTok{"th"}\NormalTok{))[[}\DecValTok{1}\NormalTok{]])}

\KeywordTok{resolveDependencies}\NormalTok{(icon_deps)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## List of 10
##  $ name      : chr "font-awesome"
##  $ version   : chr "5.15.1"
##  $ src       :List of 1
##   ..$ href: chr "https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/"
##  $ meta      : NULL
##  $ script    : NULL
##  $ stylesheet: chr "css/all.min.css"
##  $ head      : NULL
##  $ attachment: NULL
##  $ package   : NULL
##  $ all_files : logi TRUE
##  - attr(*, "class")= chr "html_dependency"
\end{verbatim}

Combining \texttt{findDependencies}, \texttt{suppressDependencies} and \texttt{resolveDependencies} gives you great power to successfully manage your dependencies!

\hypertarget{insert-custom-script-in-the-head}{%
\section{Insert Custom script in the head}\label{insert-custom-script-in-the-head}}

With \texttt{\{shinydashboardPlus\}}, users can fine tune their dashboard behavior with a simple option parameter passed to \texttt{dashboardPagePlus}. The \texttt{sidebarExpandOnHover} capability that consists in expanding the sidebar when hovering on it is part of those \href{https://adminlte.io/themes/AdminLTE/documentation/index.html\#adminlte-options}{options}, yet not exposed by \texttt{\{shinydashboard\}}. Under the hood, all those options are gathered in a (nested) list, then converted into JSON to eventually generate a JavaScript configuration file. Until now, we only saw two ways to include scripts or stylesheets. How do we include any arbitrary script (defined on the fly by the user when the app starts) in an dependency?

\texttt{htmlDependency} has a \texttt{head} parameter allowing to pass any lines of HTML to insert into the document head. We can easily imagine passing a string containing a script. Below, we first construct the options list. Then, we create the dependency: notice since \texttt{src} is mandatory, we have to give it a value but we will not use \texttt{script} nor \texttt{stylesheet} arguments.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{options <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{sidebarExpandOnHover =} \OtherTok{TRUE}\NormalTok{, }
  \DataTypeTok{boxWidgetSelectors =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{remove =} \StringTok{'[data-widget="remove"]'}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{config_script <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{htmlDependency}\NormalTok{(}
    \StringTok{"options"}\NormalTok{,}
    \KeywordTok{as.character}\NormalTok{(utils}\OperatorTok{::}\KeywordTok{packageVersion}\NormalTok{(}\StringTok{"shinydashboardPlus"}\NormalTok{)),}
    \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{file =} \KeywordTok{system.file}\NormalTok{(}\StringTok{"shinydashboardPlus-0.6.0"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"shinydashboardPlus"}\NormalTok{)),}
    \DataTypeTok{head =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(options)) \{}
      \KeywordTok{paste0}\NormalTok{(}
        \StringTok{"<script>var AdminLTEOptions = "}\NormalTok{, }
\NormalTok{        jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}
\NormalTok{          options, }
          \DataTypeTok{auto_unbox =} \OtherTok{TRUE}\NormalTok{,}
          \DataTypeTok{pretty =} \OtherTok{TRUE}
\NormalTok{        ),}
        \StringTok{";</script>"}
\NormalTok{      )}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# show the script}
\KeywordTok{print}\NormalTok{(}\KeywordTok{HTML}\NormalTok{(}\KeywordTok{config_script}\NormalTok{()}\OperatorTok{$}\NormalTok{head))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <script>var AdminLTEOptions = {
##   "sidebarExpandOnHover": true,
##   "boxWidgetSelectors": {
##     "remove": "[data-widget=\"remove\"]"
##   }
## };</script>
\end{verbatim}

I invite the reader to run the example below involving \texttt{\{shinydashboardPlus\}}, open the HTML inspector and look at the head.

\begin{Shaded}
\begin{Highlighting}[]
 \KeywordTok{shinyApp}\NormalTok{(}
   \DataTypeTok{ui =} \KeywordTok{dashboardPagePlus}\NormalTok{(}
     \DataTypeTok{collapse_sidebar =} \OtherTok{TRUE}\NormalTok{,}
     \DataTypeTok{options =}\NormalTok{ options,}
     \DataTypeTok{header =} \KeywordTok{dashboardHeaderPlus}\NormalTok{(}
      \DataTypeTok{enable_rightsidebar =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{rightSidebarIcon =} \StringTok{"gears"}
\NormalTok{     ),}
     \DataTypeTok{sidebar =} \KeywordTok{dashboardSidebar}\NormalTok{(),}
     \DataTypeTok{body =} \KeywordTok{dashboardBody}\NormalTok{(),}
     \DataTypeTok{rightsidebar =} \KeywordTok{rightSidebar}\NormalTok{(),}
     \DataTypeTok{title =} \StringTok{"DashboardPage"}
\NormalTok{   ),}
   \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{ \}}
\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

According the the AdminLTE \href{https://adminlte.io/themes/AdminLTE/documentation/index.html\#adminlte-options}{documentation}, global options must be passed before loading the app.min.js script. Creating this ``dummy'' dependency allowed us to isolate the script to insert it before the app.min.js script (contained in another \href{https://github.com/RinteRface/shinydashboardPlus/blob/master/R/deps.R\#L43}{dependency}), as shown on Figure \ref{fig:htmltools-head-deps}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/htmltools/htmltools-head-deps} \caption{Insert arbitrary script in the head}\label{fig:htmltools-head-deps}
\end{figure}

\hypertarget{part-beautify-with-css-and-sass}{%
\part*{Beautify with CSS and Sass}\label{part-beautify-with-css-and-sass}}


This part will introduce you to tools like \href{https://dreamrs.github.io/fresh/index.html}{\{fresh\}} and \href{https://rstudio.github.io/bootstraplib/index.html}{\{bslib\}}

\hypertarget{beautify-css}{%
\chapter{CSS for Shiny}\label{beautify-css}}

The first CSS version was released in 1996, that is 5 years later than HTML. Before CSS appeared, developers styled their pages with specific tags like \texttt{font}, which eventually made the HTML code hard to maintain. The current version of CSS is 3. While nowadays all web browsers support CSS, this was not the case at the very beginning!

\hypertarget{how-to-include-css}{%
\section{How to include CSS?}\label{how-to-include-css}}

There are 3 ways to include CSS in a web page:

\begin{itemize}
\tightlist
\item
  Point to an external file \texttt{\textless{}link\ rel="stylesheet"\ href="style.css"/\textgreater{}}
\item
  Insert the style in the \texttt{head}
\item
  Insert the style at the tag level, through the \texttt{style} attribute
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
\KeywordTok{<head>}
\KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"utf-8"} \KeywordTok{/>}
\KeywordTok{<link}\OtherTok{ rel=}\StringTok{"stylesheet"}\OtherTok{ href=}\StringTok{"style.css"} \KeywordTok{/>}
\KeywordTok{<title>}\NormalTok{CSS}\KeywordTok{</title>}
\KeywordTok{<style}\OtherTok{ type=}\StringTok{"text/css"}\KeywordTok{>}
\NormalTok{p \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}  
\NormalTok{\}}
\KeywordTok{</style>}
\KeywordTok{</head>}

\KeywordTok{<body>}
\KeywordTok{<p}\OtherTok{ style=}\StringTok{"color: red"}\KeywordTok{>}\NormalTok{Hello World}\KeywordTok{</p>}
\KeywordTok{<p>}\NormalTok{Some text}\KeywordTok{</p>}
\KeywordTok{<div>}\NormalTok{Plop}\KeywordTok{</div>}
\KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

I recommend to follow the first method as much as you can so that you modify the CSS in only one place!

At the end of the day, your CSS script will look like the below example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag1 \{}
\NormalTok{property1}\InformationTok{: value1}\NormalTok{;}
\NormalTok{property2}\InformationTok{: value2}\NormalTok{;}
\NormalTok{\}}

\NormalTok{tag2 \{}
\NormalTok{property1}\InformationTok{: value1}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

All of the above methods apply to shiny:

\begin{itemize}
\tightlist
\item
  External CSS file \texttt{tags\$link(rel\ =\ "stylesheet",\ type="text/css",\ href="www/style.css")}.
\item
  Internal CSS \texttt{tags\$head(tags\$style("p\ \{color:\ red;\}"))}.
\item
  Inline CSS \texttt{p(style\ =\ "color:red;",\ "Red\ text")}.
\end{itemize}

However, if you correctly followed the previous part about HTML dependencies, the best way in Shiny is to create a dependency, and attach it to a tag:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{css_dep <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{htmlDependency}\NormalTok{(}
    \DataTypeTok{name =} \StringTok{"css dep"}\NormalTok{,}
    \DataTypeTok{version =} \StringTok{"1.0"}\NormalTok{,}
    \DataTypeTok{src =}\NormalTok{ path_to_css,}
    \DataTypeTok{stylesheet =}\NormalTok{ filename}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{tagList}\NormalTok{(tag, css_dep)}
\end{Highlighting}
\end{Shaded}

Following this method, you make the file accessible on the server, thereby easing the debugging process. When should we apply the above method? Well, it does not make a lot of sense for tiny CSS modifications, where you could use one of the 3 other methods listed above.

\hypertarget{css-selectors}{%
\section{CSS selectors}\label{css-selectors}}

\hypertarget{basics}{%
\subsection{Basics}\label{basics}}

To apply CSS, we select a the tag , choose the property we want to change and give it a value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{selector \{}
\NormalTok{property: value}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For instance, to set the color blue to the \texttt{p} tag, we would do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, how would we apply the same property to multiple tags? We separate tags by a comma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p}\OperatorTok{,}\NormalTok{ div \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

See below an example with a Shiny app:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
    \StringTok{"p, div \{ }
\StringTok{      color: red;}
\StringTok{    \}"}
\NormalTok{  ),}
  \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{),}
  \KeywordTok{div}\NormalTok{(}\StringTok{"A block"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{select-by-class-id}{%
\subsection{Select by class, id}\label{select-by-class-id}}

The method shown above applies to all selected tags. This is not necessarily what we want as we probably would like to filter. We first add a \texttt{class} to the first \texttt{p} tag. Best practice is to give it a meaningful name.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<p}\OtherTok{ class=}\StringTok{"first-p"}\KeywordTok{></p>}
\end{Highlighting}
\end{Shaded}

On the CSS side, we prefix the class by a \texttt{.}, as shown below:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.first-p}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To style unique elements, we may use \texttt{id}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#element}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As another example, the result is shown in Figure \ref{fig:css-simple-select}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
    \StringTok{".first-p \{ }
\StringTok{      color: red;}
\StringTok{    \}}
\StringTok{    #element \{}
\StringTok{      color: red;}
\StringTok{    \}}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{p}\NormalTok{(}\DataTypeTok{class =} \StringTok{"first-p"}\NormalTok{, }\StringTok{"Hello World"}\NormalTok{),}
  \KeywordTok{p}\NormalTok{(}\StringTok{"Another text"}\NormalTok{),}
  \KeywordTok{div}\NormalTok{(}\DataTypeTok{id =} \StringTok{"element"}\NormalTok{, }\StringTok{"A block"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-simple-select} \caption{Select by class and id}\label{fig:css-simple-select}
\end{figure}

\hypertarget{apply-css-to-single-elements}{%
\subsection{Apply CSS to single elements}\label{apply-css-to-single-elements}}

Let's consider the following example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<p>}\NormalTok{Hello World! What's up?}\KeywordTok{</p>}
\end{Highlighting}
\end{Shaded}

How would you change the color of the \texttt{World} word? We could not select the whole \texttt{p} element.
There exist specific tags like \texttt{div} and \texttt{span} which you can apply. As stated in @chapter(web-intro-html), \texttt{span} may be used inside containers to surround words:

\begin{verbatim}
<p>Hello <span class="custom">World</span>! What's up?</p>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.custom}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{advanced-selectors}{%
\subsection{Advanced selectors}\label{advanced-selectors}}

Until now, we' seen how to select an element by the tag name, a class and an id. Yet, this is not enough. How would you select the below tag?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<a}\OtherTok{ data-toggle=}\StringTok{"dropdown"}\KeywordTok{>}\NormalTok{Tag}\KeywordTok{</a>}
\end{Highlighting}
\end{Shaded}

\hypertarget{select-nested-tags}{%
\subsubsection{Select nested tags}\label{select-nested-tags}}

We consider 2 HTML tags. We only want the first \texttt{a} element to have a red text.
We can't select by class \texttt{.nav-link} as it would also style the second element!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<li}\OtherTok{ class=}\StringTok{"nav-item"}\KeywordTok{>}
\KeywordTok{<a}\OtherTok{ class=}\StringTok{"nav-link"}\OtherTok{ href=}\StringTok{"#"}\KeywordTok{>}\NormalTok{Link}\KeywordTok{</a>}
\KeywordTok{</li>}

\KeywordTok{<a}\OtherTok{ class=}\StringTok{"nav-link"}\OtherTok{ href=}\StringTok{"#"}\KeywordTok{>}\NormalTok{Link}\KeywordTok{</a>}
\end{Highlighting}
\end{Shaded}

The idea is to select the first tag, that is \texttt{li}, then select it's child \texttt{a}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{li a \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The Shiny \texttt{navbarPage} template is composed of navigation items \texttt{li} and \texttt{a}, which we may easily modify:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{navbarPage}\NormalTok{(}
  \StringTok{"App Title"}\NormalTok{,}
  \KeywordTok{tabPanel}\NormalTok{(}
    \StringTok{"Plot"}\NormalTok{,}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
      \StringTok{"li a \{}
\StringTok{        font-size: 20px;}
\StringTok{        font-weight: bold;}
\StringTok{      \}}
\StringTok{    "}
\NormalTok{    ),}
    \KeywordTok{tabsetPanel}\NormalTok{(}
      \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Plot"}\NormalTok{),}
      \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Summary"}\NormalTok{),}
      \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Table"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Summary"}\NormalTok{),}
  \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Table"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-combined-selectors-1} \caption{Style all nav link elements}\label{fig:css-combined-selectors-1}
\end{figure}

You'll notice that \texttt{tabsetPanel} tabs are also modified, which is not exactly what we wanted, as shown in Figure \ref{fig:css-combined-selectors-1}. The main difference between \texttt{navbarPage} and \texttt{tabsetPanel} is the class held by the the menu wrapper \texttt{ul}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\KeywordTok{navbarPage}\NormalTok{(}\KeywordTok{tabPanel}\NormalTok{(}\StringTok{"test"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "<nav class=\"navbar navbar-default navbar-static-top\" role=\"navigation\">\n  <div class=\"container-fluid\">\n    <div class=\"navbar-header\">\n      <span class=\"navbar-brand\">\n        <div class=\"tab-pane\" title=\"test\" data-value=\"test\"></div>\n      </span>\n    </div>\n    <ul class=\"nav navbar-nav\" data-tabsetid=\"7981\"></ul>\n  </div>\n</nav>\n<div class=\"container-fluid\">\n  <div class=\"tab-content\" data-tabsetid=\"7981\"></div>\n</div>"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\KeywordTok{tabsetPanel}\NormalTok{(}\KeywordTok{tabPanel}\NormalTok{(}\StringTok{"test"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "<div class=\"tabbable\">\n  <ul class=\"nav nav-tabs\" data-tabsetid=\"4903\">\n    <li class=\"nav-item\">\n      <a href=\"#\" data-toggle=\"tab\" data-value=\"test\" class=\"nav-link active\" data-target=\"#tab-4903-1\">test</a>\n    </li>\n  </ul>\n  <div class=\"tab-content\" data-tabsetid=\"4903\">\n    <div class=\"tab-pane active\" data-value=\"test\" id=\"tab-4903-1\"></div>\n  </div>\n</div>"
\end{verbatim}

which is \texttt{nav\ navbar-nav} for \texttt{navbarPage} and \texttt{nav\ nav-tabs} for \texttt{tabsetPanel}.
To isolate \texttt{navbarPage} tabs, we have to improve our previous selector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.navbar-nav}\NormalTok{ li a \{}
\KeywordTok{font-size}\NormalTok{: }\DecValTok{20}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{font-weight}\NormalTok{: }\DecValTok{bold}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Doing so, we'll only look at the link elements inside the container having the \texttt{navbar-nav} class.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{navbarPage}\NormalTok{(}
  \StringTok{"App Title"}\NormalTok{,}
  \KeywordTok{tabPanel}\NormalTok{(}
    \StringTok{"Plot"}\NormalTok{,}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
      \StringTok{".navbar-nav li a \{}
\StringTok{        font-size: 20px;}
\StringTok{        font-weight: bold;}
\StringTok{      \}}
\StringTok{    "}
\NormalTok{    ),}
    \KeywordTok{tabsetPanel}\NormalTok{(}
      \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Plot"}\NormalTok{),}
      \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Summary"}\NormalTok{),}
      \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Table"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Summary"}\NormalTok{),}
  \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Table"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The final result is depicted in Figure \ref{fig:css-combined-selectors-2}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-combined-selectors-2} \caption{Style specific navbar nav link elements}\label{fig:css-combined-selectors-2}
\end{figure}

\hypertarget{select-by-attributes}{%
\subsubsection{Select by attributes}\label{select-by-attributes}}

To select by attribute, we use \texttt{tag{[}attribute{]}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<a}\OtherTok{ data-toggle=}\StringTok{"dropdown"}\KeywordTok{>}\NormalTok{Tag}\KeywordTok{</a>}
\KeywordTok{<a}\OtherTok{ data-toggle=}\StringTok{"my dropdown"}\KeywordTok{>}\NormalTok{Tag}\KeywordTok{</a>}
\KeywordTok{<a}\OtherTok{ data-toggle=}\StringTok{"whatever"}\KeywordTok{>}\NormalTok{Tag}\KeywordTok{</a>}
\end{Highlighting}
\end{Shaded}

The below CSS code, will select all \texttt{a} tags:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\ExtensionTok{[data-toggle]}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

while the following code, will only select the first \texttt{a} tag:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\ExtensionTok{[data-toggle}\OperatorTok{=}\StringTok{"dropdown"}\ExtensionTok{]}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The reason is that we exactly match the \texttt{dropdown} value!

We could be less specific:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\ExtensionTok{[data-toggle}\OperatorTok{*=}\StringTok{"dropdown"}\ExtensionTok{]}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{*} checks whether the word \texttt{dropdown} is there but not the position. You may use \texttt{\^{}} and \texttt{\$} like you do with regular expressions to check if the value starts or ends by the specified word, respectively.

\hypertarget{other-selectors}{%
\subsubsection{Other selectors}\label{other-selectors}}

\hypertarget{direct-descendants}{%
\subsubsection{Direct descendants}\label{direct-descendants}}

Let's consider a \texttt{navbarPage} with nested navigation. This is accomplished with the \texttt{navbarMenu} function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{navbarPage}\NormalTok{(}\StringTok{"App Title"}\NormalTok{,}
           \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Plot"}\NormalTok{),}
           \KeywordTok{navbarMenu}\NormalTok{(}\StringTok{"More"}\NormalTok{,}
                      \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Summary"}\NormalTok{),}
                      \StringTok{"----"}\NormalTok{,}
                      \StringTok{"Section header"}\NormalTok{,}
                      \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Table"}\NormalTok{)}
\NormalTok{           )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The resulting HTML code is as follow:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<ul}\OtherTok{ class=}\StringTok{"nav navbar-nav"}\OtherTok{ data-tabsetid=}\StringTok{"5879"}\KeywordTok{>}
\KeywordTok{<li}\OtherTok{ class=}\StringTok{"active"}\KeywordTok{>}
\KeywordTok{<a}\OtherTok{ href=}\StringTok{"#tab-5879-1"}\OtherTok{ data-toggle=}\StringTok{"tab"}\OtherTok{ data-value=}\StringTok{"Plot"}\KeywordTok{>}\NormalTok{Plot}\KeywordTok{</a>}
\KeywordTok{</li>}
\KeywordTok{<li}\OtherTok{ class=}\StringTok{"dropdown"}\KeywordTok{>}
\KeywordTok{<a}\OtherTok{ href=}\StringTok{"#"}\OtherTok{ class=}\StringTok{"dropdown-toggle"}\OtherTok{ data-toggle=}\StringTok{"dropdown"}\OtherTok{ data-value=}\StringTok{"More"}\KeywordTok{>}
\NormalTok{More}
\KeywordTok{<b}\OtherTok{ class=}\StringTok{"caret"}\KeywordTok{></b>}
\KeywordTok{</a>}
\KeywordTok{<ul}\OtherTok{ class=}\StringTok{"dropdown-menu"}\OtherTok{ data-tabsetid=}\StringTok{"7141"}\KeywordTok{>}
\KeywordTok{<li>}
\KeywordTok{<a}\OtherTok{ href=}\StringTok{"#tab-7141-1"}\OtherTok{ data-toggle=}\StringTok{"tab"}\OtherTok{ data-value=}\StringTok{"Summary"}\KeywordTok{>}\NormalTok{Summary}\KeywordTok{</a>}
\KeywordTok{</li>}
\KeywordTok{<li}\OtherTok{ class=}\StringTok{"divider"}\KeywordTok{></li>}
\KeywordTok{<li}\OtherTok{ class=}\StringTok{"dropdown-header"}\KeywordTok{>}\NormalTok{Section header}\KeywordTok{</li>}
\KeywordTok{<li>}
\KeywordTok{<a}\OtherTok{ href=}\StringTok{"#tab-7141-4"}\OtherTok{ data-toggle=}\StringTok{"tab"}\OtherTok{ data-value=}\StringTok{"Table"}\KeywordTok{>}\NormalTok{Table}\KeywordTok{</a>}
\KeywordTok{</li>}
\KeywordTok{</ul>}
\KeywordTok{</li>}
\KeywordTok{</ul>}
\end{Highlighting}
\end{Shaded}

We see that there are two \texttt{ul} menus with multiple \texttt{li} and \texttt{a} inside. Applying our previous CSS selector as depicted in Figure \ref{fig:css-direct-child-1} selects all links.

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-direct-child-1} \caption{Style all navbar nav link elements}\label{fig:css-direct-child-1}
\end{figure}

What if we only want to select the direct \texttt{a} children of the outer menu (meaning we exclude the inner menu links)? Using the \texttt{\textgreater{}} we can select direct children and not all descendant that could contain grand-children.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.navbar-nav} \OperatorTok{>}\NormalTok{ li }\OperatorTok{>}\NormalTok{ a \{}
\KeywordTok{font-size}\NormalTok{: }\DecValTok{20}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{font-weight}\NormalTok{: }\DecValTok{bold}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Result is displayed in Figure \ref{fig:css-direct-child-2}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{navbarPage}\NormalTok{(}
  \StringTok{"App Title"}\NormalTok{,}
  \KeywordTok{tabPanel}\NormalTok{(}
    \StringTok{"Plot"}\NormalTok{,}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
      \KeywordTok{HTML}\NormalTok{(}
        \StringTok{".navbar-nav > li > a \{}
\StringTok{          font-size: 20px;}
\StringTok{          font-weight: bold;}
\StringTok{        \}}
\StringTok{        "}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{navbarMenu}\NormalTok{(}\StringTok{"More"}\NormalTok{,}
             \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Summary"}\NormalTok{),}
             \StringTok{"----"}\NormalTok{,}
             \StringTok{"Section header"}\NormalTok{,}
             \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Table"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-direct-child-2} \caption{Style only direct children navbar nav link elements}\label{fig:css-direct-child-2}
\end{figure}

Well, what if we want to be even more specific and get only the very first nav link element? We'll have to introduce pseudo classes.

\hypertarget{pseudo-classes}{%
\paragraph{Pseudo-classes}\label{pseudo-classes}}

A pseudo class starts with the \texttt{:} symbol. For instance, \texttt{a:active} styles active links, \texttt{button:disabled} applies for disabled buttons, \ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\InformationTok{:active}\NormalTok{ \{}

\NormalTok{\}}

\NormalTok{button}\InformationTok{:disabled}\NormalTok{ \{}

\NormalTok{\}}

\NormalTok{checkbox}\InformationTok{:checked}\NormalTok{ \{}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There exists many pseudo class types, particularly the structural ones. Those are useful to select specific children like \texttt{element:first-child}. Going back to the \texttt{navbarPage} example, we could refine our CSS selector adding \texttt{:first-child} to the \texttt{li} element as we want to only select the first item:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.navbar-nav} \OperatorTok{>}\NormalTok{ li}\InformationTok{:first-child} \OperatorTok{>}\NormalTok{ a \{}
\KeywordTok{font-size}\NormalTok{: }\DecValTok{20}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{font-weight}\NormalTok{: }\DecValTok{bold}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As expected, only the first link is styled, as demonstrated in Figure \ref{fig:css-direct-child-3}!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{navbarPage}\NormalTok{(}
  \StringTok{"App Title"}\NormalTok{,}
  \KeywordTok{tabPanel}\NormalTok{(}
    \StringTok{"Plot"}\NormalTok{,}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
      \KeywordTok{HTML}\NormalTok{(}
        \StringTok{".navbar-nav > li:first-child > a \{}
\StringTok{          font-size: 20px;}
\StringTok{          font-weight: bold;}
\StringTok{        \}}
\StringTok{        "}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{navbarMenu}\NormalTok{(}\StringTok{"More"}\NormalTok{,}
             \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Summary"}\NormalTok{),}
             \StringTok{"----"}\NormalTok{,}
             \StringTok{"Section header"}\NormalTok{,}
             \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Table"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-direct-child-3} \caption{Style only the first navbar nav link element}\label{fig:css-direct-child-3}
\end{figure}

\hypertarget{pseudo-elements}{%
\paragraph{Pseudo-elements}\label{pseudo-elements}}

Pseudo elements are preceded by \texttt{::}. One of the most famous ones are \texttt{::before} and \texttt{::after} that respectively apply before and after the selected element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\InformationTok{::before}\NormalTok{ \{}

\NormalTok{\}}

\NormalTok{a}\InformationTok{::after}\NormalTok{ \{}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For instance \texttt{.navbar-nav\ \textgreater{}\ li:first-child\ \textgreater{}\ a::before} will insert an element before the very first navbar link.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{navbarPage}\NormalTok{(}
  \StringTok{"App Title"}\NormalTok{,}
  \KeywordTok{tabPanel}\NormalTok{(}
    \StringTok{"Plot"}\NormalTok{,}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
      \KeywordTok{HTML}\NormalTok{(}
        \StringTok{".navbar-nav > li:first-child > a \{}
\StringTok{                  font-size: 20px;}
\StringTok{                  font-weight: bold;}
\StringTok{                \} }
\StringTok{                .navbar-nav > li:first-child > a::before \{}
\StringTok{                  content: ''}
\StringTok{                \}}
\StringTok{                "}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{navbarMenu}\NormalTok{(}
    \StringTok{"More"}\NormalTok{,}
    \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Summary"}\NormalTok{),}
    \StringTok{"----"}\NormalTok{,}
    \StringTok{"Section header"}\NormalTok{,}
    \KeywordTok{tabPanel}\NormalTok{(}\StringTok{"Table"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-pseudoelements-before} \caption{Add before pseudo-element}\label{fig:css-pseudoelements-before}
\end{figure}

\hypertarget{modify-css-with-the-html-inspector}{%
\section{Modify CSS with the HTML inspector}\label{modify-css-with-the-html-inspector}}

\hypertarget{add-inline-properties}{%
\subsection{Add inline properties}\label{add-inline-properties}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run the following app:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}\StringTok{"p \{ color: red;\}"}\NormalTok{),}
  \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Right click the \texttt{p} element and open the inspector. In the \texttt{Styles} tab, notice the \texttt{element.style} section. This is to define inline new CSS rules for the selected item.
\item
  Let's add 2 rules by clicking inside the \texttt{element.style} container:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{border-style:\ dashed}. Indicates we want a box with dashed border
\item
  \texttt{border-color:\ ...}. To set a border color
\end{itemize}

After typing enter, the inline CSS is automatically added in the tag element.

You probably noticed the auto suggestion feature while typing a property, as shown in Figure \ref{fig:html-dom-css}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/dom-css} \caption{Edit CSS with Chrome DevTools}\label{fig:html-dom-css}
\end{figure}

\hypertarget{view-local-changes}{%
\subsection{View local changes}\label{view-local-changes}}

Whenever playing around with a web page style or a shiny app, it may be good to have an overview of all changes when you are satisfied about the new design.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run the previous shiny app example and open the inspector
\item
  In the Styles tab, add some new CSS properties to the first p element set of rules
\item
  Once done press enter and click on the file name located at the top-right corner of the property box
\item
  This opens the Sources tab. In the left sidebar, right click on the file name (index) and select \texttt{Local\ Modifications}
\item
  This opens a \texttt{Git} like diff panel called \texttt{Changes} where you can review any change and see the previous values. If you refresh the page, you will loose every local change, unless the persistent authoring feature is active
\end{enumerate}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/dom-css-changes} \caption{Review all CSS changes}\label{fig:html-dom-css-changes}
\end{figure}

To get a deeper understanding of the different CSS options please refer to the Google \href{https://developers.google.com/web/tools/chrome-devtools/css}{documentation}.

\hypertarget{css-in-action}{%
\section{CSS in action}\label{css-in-action}}

Below we review the most commonly used CSS properties such as text styling, shadows, color and background color, \ldots{}

\hypertarget{text-styling}{%
\subsection{Text Styling}\label{text-styling}}

\hypertarget{polices}{%
\subsubsection{Polices}\label{polices}}

This controls the text appearance. The police may be changed like below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag \{}
  \KeywordTok{font-family}\NormalTok{: mypolice1}\OperatorTok{,}\NormalTok{ mypolice2}\OperatorTok{,} \DecValTok{...}\OperatorTok{,} \DecValTok{serif}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In practice, we enter multiple police values, in case the end user does not have the same
police. The last values are composed of generic polices like \texttt{serif} and \texttt{monospace}.
For instance, Bootstrap 3 that powers Shiny utilizes the default \texttt{sans-serif} police. A neat tool to inspect the current text polices is the HTML inspector CSS Overview tab, as shown Figure \ref{fig:css-overview-font-family}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-overview-font-family} \caption{Overview of font properties}\label{fig:css-overview-font-family}
\end{figure}

Custom polices may be downloaded with \texttt{@font-face} but there are few prerequisites to make it work properly:

\begin{itemize}
\tightlist
\item
  The files format must be correctly handled by the end user web browsers. There are currently \texttt{.ttf} (work on almost all web browser), \texttt{.woff} (work on almost all web browser), \texttt{.svg} (iPhone and iPad), \texttt{.eot} (IE only) and \texttt{.otf} (don't work on IE).
\item
  Those files have to be downloaded which may take time.
\item
  Be careful about copyright! Most polices are not open source.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{@font-face}\NormalTok{ \{}
  \KeywordTok{font-family}\NormalTok{: }\StringTok{'customPolice'}\OperatorTok{;}
  \KeywordTok{src}\NormalTok{: }\FunctionTok{url(}\StringTok{'customPolice.ttf'}\FunctionTok{)}\OperatorTok{,}
         \FunctionTok{url(}\StringTok{'customPolice.woff'}\FunctionTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Importantly, the police files must be accessible to the CSS file where they are called from. As another example, the below code means that the \texttt{fonts} folder is located one level above the CSS file:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{@font-face}\NormalTok{ \{}
  \KeywordTok{font-family}\NormalTok{: }\StringTok{'Framework7 Icons'}\OperatorTok{;}
  \KeywordTok{font-style}\NormalTok{: }\DecValTok{normal}\OperatorTok{;}
  \KeywordTok{font-weight}\NormalTok{: }\DecValTok{400}\OperatorTok{;}
  \KeywordTok{src}\NormalTok{: }\FunctionTok{url(}\StringTok{"../fonts/Framework7Icons-Regular.eot"}\FunctionTok{)}\OperatorTok{;}
  \KeywordTok{src}\NormalTok{: }\FunctionTok{url(}\StringTok{"../fonts/Framework7Icons-Regular.woff2"}\FunctionTok{)} \FunctionTok{format(}\StringTok{"woff2"}\FunctionTok{)}\OperatorTok{,}
       \FunctionTok{url(}\StringTok{"../fonts/Framework7Icons-Regular.woff"}\FunctionTok{)} \FunctionTok{format(}\StringTok{"woff"}\FunctionTok{)}\OperatorTok{,}
       \FunctionTok{url(}\StringTok{"../fonts/Framework7Icons-Regular.ttf"}\FunctionTok{)} \FunctionTok{format(}\StringTok{"truetype"}\FunctionTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{size}{%
\subsubsection{Size}\label{size}}

To change the text size, we use the \texttt{font-size} property. From there, you have 2 choices:

\begin{itemize}
\tightlist
\item
  relative size (first choice) like \texttt{small}, \texttt{medium}, \ldots{}
  You may also find notations like \texttt{1em} (default size), \texttt{1.8em} being bigger and \texttt{0.5em} being smaller; as well as percentages.
\item
  absolute size: 16px, 20px, \ldots{}
\end{itemize}

In the following example, the second \texttt{h1} tag is smaller than the default one, so is \texttt{p}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
    \StringTok{".smaller--h1 \{}
\StringTok{      font-size: 0.75em;}
\StringTok{    \}}
\StringTok{    .smaller--p \{}
\StringTok{      font-size: 80%;}
\StringTok{    \}}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"Default <h1>"}\NormalTok{),}
  \KeywordTok{h1}\NormalTok{(}\DataTypeTok{class =} \StringTok{"smaller--h1"}\NormalTok{, }\StringTok{"Smaller <h1>"}\NormalTok{),}
  \KeywordTok{p}\NormalTok{(}\StringTok{"Normal <p>"}\NormalTok{),}
  \KeywordTok{p}\NormalTok{(}\DataTypeTok{class =} \StringTok{"smaller--p"}\NormalTok{, }\StringTok{"Smaller <p>"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{alignement}{%
\subsubsection{Alignement}\label{alignement}}

This is a job for \texttt{text-align} which accepts 4 values (left, center, right and justify). Importantly, this does not work for inline tags like \texttt{span}!

\hypertarget{other-styling-properties}{%
\subsubsection{Other styling properties}\label{other-styling-properties}}

You can also put any text in bold, italic using \texttt{font-style:\ italic} and \texttt{font-weight:\ bold}, respectively.

\hypertarget{colors}{%
\subsection{Colors}\label{colors}}

We have already mentioned this property before in the previous examples. In CSS, there are 4 ways to apply colors to a text or to the background:

\begin{itemize}
\tightlist
\item
  Using the hexadecimal notation (HEX). For instance \texttt{\#FFFFFF} corresponds to the white color. Given a color code, unless you already know it, the result is quite hard to predict. Could you guess what is the result of \texttt{\#4b0082}?
\item
  Using the \texttt{rgb} code. If you ever followed art courses, this is the classic system uses in painting, by mixing colors. \texttt{rgb} stands for red, green and blue. Each scale goes from 0 to 255 (256 choices), which gives a weight to each color! Why 255? Since 256\emph{256}256 gives about 16 millions color, the maximum number of colors that actual screen can display.
\item
  Using the \texttt{hsl} convention. \texttt{hsl} stands for hue, saturation and lightness. Saturation and lightness are expressed in percentage from 0 to 100. The hue goes from red (0) to 360 (a sort of red) each time incrementing by 15. The yellow color is 60.
\item
  Using the color name like \texttt{ghostwhite}, \texttt{maroon}, \texttt{red}\ldots{}
\end{itemize}

While \texttt{rgb} and \texttt{hsl} give an unlimited number of possibilities, HTML color names are not infinite.

There are many tools allowing to get each of those codes like, notably color pickers:

\begin{itemize}
\tightlist
\item
  \url{https://html-color.codes/}
\item
  \url{https://www.w3schools.com/colors/colors_picker.asp}
\end{itemize}

\hypertarget{text-color}{%
\subsubsection{Text color}\label{text-color}}

Given the methods listed above, we use the \texttt{color} property to change any text color. For obvious colors like \texttt{red}, this is not necessary to use the \texttt{rgb} convention.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{background-color}{%
\subsubsection{Background color}\label{background-color}}

\texttt{backgound-color} is the property necessary to apply a given color to the background. To change to page background color, we target the \texttt{body} tag, but you could also target any tag like \texttt{p}.

\hypertarget{borders-and-shadows}{%
\subsection{Borders and shadows}\label{borders-and-shadows}}

These effects may be applied to text and block elements. The easiest way to set up a border is to leverage the \texttt{border} propriety which takes 3 parameters:

\begin{itemize}
\tightlist
\item
  The border \texttt{width} in px.
\item
  The border \texttt{color} with any valid CSS color like \texttt{rgb()}, \texttt{red}, \ldots{}
\item
  The border \texttt{type}, which corresponds to the border style (\texttt{none}, \texttt{solid},
  \texttt{dotted}, \texttt{dashed}, \texttt{double}, \texttt{groove}, \texttt{ridge}, \texttt{inset} and \texttt{outset}). In practice, we mostly use \texttt{solid}.
\end{itemize}

There exist other properties such as \texttt{border-radius} which controls the shape of the corners from top left to bottom left. The higher the value the most rounded is the corner.

If for any reason, you want to fine tune the border position, there are four properties: \texttt{border-top}, \texttt{border-bottom}, \texttt{border-left} and \texttt{border-right}.

Finally, shadows are controlled by two properties:

\begin{itemize}
\tightlist
\item
  \texttt{text-shadow} which applies a shadow to a text element (not the most used).
\item
  \texttt{box-shadow} for styling blocks.
\end{itemize}

For instance:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{block \{}
  \KeywordTok{box-shadow}\NormalTok{: }\DecValTok{2}\DataTypeTok{px} \DecValTok{2}\DataTypeTok{px} \DecValTok{0}\DataTypeTok{px} \ConstantTok{black}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{box-shadow} \href{https://www.w3schools.com/cssref/css3_pr_box-shadow.asp}{property} takes four main parameters:

\begin{itemize}
\tightlist
\item
  The horizontal offset in px.
\item
  The vertical offset in px.
\item
  The blur radius value in px. The higher the more blurred.
\item
  The shadow color.
\end{itemize}

Do your remember the \texttt{\{shinydashboard\}} box that we imported inside a simple shiny app from Chapter \ref{htmldeps-import}? This box has been included in the \texttt{\{OSUICode\}} side package. Let's add it some border and shadows.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(OSUICode)}
\KeywordTok{library}\NormalTok{(shinyWidgets)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{useShinydashboard}\NormalTok{(),}
  \KeywordTok{br}\NormalTok{(),}
  \KeywordTok{box2}\NormalTok{(}\DataTypeTok{title =} \StringTok{"Box with border"}\NormalTok{, }\DataTypeTok{background =} \StringTok{"blue"}\NormalTok{, }\DataTypeTok{height =} \StringTok{"400px"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The \texttt{box} class is styled as follow and show Figure \ref{fig:box-shadow-1}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.box}\NormalTok{ \{}
  \KeywordTok{border-radius}\NormalTok{: }\DecValTok{3}\DataTypeTok{px}\OperatorTok{;}
  \KeywordTok{border-top}\NormalTok{: }\DecValTok{3}\DataTypeTok{px} \DecValTok{solid} \ConstantTok{#d2d6de}\OperatorTok{;}
  \KeywordTok{box-shadow}\NormalTok{: }\DecValTok{0} \DecValTok{1}\DataTypeTok{px} \DecValTok{1}\DataTypeTok{px} \FunctionTok{rgb(}\DecValTok{0} \DecValTok{0} \DecValTok{0}\NormalTok{ / }\DecValTok{10}\DataTypeTok{%}\FunctionTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/box-shadow-1} \caption{Shinydashboard box style}\label{fig:box-shadow-1}
\end{figure}

The \texttt{border-radius} of 3px indicates that the box is slightly rounded on all corners.
There is a top solid border which color in gray as well as a tiny shadow.
Let' increase the \texttt{border-radius} to 10px, change the border top to \texttt{border-left} with an orange color and slightly increased thickness:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.box}\NormalTok{ \{}
  \KeywordTok{border-radius}\NormalTok{: }\DecValTok{10}\DataTypeTok{px}\OperatorTok{;}
  \KeywordTok{border-left}\NormalTok{: }\DecValTok{6}\DataTypeTok{px} \DecValTok{solid} \ConstantTok{#e28810}\OperatorTok{;}
  \KeywordTok{box-shadow}\NormalTok{: }\DecValTok{0} \DecValTok{1}\DataTypeTok{px} \DecValTok{1}\DataTypeTok{px} \FunctionTok{rgb(}\DecValTok{0} \DecValTok{0} \DecValTok{0}\NormalTok{ / }\DecValTok{10}\DataTypeTok{%}\FunctionTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We would like to increase the shadow effect only on mouse hover, with reasonable values. To proceed we leverage the pseudo format elements like \texttt{:hover}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.box}\InformationTok{:hover}\NormalTok{ \{}
  \KeywordTok{box-shadow}\NormalTok{: }\DecValTok{0}\DataTypeTok{px} \DecValTok{8}\DataTypeTok{px} \DecValTok{8}\DataTypeTok{px} \DecValTok{0}\DataTypeTok{px} \FunctionTok{rgb(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0.2}\FunctionTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The easiest way to modify the shadow style is directly inside the HTML inspector, as demonstrated on Figure \ref{fig:box-shadow-tool-1}. Next to the property text, there is a button to open the shadow editor. We click on it, which opens a box with input to control the shadow offset, the blur and spread parameter. We leave the effect outside the box, that is \texttt{outset} unchanged. To change the color, we click on the color widget next to the rgb value which opens Figure \ref{fig:box-shadow-tool-2}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/box-shadow-tool-1} \caption{Box shadow shape tools}\label{fig:box-shadow-tool-1}
\end{figure}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/box-shadow-tool-2} \caption{Box shadow color tools}\label{fig:box-shadow-tool-2}
\end{figure}

We finally include this new CSS rule inside the previous app. Optionally, we may change
the color of the text header to be white, to improve the contrast with the box background (See Figure \ref{fig:box-shadow-result}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{useShinydashboard}\NormalTok{(),}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
    \StringTok{".box \{}
\StringTok{      border-top: none;}
\StringTok{      border-radius: 10px;}
\StringTok{      border-left: 6px solid #e28810;}
\StringTok{      box-shadow: 0 1px 1px rgb(0 0 0 / 10%);}
\StringTok{    \}}
\StringTok{    .box:hover \{}
\StringTok{      box-shadow: 0px 8px 8px 0px rgb(0, 0, 0, 0.2);}
\StringTok{    \}}
\StringTok{    .box-header \{}
\StringTok{      color: #fff;}
\StringTok{    \}}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{br}\NormalTok{(),}
  \KeywordTok{box2}\NormalTok{(}\DataTypeTok{title =} \StringTok{"Box with border"}\NormalTok{, }\DataTypeTok{background =} \StringTok{"blue"}\NormalTok{, }\DataTypeTok{height =} \StringTok{"400px"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/box-shadow-result} \caption{Improved box shadow on hover}\label{fig:box-shadow-result}
\end{figure}

\hypertarget{layout}{%
\subsection{Layout}\label{layout}}

As mentioned in section \ref{web-intro-html}, there exist \texttt{block} and \texttt{inline} tags. While block elements are displayed under each other, inline elements are added next to each others, as shown in Figure \ref{fig:css-layout-intro}.

\begin{figure}

{\centering \includegraphics[width=0.25\linewidth]{images/beautify/css-layout-intro} 

}

\caption{Inline and block elements}\label{fig:css-layout-intro}
\end{figure}

CSS allows deep customization of block elements like setting up the width, height and margin. Let's review them below.

\hypertarget{style-blocks}{%
\subsubsection{Style blocks}\label{style-blocks}}

As shown Figure \ref{fig:css-block-box}, a block tag may be seen as a box. CSS allows to set internal and external margins. Internal margins, also called \textbf{padding}, is the space between the block border and the content, in all directions. External margins also known as \textbf{margin} are all spaces between blocks in all directions. A block is also defined by a \textbf{width} and \textbf{height} as well as optional minimal width and height. Width and height may be set either using absolute unites (px) or relative unites(\%) but minimal values are always absolute. Minimal values are useful in case the end user resizes the windows.

The corresponding CSS properties are found below:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.block}\NormalTok{ \{}
\KeywordTok{width}\NormalTok{: }\DecValTok{50}\DataTypeTok{%}\OperatorTok{;} \CommentTok{/* % also work and will be relative size*/}
\KeywordTok{height}\NormalTok{: }\DecValTok{200}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{min-width}\NormalTok{: }\DecValTok{200}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Padding and margins are called CSS super properties. Indeed, setting \texttt{padding:\ 10px} guarantees to have 10px in all directions. If you need custom values, you will have to specify the directions as follows:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.block}\NormalTok{ \{}
\KeywordTok{padding}\NormalTok{: }\DecValTok{10}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{margin-top}\NormalTok{: }\DecValTok{10}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{margin-left}\NormalTok{: }\DecValTok{5}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There exists a shortcut \texttt{margin:\ 5px\ 0\ 5px\ 2} that means 5px on the top, 0 px on the right, 5 px on the bottom and 2px on the left. To remember about the good order, it is clockwise (top, right, bottom, left). Specifying only 2 values \texttt{margin:\ 5px\ 2.5px} means 5px top and bottom, 2.5px left and right. All of the above obviously applies to padding!

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-block-box} \caption{Blocks layout}\label{fig:css-block-box}
\end{figure}

Using margin allows to center a block when \texttt{margin:\ auto} is applied in combination with a given width.

What happens when the content inside the block is bigger than the block itself?
We apply the \textbf{overflow} super property that acts either horizontally or vertically. To have only vertical overflow, choose \texttt{overflow-y}. The overflow property has 4 possible values:

\begin{itemize}
\tightlist
\item
  visible shows the content.
\item
  hidden hides the content that goes outside the block.
\item
  scroll shows scrolling bars in all directions to see the hidden content.
\item
  auto let the web browser decide.
\end{itemize}

Let's apply our newly acquired knowledge to a simple shiny app.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
    \StringTok{".block \{}
\StringTok{      border-color: #00000;}
\StringTok{      border-style: solid;}
\StringTok{      background-color: lightblue;}
\StringTok{      text-align: center;}
\StringTok{      margin: 10px;}
\StringTok{      min-height: 200px;}
\StringTok{      width: 200px;}
\StringTok{    \}}
\StringTok{    }
\StringTok{    span, a \{}
\StringTok{      background-color: orange;}
\StringTok{    \}}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"block"}\NormalTok{,}
    \StringTok{"Block 1"}\NormalTok{,}
    \KeywordTok{br}\NormalTok{(),}
    \KeywordTok{span}\NormalTok{(}\StringTok{"Inline text 1"}\NormalTok{), }\KeywordTok{span}\NormalTok{(}\StringTok{"Inline text 2"}\NormalTok{)}
\NormalTok{  ),}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"block"}\NormalTok{,}
    \StringTok{"Block 2"}\NormalTok{,}
    \KeywordTok{br}\NormalTok{(),}
    \KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, a, }\DataTypeTok{href =} \StringTok{"https://www.google.com/"}\NormalTok{, }\StringTok{"Link"}\NormalTok{)}
\NormalTok{  ),}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"block"}\NormalTok{,}
    \StringTok{"Block 3"}\NormalTok{,}
    \KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, span, }\StringTok{"Inline text"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Well, is that all? I could to better by combining \texttt{fluidRow} and \texttt{column}! Indeed, those 2 functions are part of the grid system built on top of \textbf{flexbox}. Let's talk about this in the next section.

\hypertarget{flexbox}{%
\subsubsection{Flexbox}\label{flexbox}}

The \href{https://css-tricks.com/snippets/css/a-guide-to-flexbox/}{flexbox} (``flexible boxes'') model is a game changer in layout development as it allows to seamlessly:

\begin{itemize}
\tightlist
\item
  align items in a container.
\item
  ensure those items fill the same space.
\item
  \ldots{}
\end{itemize}

The first step is to define the main container and give the flex value to the display property:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.container}\NormalTok{ \{}
\KeywordTok{display}\NormalTok{: flex}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Once done, we have to define the direction and have 4 choices, as shown Figure \ref{fig:css-flexbox-direction}:

\begin{itemize}
\tightlist
\item
  row
\item
  row-reverse
\item
  column
\item
  column-reverse
\end{itemize}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/css-flexbox-direction} \caption{Flexbox directions}\label{fig:css-flexbox-direction}
\end{figure}

Below is an example involving shiny. We first define the container CSS where \texttt{display:\ flex} and \texttt{flex-direction:\ row} set the flexbox display. We also add a border to better see the container limits:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.container}\NormalTok{ \{}
\KeywordTok{display}\NormalTok{: flex}\OperatorTok{;}
\KeywordTok{flex-direction}\NormalTok{: row}\OperatorTok{;}
\KeywordTok{border}\NormalTok{: }\ConstantTok{red} \DecValTok{dashed} \DecValTok{2}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Then, we define the style for container elements, that are \texttt{p} tags. We give them a width and height to better see the blocks. Each child has a given background color with the \texttt{:nth-child(n)} pseudo class. As an exercise, you may try to replace the \texttt{flex-direction} by any of the 4 values and see how blocks move in the main container.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
    \StringTok{".container \{}
\StringTok{      display: flex;}
\StringTok{      flex-direction: row-reverse;}
\StringTok{      border: red dashed 2px;}
\StringTok{    \}}
\StringTok{    }
\StringTok{    p \{}
\StringTok{      width: 200px;}
\StringTok{      height: 200px;}
\StringTok{      text-align: center;}
\StringTok{      color: white;}
\StringTok{      font-size: 50px;}
\StringTok{    \}}
\StringTok{    }
\StringTok{    .container  :nth-child(1) \{}
\StringTok{      background-color: green;}
\StringTok{    \}}
\StringTok{    .container  :nth-child(2) \{}
\StringTok{      background-color: orange;}
\StringTok{    \}}
\StringTok{    .container  :nth-child(3) \{}
\StringTok{      background-color: purple;}
\StringTok{    \}}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"container"}\NormalTok{,}
    \KeywordTok{p}\NormalTok{(}\StringTok{"A"}\NormalTok{),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"B"}\NormalTok{),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"C"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The \textbf{flex-wrap} property may be useful to control how blocks are arranged:

\begin{itemize}
\tightlist
\item
  nowrap (default) put all items on the same row.
\item
  wrap put items on multiple lines from top to bottom.
\item
  wrap-reverse put items on multiple lines from bottom to top.
\end{itemize}

Interestingly, both \texttt{flex-wrap} and \texttt{flex-direction} may be merged with \texttt{flex-flow:\ direction\ wrap\ mode}.

Items may be aligned either on the principal axis defined in the container CSS or on the secondary axis, called cross-axis:

\begin{itemize}
\tightlist
\item
  \texttt{justify-content} that may take the following values flex-start (default), flex-end, center, space-between, space-around and space-evenly
\item
  \texttt{align-items} whose values can be stretch (default), flex-start, flex-end, center and baseline
\end{itemize}

\texttt{justify-content} and \texttt{align-items} are applied at the container level and not on individual items! Whenever the container has multiple line, as a result of a \texttt{flex-wrap:\ wrap} or \texttt{flex-flow:\ ...\ wrap}, we use \texttt{align-content} to align on the cross-axis (flex-start, flex-end, center, stretch by default, space-between, space-around).

flexbox is a mono dimensional system. In the following, we review the CSS grid system\ldots{}

\hypertarget{grid-model}{%
\subsubsection{Grid model}\label{grid-model}}

As mentioned above, \texttt{fluidRow} and \texttt{column} leverage the Bootstrap \href{https://getbootstrap.com/docs/4.3/layout/grid/}{grid} system, that uses flexbox. This is unfortunately rather complex and out of the scope of this book.

\hypertarget{responsive-design-media-queries}{%
\subsection{Responsive design: media queries}\label{responsive-design-media-queries}}

At the very beginning of the web, there was no smartphones or tablets. All websites
were mostly designed to be display on fix computer screens. Everything has changed now, which leads to several problems for non responsive sites.

Media queries are convenient to solve this issue. They allow to setup rules depending
on various conditions. The structure is defined as follows:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{@media}\NormalTok{ rule1 \{}
  \CommentTok{/* CSS */}
\NormalTok{\}}

\CommentTok{/* We may combine rules */}

\ImportTok{@media}\NormalTok{ rule1 }\KeywordTok{and}\NormalTok{ rule }\DecValTok{2} \KeywordTok{and} \DecValTok{...}\NormalTok{ \{}
  \CommentTok{/* CSS */}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For instance, assuming you want to increase the text size, only for mobile devices:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{@media} \DecValTok{all} \KeywordTok{and}\NormalTok{ (}\KeywordTok{max-device-width}\NormalTok{: }\DecValTok{480}\DataTypeTok{px}\NormalTok{) \{}
\NormalTok{p \{}
\KeywordTok{font-size}\NormalTok{: }\DecValTok{1.5}\DataTypeTok{em}\OperatorTok{;}
\NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{all} stands for all screen sizes and the second request target devices having a width
of 480px, at most.

In a shiny app this would give:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}
    \StringTok{"@media all and (max-device-width: 480px) \{}
\StringTok{      p \{}
\StringTok{        font-size: 1.5em;}
\StringTok{      \}}
\StringTok{    \}}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

As shown on Figure \ref{fig:media-queries}, the developer tools have a responsive mode,
which you can enable by clicking on the blue button next to the \texttt{Elements} tabs.
The responsive mode let you define the viewport dimensions, that is the height and width of the web browser page so as to test the media queries. We set the width to 480 so that the text size appears increased. You may try with 481px and see that this text becomes smaller. Be careful, the responsive mode tool does not display the web browser navigation bars, nor the status bar (the bar containing the battery icon and various indicators). Be sure to select the \texttt{...} icon to enable the \texttt{show\ media\ queries} and \texttt{show\ rulers} options. The media query option provides a better visualization of the media query range versus the current screen width, while the ruler helps to fine tune the design.

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/media-queries} \caption{HTML inspector in responsive mode}\label{fig:media-queries}
\end{figure}

Let's consider another example, involving \texttt{shiny::modalDialog}. This function displays
a Bootstrap 3 modal, whose design is partly controlled by media queries. We run the app below and open the developer tools:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{fluidPage}\NormalTok{(}
    \KeywordTok{actionButton}\NormalTok{(}\StringTok{"show"}\NormalTok{, }\StringTok{"Show modal dialog"}\NormalTok{)}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{}
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{show, \{}
      \KeywordTok{showModal}\NormalTok{(}
        \KeywordTok{modalDialog}\NormalTok{(}
          \DataTypeTok{title =} \StringTok{"Important message"}\NormalTok{,}
          \StringTok{"This is an important message!"}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    \})}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The corresponding CSS rules are located in the Bootstrap (3) CSS file:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{@media}\NormalTok{ (}\KeywordTok{min-width}\NormalTok{: }\DecValTok{768}\DataTypeTok{px}\NormalTok{) \{}
  \FunctionTok{.modal-dialog}\NormalTok{ \{}
    \KeywordTok{width}\NormalTok{: }\DecValTok{600}\DataTypeTok{px}\OperatorTok{;}
    \KeywordTok{margin}\NormalTok{: }\DecValTok{30}\DataTypeTok{px} \BuiltInTok{auto}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{.modal-content}\NormalTok{ \{}
    \KeywordTok{-webkit-box-shadow}\NormalTok{: }\DecValTok{0} \DecValTok{5}\DataTypeTok{px} \DecValTok{15}\DataTypeTok{px} \FunctionTok{rgba(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0.5}\FunctionTok{)}\OperatorTok{;}
    \KeywordTok{box-shadow}\NormalTok{: }\DecValTok{0} \DecValTok{5}\DataTypeTok{px} \DecValTok{15}\DataTypeTok{px} \FunctionTok{rgba(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0.5}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{.modal-sm}\NormalTok{ \{}
    \KeywordTok{width}\NormalTok{: }\DecValTok{300}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\ImportTok{@media}\NormalTok{ (}\KeywordTok{min-width}\NormalTok{: }\DecValTok{992}\DataTypeTok{px}\NormalTok{) \{}
  \FunctionTok{.modal-lg}\NormalTok{ \{}
    \KeywordTok{width}\NormalTok{: }\DecValTok{900}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The first query fixes a width of 600px for all modals having the \texttt{.modal-dialog} class (default), as long as the screen size is at least 768px. Moreover, if the modal has the \texttt{modal-sm} class, its width is set to 300px. Finally, as soon as the screen width is higher or equal to 992 px, all modals having the \texttt{.modal-lg} class have a width set to 900px.

Figure \ref{fig:responsive-modal} illustrates the modal responsiveness.

\begin{figure}
\includegraphics[width=0.5\linewidth]{images/beautify/modal-768} \includegraphics[width=0.5\linewidth]{images/beautify/modal-600} \caption{Responsive modal. Left: first media query is fullfilled, width is 600px. Right: First media query not met, width is set to auto}\label{fig:responsive-modal}
\end{figure}

In Figure \ref{fig:modal-size}, we changed the modal size from \texttt{s} to \texttt{l} (left and right, respectively).

\begin{figure}
\includegraphics[width=0.5\linewidth]{images/beautify/modal-s-768} \includegraphics[width=0.5\linewidth]{images/beautify/modal-l-992} \caption{Changed modal size. Left: small modal when screensize is at least 768px. Right: large modal when screen size is at least 992px.}\label{fig:modal-size}
\end{figure}

This has strong implications for the modal size on mobiles. As long as the screen size is
lower than 768px, the size parameter is ignored!

\hypertarget{best-practice}{%
\section{Best practice}\label{best-practice}}

\hypertarget{dry-principles}{%
\subsection{DRY principles}\label{dry-principles}}

DRY stands for ``Don't repeat yourself''. This methodology not only applies to structural languages like R and JavaScript but also to declarative languages like CSS.
Below is an example of badly managed CSS code. Both \texttt{.class-1} and \texttt{.class-2} have the same color and border radius. Only the padding and font size change. This type of code does not follow the DRY rule and increases the risk of having contradictory CSS properties.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.class-1}\NormalTok{\{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{#33BEFF}\OperatorTok{;}
\KeywordTok{padding}\NormalTok{: }\DecValTok{10}\DataTypeTok{px} \DecValTok{16}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{font-size}\NormalTok{: }\DecValTok{12}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{border-radius}\NormalTok{: }\DecValTok{3}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{.class-2}\NormalTok{\{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{#33BEFF}\OperatorTok{;}
\KeywordTok{padding}\NormalTok{: }\DecValTok{5}\DataTypeTok{px} \DecValTok{10}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{font-size}\NormalTok{: }\DecValTok{12}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{border-radius}\NormalTok{: }\DecValTok{3}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We could gather all common properties in one generic class:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.generic}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{#33BEFF}\OperatorTok{;}
\KeywordTok{border-radius}\NormalTok{: }\DecValTok{3}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{.specific-1}\NormalTok{ \{}
\KeywordTok{padding}\NormalTok{: }\DecValTok{10}\DataTypeTok{px} \DecValTok{16}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{font-size}\NormalTok{: }\DecValTok{18}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{.specific2}\NormalTok{ \{}
\KeywordTok{padding}\NormalTok{: }\DecValTok{5}\DataTypeTok{px} \DecValTok{10}\DataTypeTok{px}\OperatorTok{;}
\KeywordTok{font-size}\NormalTok{: }\DecValTok{12}\DataTypeTok{px}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

On the HTML side, we add classes from the most generic to the most specific like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"generic specific-1"}\KeywordTok{>}\NormalTok{My element}\KeywordTok{</div>}
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"generic specific-2"}\KeywordTok{>}\NormalTok{My element}\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

As an even more concrete example, take a look at the \href{https://bulma.io/documentation/elements/button/}{bulma} button:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<button}\OtherTok{ class=}\StringTok{"button is-large is-fullwidth"}\KeywordTok{>}\NormalTok{Large}\KeywordTok{</button>}
\end{Highlighting}
\end{Shaded}

Notice how easy it is to predict the style of the button. It will be large and take the maximum width. It is for sure more meaningful than \texttt{.class1}!

\hypertarget{selector-specificity}{%
\subsection{Selector specificity}\label{selector-specificity}}

What happens in case multiple different selectors target the same element? Which style is really applied? Consider the following example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ id=}\StringTok{"element"}\OtherTok{ class=}\StringTok{"myclass"}\KeywordTok{>}\NormalTok{Some text}\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

with the following CSS rules:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#element}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{.myclass}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{blue}\OperatorTok{;}
\NormalTok{\}}

\NormalTok{div \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{green}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Can you guess what would be the element text color? Well, this is not obvious. You must understand that web browsers apply rules to select the more specific rules:

\begin{itemize}
\tightlist
\item
  Inline style is the most specific. This is style directly attached to the HTML tag.
\item
  \texttt{id} apply to unique objects.
\item
  \texttt{class}, \texttt{pseudoclasses}, attributes.
\item
  elements and pseudo-elements.
\end{itemize}

Going back to our previous example, the most specific selector is \texttt{\#element}, therefore the text color will be red. What happens in case of equality? The last written selector is applied:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"class1 class2"}\KeywordTok{>}\NormalTok{Some text}\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.class1}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{blue}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{.class2}\NormalTok{ \{}
\KeywordTok{color}\NormalTok{: }\ConstantTok{red}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Only the second selector is applied to the tag. To apply \texttt{class1}, you must move it after the \texttt{class2} style definition.

Best practice is to keep the lowest specificity as possible, thereby making \texttt{.class} the first choice.

\hypertarget{block-element-modified-bem}{%
\subsection{Block element modified (BEM)}\label{block-element-modified-bem}}

The BEM \href{http://getbem.com/introduction/}{methodology} will help you to write meaningful CSS, easier to manage.
A block is a standalone entity having a self explanatory name like \texttt{header}, \texttt{checkbox}. An elements is part of the block but not standalone like menu items.
A modifier indicates a specific state of an element, for instance if a button is disabled, active, \ldots{} The general scheme is defined below:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.block__element--modifier}\NormalTok{ \{}
\CommentTok{/* rules */}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Following this methodology guaranties to have documented and meaningful classes.

\hypertarget{exercises-1}{%
\section{Exercises}\label{exercises-1}}

TO DO

\hypertarget{beautify-sass}{%
\chapter{Introduction to SASS}\label{beautify-sass}}

One of the main problem with CSS is to handle the growing number of files and the code repetition. Nowadays, web developers mainly use CSS preprocessors like \href{https://sass-lang.com/guide}{Sass}, that stands for ``Syntactically Awesome Style Sheets'', providing access to variables, mathematical operators, nesting, thereby reducing the code complexity and extending the possibilities. \href{https://rstudio.com}{Rstudio} developed the \href{https://rstudio.github.io/sass/articles/sass.html}{\{sass\}} package, which makes it possible to use Sass in Shiny apps or Rmarkdown documents.

\hypertarget{getting-started-with-sass}{%
\section{Getting started with Sass}\label{getting-started-with-sass}}

While we could use Sass from the terminal, we leverage the \texttt{\{sass\}} package features to stay in R.
To install the \texttt{\{sass\}}, we run:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"sass"}\NormalTok{)}
\CommentTok{# OR}
\NormalTok{remotes}\OperatorTok{::}\KeywordTok{install_github}\NormalTok{(}\StringTok{"rstudio/sass"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We then use the \texttt{sass()} function whose \texttt{input} parameter accepts:

\begin{itemize}
\tightlist
\item
  A R string like \texttt{a\ \{\ color:\ pink\}}.
\item
  A named \texttt{list()}.
\item
  A file passed with \texttt{sass\_file()}, imports with \texttt{sass\_import()}.
\item
  More complex structures.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(sass)}
\KeywordTok{sass}\NormalTok{(}\DataTypeTok{input =} \StringTok{".element-class \{ color: pink;\}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{variables}{%
\subsection{Variables}\label{variables}}

Let us consider the following example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{.class-1}\NormalTok{\{}
  \KeywordTok{color}\NormalTok{: }\ConstantTok{#33BEFF}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{.class-2}\NormalTok{\{}
  \KeywordTok{background-color}\NormalTok{: }\ConstantTok{#33BEFF}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Shouldn't this be easier? Imagine if we had hundreds of elements with the same color.
What happens in case the color changes? Do we have to update all properties by hand?

If we let the Sass variable \texttt{\$my-color}:

\begin{verbatim}
$my-color: purple;
.class-1{
  color: $my-color;
}
.class-2{
  background-color: $my-color;
}
\end{verbatim}

we can quickly solve that problem. With \texttt{\{sass\}}, we obtain:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var <-}\StringTok{ "$my-color: purple;"}
\NormalTok{rule1 <-}\StringTok{ ".class-1\{ color: $my-color; \}"}
\NormalTok{rule2 <-}\StringTok{ ".class-2\{ background-color: $my-color; \}"}
\KeywordTok{sass}\NormalTok{(}\DataTypeTok{input =} \KeywordTok{list}\NormalTok{(var, rule1, rule2))}
\end{Highlighting}
\end{Shaded}

\textbf{Note}: it is good practice to add the \texttt{default!} tag after the variable definition, if you want
to let others modify it: \texttt{"\$my-color:\ purple\ !default;"}

\hypertarget{partials-and-modules}{%
\subsection{Partials and Modules}\label{partials-and-modules}}

It is best practice to save useful code snippets in one place, and reuse them
at anytime and anywhere. Sass allows to define partials, like \texttt{\_partial.css}, with the leading
underscore, which avoids it to be converted into CSS. Partials are subsequently called
with \texttt{@import\ \textless{}PARTIAL\_NAME\textgreater{}} (you may also find \texttt{@use}, the latter not being handled
by \texttt{LibSass}, which fuels\texttt{\{sass\}}), thereby significantly reducing code duplication.

Modules are pieces of Sass files that are later converted into CSS, reducing file size to a minimum.
Below is an example of the \texttt{bootstrap.scss} \href{https://github.com/twbs/bootstrap/blob/main/scss/bootstrap.scss}{file}:

\begin{verbatim}
/*!
 * Bootstrap v5.0.0-beta1 (https://getbootstrap.com/)
 * Copyright 2011-2021 The Bootstrap Authors
 * Copyright 2011-2021 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */

// scss-docs-start import-stack
// Configuration
@import "functions";
@import "variables";
@import "mixins";
@import "utilities";

// Layout & components
@import "root";
@import "reboot";
@import "type";
@import "images";
@import "containers";
@import "grid";
@import "tables";
@import "forms";
@import "buttons";
@import "transitions";
@import "dropdown";
@import "button-group";
@import "nav";
@import "navbar";
@import "card";
@import "accordion";
@import "breadcrumb";
@import "pagination";
@import "badge";
@import "alert";
@import "progress";
@import "list-group";
@import "close";
@import "toasts";
@import "modal";
@import "tooltip";
@import "popover";
@import "carousel";
@import "spinners";

// Helpers
@import "helpers";

// Utilities
@import "utilities/api";
// scss-docs-end import-stack
\end{verbatim}

which is better to read and easier to maintain than the original \texttt{bootstrap.css} with 10717 lines of code!

In practice, we will often end up with a main Sass file and compile it as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sass}\NormalTok{(}\KeywordTok{sass_file}\NormalTok{(}\StringTok{"main.scss"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{mixins-and-functions}{%
\subsection{Mixins and Functions}\label{mixins-and-functions}}

\hypertarget{mixins}{%
\subsubsection{Mixins}\label{mixins}}

To make a 90 degrees rotation in CSS, we have to write:

\begin{verbatim}
.element {
  -webkit-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  transform: rotate(90deg);
}
\end{verbatim}

which is tedious. Mixins allow to encapsulate the logic into a reusable unit:

\begin{verbatim}
@mixin transform($property, ...) {
  -webkit-transform: $property;
  -ms-transform: $property;
  transform: $property;
}

.element1 { @include transform(rotate(90deg)); }
\end{verbatim}

The mixin starts with a \texttt{@mixin} keyword followed by its name and parameters.
It is called with \texttt{@include\ \textless{}MIXIN\_NAME(PARMS)\textgreater{}}, very similar to a function declaration, excepts that
it must return a CSS rule.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mixin <-}\StringTok{ "@mixin transform($property) \{}
\StringTok{  -webkit-transform: $property;}
\StringTok{  -ms-transform: $property;}
\StringTok{  transform: $property;}
\StringTok{\}"}
\NormalTok{rule <-}\StringTok{ ".element1 \{ @include transform(rotate(90deg)); \}"}
\KeywordTok{sass}\NormalTok{(}\DataTypeTok{input =} \KeywordTok{list}\NormalTok{(mixin, rule))}
\end{Highlighting}
\end{Shaded}

\hypertarget{functions}{%
\subsubsection{Functions}\label{functions}}

Sass offers many built-In \href{https://sass-lang.com/documentation/modules}{modules} containing
ready to use functions for colors, numbers, strings, lists, maps, \ldots Some functions like
\texttt{rgb} are global, so that we don't have to import the corresponding module.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sass}\NormalTok{(}\StringTok{".pouet \{ color: rgb(0, 255, 0); \}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

It is definitely possible to design custom functions with \texttt{@function},
whose syntax is very close the mixins:

\begin{verbatim}
@function name($parm1, $parm2) {
  /* logic */
  @return value;
}
\end{verbatim}

While debugging functions, it might be useful to capture intermediate elements.
\texttt{@debug} allows this:

\begin{verbatim}
$my-var: 1;
@debug myvar;
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sass}\NormalTok{(}\StringTok{"}
\StringTok{  $myvar: 1;}
\StringTok{  @debug '$myvar is #\{$myvar\};'}
\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{extendinheritance}{%
\subsection{Extend/Inheritance}\label{extendinheritance}}

We consider 2 alerts with the color as only difference. As we can't capture multiple properties
inside one single Sass variable, we introduce the \texttt{extend} concept, which permits to import
CSS properties inside multiple rules. We first define a generic \texttt{alerts-common} rule,
prefixed by the \texttt{\%} symbol. It contains several rules and variables:

\begin{verbatim}
%alerts-common {
  position: relative;
  padding: $alert-padding-y $alert-padding-x;
  margin-bottom: $alert-margin-bottom;
}


.alert-red {
  @extend %alerts-common;
  color: red;
}

.alert-green {
  @extend %alerts-common;
  color: green;
}
\end{verbatim}

Let's translate this into R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y_padding <-}\StringTok{ "$alert-padding-y: 5px;"}
\NormalTok{x_padding <-}\StringTok{ "$alert-padding-x: 10px;"}
\NormalTok{b_margin <-}\StringTok{ "$alert-margin-bottom: 2px;"}
\NormalTok{common <-}\StringTok{ "%alerts-common \{}
\StringTok{  position: relative;}
\StringTok{  padding: $alert-padding-y $alert-padding-x;}
\StringTok{  margin-bottom: $alert-margin-bottom;}
\StringTok{\}"}
\NormalTok{alert_red <-}\StringTok{ ".alert-red \{}
\StringTok{  @extend %alerts-common;}
\StringTok{  color: red;}
\StringTok{\}}
\StringTok{"}
\NormalTok{alert_green <-}\StringTok{ ".alert-green \{}
\StringTok{  @extend %alerts-common;}
\StringTok{  color: green;}
\StringTok{\}}
\StringTok{"}
\KeywordTok{sass}\NormalTok{(}\DataTypeTok{input =} \KeywordTok{list}\NormalTok{(y_padding, x_padding, b_margin, common, alert_red, alert_green))}
\end{Highlighting}
\end{Shaded}

This method avoids to multiply classes on elements such as \texttt{.alert-common\ .alert-red\ ...}.
Yet, there is still duplication as we could have programmatically generated the two alert
classes with a loop.

\hypertarget{flow-controls}{%
\subsection{Flow Controls}\label{flow-controls}}

These are elements aiming at fine tuning mixins and functions behavior.\\
\#\#\#\# If and else
Like in every programming language \texttt{if} and \texttt{else} control the execution of a code block, depending
on some conditions.
Below, we only want to conditionally control a shadow property, depending on the alert color:

\begin{verbatim}
@mixin add-shadow($box-color) {
  @if box-color == red {
    box-shadow: 
      0 4px 10px 0 rgb(255, 0, 0), 
      0 4px 20px 0 rgb(255, 0, 0);
  } @else if $box-color == green {
    box-shadow: 
      0 4px 10px 0 rgb(0, 255, 0), 
      0 4px 20px 0 rgb(0, 255, 0);
  }
}

.alert-red {
  @extend %alerts-common;
  color: red;
  @include add-shadow($box-color: red);
}

.alert-green {
  @extend %alerts-common;
  color: green;
  @include add-shadow($box-color: green);
}
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add_shadow <-}\StringTok{ "@mixin add-shadow($box-color) \{}
\StringTok{  @if $box-color == red \{}
\StringTok{    box-shadow: }
\StringTok{      0 4px 10px 0 rgb(255, 0, 0), }
\StringTok{      0 4px 20px 0 rgb(255, 0, 0);}
\StringTok{  \} @else if $box-color == green \{}
\StringTok{    box-shadow: }
\StringTok{      0 4px 10px 0 rgb(0, 255, 0), }
\StringTok{      0 4px 20px 0 rgb(0, 255, 0);}
\StringTok{  \}}
\StringTok{\}}
\StringTok{"}
\NormalTok{y_padding <-}\StringTok{ "$alert-padding-y: 5px;"}
\NormalTok{x_padding <-}\StringTok{ "$alert-padding-x: 10px;"}
\NormalTok{b_margin <-}\StringTok{ "$alert-margin-bottom: 2px;"}
\NormalTok{common <-}\StringTok{ "%alerts-common \{}
\StringTok{  position: relative;}
\StringTok{  padding: $alert-padding-y $alert-padding-x;}
\StringTok{  margin-bottom: $alert-margin-bottom;}
\StringTok{\}"}
\NormalTok{alert_red <-}\StringTok{ ".alert-red \{}
\StringTok{  @extend %alerts-common;}
\StringTok{  color: red;}
\StringTok{  @include add-shadow($box-color: red);}
\StringTok{\}}
\StringTok{"}
\NormalTok{alert_green <-}\StringTok{ ".alert-green \{}
\StringTok{  @extend %alerts-common;}
\StringTok{  color: green;}
\StringTok{  @include add-shadow($box-color: green);}
\StringTok{\}}
\StringTok{"}
\KeywordTok{sass}\NormalTok{(}\DataTypeTok{input =} \KeywordTok{list}\NormalTok{(y_padding, x_padding, b_margin, common, add_shadow, alert_red, alert_green))}
\end{Highlighting}
\end{Shaded}

\hypertarget{loops}{%
\subsubsection{Loops}\label{loops}}

\hypertarget{each}{%
\paragraph{Each}\label{each}}

We would like to create the alert class with only one rule. We first define a list of colors in Sass and
call the \texttt{@each}:

\begin{verbatim}
$colors: red, green;

@each $color in $colors {
  .alert-#{$color} {
    color: green;
    @include add-shadow($box-color: $color);
  }
}
\end{verbatim}

The structure is the same as the JavaScript loop. You'll also notice the \texttt{\#\{...\}} which
is called \href{https://sass-lang.com/documentation/interpolation}{interpolation} and allows to
insert any Sass expression in a string. As another example, if we want to create a \texttt{background-image} property
within a mixin, we could do \texttt{background-image:\ url("/some\_path/\#\{\$name\}.svg")}, where \texttt{\#\{\$name\}} holds the file name.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add_shadow <-}\StringTok{ "@mixin add-shadow($box-color) \{}
\StringTok{  @if $box-color == red \{}
\StringTok{    box-shadow: }
\StringTok{      0 4px 10px 0 rgb(255, 0, 0), }
\StringTok{      0 4px 20px 0 rgb(255, 0, 0);}
\StringTok{  \} @else if $box-color == green \{}
\StringTok{    box-shadow: }
\StringTok{      0 4px 10px 0 rgb(0, 255, 0), }
\StringTok{      0 4px 20px 0 rgb(0, 255, 0);}
\StringTok{  \}}
\StringTok{\}}
\StringTok{"}
\NormalTok{y_padding <-}\StringTok{ "$alert-padding-y: 5px;"}
\NormalTok{x_padding <-}\StringTok{ "$alert-padding-x: 10px;"}
\NormalTok{b_margin <-}\StringTok{ "$alert-margin-bottom: 2px;"}
\NormalTok{common <-}\StringTok{ "%alerts-common \{}
\StringTok{  position: relative;}
\StringTok{  padding: $alert-padding-y $alert-padding-x;}
\StringTok{  margin-bottom: $alert-margin-bottom;}
\StringTok{\}"}
\NormalTok{alerts_rule <-}\StringTok{ "$colors: red, green;}
\StringTok{@each $color in $colors \{}
\StringTok{  .alert-#\{$color\} \{}
\StringTok{    @extend %alerts-common;}
\StringTok{    color: green;}
\StringTok{    @include add-shadow($box-color: $color);}
\StringTok{  \}}
\StringTok{\}}
\StringTok{"}
\KeywordTok{sass}\NormalTok{(}\DataTypeTok{input =} \KeywordTok{list}\NormalTok{(y_padding, x_padding, b_margin, common, add_shadow, alerts_rule))}
\end{Highlighting}
\end{Shaded}

It becomes even more powerful while working with maps like \texttt{\$font-weights:\ ("regular":\ 400,\ "medium":\ 500,\ "bold":\ 700);}, ie by key/value \href{https://sass-lang.com/documentation/at-rules/control/each\#with-maps}{pairs}.
\texttt{@each} is as convenient as \texttt{lapply} or \texttt{map} functions to chain repetitive rules creation.

\hypertarget{for}{%
\paragraph{For}\label{for}}

However, it is not straightforward to count up or down with \texttt{@each}. This is precisely where
\texttt{@for} fills the gap. The generic scheme is:

\begin{verbatim}
@for <variable> from <expression> to <expression> { ... } 
@for <variable> from <expression> through <expression> { ... }
\end{verbatim}

\texttt{to} excludes the last number while \texttt{through} includes it.

\hypertarget{sass-best-practices}{%
\section{\texorpdfstring{\texttt{\{sass\}} best practices}{\{sass\} best practices}}\label{sass-best-practices}}

As it's best practice, especially for debugging purposes, to include assets as HTML
dependencies, it is a good idea to organize the Sass variable definition, function/mixins in layers, leveraging the \texttt{sass\_layer} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var <-}\StringTok{ "$my-color: purple !default"}
\NormalTok{rule1 <-}\StringTok{ ".class-1\{ color: $my-color; \}"}
\NormalTok{rule2 <-}\StringTok{ ".class-2\{ background-color: $my-color; \}"}
\NormalTok{layer1 <-}\StringTok{ }\KeywordTok{sass_layer}\NormalTok{(}
  \DataTypeTok{default =}\NormalTok{ var,}
  \DataTypeTok{rules =} \KeywordTok{c}\NormalTok{(rule1, rule2)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in sass_layer(default = var, rules = c(rule1, rule2)): partial argument
## match of 'default' to 'defaults'
\end{verbatim}

Besides, \texttt{sass\_layer} provide options like:

\begin{itemize}
\tightlist
\item
  \texttt{declarations} containing any function, mixin elements, in a \texttt{sass\_file} for instance.
\item
  \texttt{html\_deps} that attaches a single or a list of HTML dependencies to the provided Sass code. (See below)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sass_layer}\NormalTok{(}
  \DataTypeTok{html_deps =}\NormalTok{ htmltools}\OperatorTok{::}\KeywordTok{htmlDependency}\NormalTok{(}
    \DataTypeTok{name =} \StringTok{"my-dep"}\NormalTok{, }
    \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{,}
    \DataTypeTok{package =} \StringTok{"mypkg"}\NormalTok{,}
    \DataTypeTok{src =} \StringTok{"path"}\NormalTok{,}
\NormalTok{    ...}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ultimately, multiple layers may be bundled with \texttt{sass\_bundle}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var2 <-}\StringTok{ "$my-color: blue !default"}
\NormalTok{layer2 <-}\StringTok{ }\KeywordTok{sass_layer}\NormalTok{(}
  \DataTypeTok{default =}\NormalTok{ var2,}
  \DataTypeTok{rules =} \KeywordTok{c}\NormalTok{(rule1, rule2)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in sass_layer(default = var2, rules = c(rule1, rule2)): partial argument
## match of 'default' to 'defaults'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_bundle <-}\StringTok{ }\KeywordTok{sass_bundle}\NormalTok{(}\DataTypeTok{layer1 =}\NormalTok{ layer1, }\DataTypeTok{layer2 =}\NormalTok{ layer1)}
\NormalTok{my_bundle}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## /* Sass Bundle: layer1, layer2 */
## $my-color: purple !default
## $my-color: purple !default
## .class-1{ color: $my-color; }
## .class-2{ background-color: $my-color; }
## .class-1{ color: $my-color; }
## .class-2{ background-color: $my-color; }
## /* *** */
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sass}\NormalTok{(my_bundle)}
\end{Highlighting}
\end{Shaded}

and \texttt{sass\_bundle\_remove}
removes a given layer from the bundle, provided that you passed a named list to \texttt{sass\_bundle}.
This allows other developers to reuse and modify predefined layers:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_bundle <-}\StringTok{ }\KeywordTok{sass_bundle_remove}\NormalTok{(my_bundle, }\StringTok{"layer2"}\NormalTok{)}
\KeywordTok{sass}\NormalTok{(my_bundle)}
\end{Highlighting}
\end{Shaded}

\hypertarget{from-sass-to-css}{%
\section{From Sass to CSS}\label{from-sass-to-css}}

\texttt{sass} can generate CSS from Sass by passing an \texttt{output} parameter pointing to the path where
to generate the CSS file. Best practice consists in enabling compression and source maps. We discuss
this later in the book in Chapter \ref{workflow-charpente}. Overall those steps makes the code faster to load and easier to debug:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sass}\NormalTok{(}
  \KeywordTok{list}\NormalTok{(}
   \StringTok{"$color: pink;"}\NormalTok{,}
   \StringTok{".a \{ color: $color; \}"} 
\NormalTok{  ),}
  \DataTypeTok{options =} \KeywordTok{sass_options}\NormalTok{(}
    \DataTypeTok{output_style =} \StringTok{"compressed"}\NormalTok{,}
    \DataTypeTok{source_map_embed =} \OtherTok{TRUE}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sass}\NormalTok{(}
  \KeywordTok{sass_file}\NormalTok{(}\StringTok{"main.scss"}\NormalTok{),}
  \StringTok{"<OUTPUT PATH>"}\NormalTok{,}
  \DataTypeTok{options =} \KeywordTok{sass_options}\NormalTok{(}
    \DataTypeTok{output_style =} \StringTok{"compressed"}\NormalTok{,}
    \DataTypeTok{source_map_embed =} \OtherTok{TRUE}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{sass-and-shiny}{%
\section{Sass and Shiny}\label{sass-and-shiny}}

Now let's go back to Shiny! How do we include Sass code in a Shiny app? There are multiple situations:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  You simply want to style a shiny app.
\item
  You developed a template with custom JS and Sass/CSS to be reused by other developers.
\end{enumerate}

The first option is rather simple since the Sass code is compiled with \texttt{sass} before the shiny apps is launched. The resulting code may be either a string or a CSS file (within the \texttt{www} folder), to be included in the \texttt{head}. To
make it easier to test on the reader side, we create a temporary folder where the Sass code is compiled.
We then create a simple app file which is run with \texttt{runApp}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"myApp"}\NormalTok{)}
\KeywordTok{dir.create}\NormalTok{(}\KeywordTok{sprintf}\NormalTok{(}\StringTok{"%s/www"}\NormalTok{, path), }\DataTypeTok{recursive =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{sass}\NormalTok{(}
  \KeywordTok{list}\NormalTok{(}
   \KeywordTok{c}\NormalTok{(}\StringTok{"$color: pink;"}\NormalTok{, }\StringTok{"$size: 30px;"}\NormalTok{),}
   \KeywordTok{c}\NormalTok{(}\StringTok{".awesome-link \{ }
\StringTok{        color: $color; }
\StringTok{        font-size: $size; }
\StringTok{        &:hover\{}
\StringTok{          color: green;}
\StringTok{        \}}
\StringTok{      \}"}
\NormalTok{    )}
\NormalTok{  ), }
  \DataTypeTok{output =} \KeywordTok{sprintf}\NormalTok{(}\StringTok{"%s/www/main.min.css"}\NormalTok{, path),}
  \DataTypeTok{options =} \KeywordTok{sass_options}\NormalTok{(}
    \DataTypeTok{output_style =} \StringTok{"compressed"}\NormalTok{,}
    \DataTypeTok{source_map_embed =} \OtherTok{TRUE}
\NormalTok{  )}
\NormalTok{)}

\KeywordTok{file.create}\NormalTok{(}\KeywordTok{sprintf}\NormalTok{(}\StringTok{"%s/app.R"}\NormalTok{, path))}

\NormalTok{app_code <-}\StringTok{ 'library(shiny)}

\StringTok{ui <- fluidPage(}
\StringTok{  tags$head(}
\StringTok{    tags$link(href = "main.min.css", rel = "stylesheet", type = "text/css")}
\StringTok{  ),}
\StringTok{  a("Hello Shiny!", class = "awesome-link")}
\StringTok{)}

\StringTok{server <- function(input, output) \{\}}
\StringTok{shinyApp(ui, server)}
\StringTok{'}
\KeywordTok{writeLines}\NormalTok{(app_code, }\KeywordTok{sprintf}\NormalTok{(}\StringTok{"%s/app.R"}\NormalTok{, path))}

\KeywordTok{runApp}\NormalTok{(}\KeywordTok{sprintf}\NormalTok{(}\StringTok{"%s"}\NormalTok{, path))}
\end{Highlighting}
\end{Shaded}

Source maps allow us to see the original Sass code, as shown Figure \ref{fig:sass-inspect}.
\texttt{sass\_options} gives the flexibility to fine tune the CSS output and source map configuration.

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/sass-inspect} \caption{Inspect Sass code in the web browser}\label{fig:sass-inspect}
\end{figure}

The second option requires to run \texttt{sass} passing an \texttt{output} file within the package. Then, the generated CSS
is included in an HTML dependency, to be shipped with the template:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sass}\NormalTok{(}
  \KeywordTok{sass_file}\NormalTok{(}\StringTok{"main.scss"}\NormalTok{),}
  \StringTok{"<OUTPUT PATH>/main.css"}\NormalTok{,}
  \DataTypeTok{options =} \KeywordTok{sass_options}\NormalTok{(}
    \DataTypeTok{output_style =} \StringTok{"compressed"}\NormalTok{,}
    \DataTypeTok{source_map_embed =} \OtherTok{TRUE}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{my_css_deps <-}\StringTok{ }\NormalTok{htmltools}\OperatorTok{::}\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"my-style"}\NormalTok{, }
  \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{,}
  \DataTypeTok{package =} \StringTok{"mypkg"}\NormalTok{,}
  \DataTypeTok{src =} \StringTok{"<OUTPUT PATH>"}\NormalTok{,}
  \DataTypeTok{stylesheet =} \StringTok{"main.css"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{examples}{%
\section{Examples}\label{examples}}

\hypertarget{sass-customize-bs4Dash}{%
\subsection{\texorpdfstring{Customize \texttt{\{bs4Dash\}} colors}{Customize \{bs4Dash\} colors}}\label{sass-customize-bs4Dash}}

\texttt{\{bs4Dash\}} is a Bootstrap 4 dashboard template built on top of the \href{https://adminlte.io/themes/v3/}{AdminLTE3} HTML template. \texttt{\{shinydashboard\}} is powered by the previous version, that is \href{https://adminlte.io/themes/AdminLTE/index2.html}{AdminLTE2}, which make it somehow \texttt{\{bs4Dash\}}'s big brother!
AdminLTE3 relies on Sass and all files are stored \href{https://github.com/ColorlibHQ/AdminLTE/tree/master/build/scss}{here}. Particularly,
all variables are located in the \texttt{\_variables.scss} partial. Since we can decompose our
Sass code in multiple layers thanks to \texttt{\{sass\}}, we can seamlessly customize the theme color
variables listed below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$blue}\InformationTok{: #0073b7 !default}\NormalTok{;}
\NormalTok{$lightblue}\InformationTok{: #3c8dbc !default}\NormalTok{;}
\NormalTok{$navy}\InformationTok{: #001f3f !default}\NormalTok{;}
\NormalTok{$teal}\InformationTok{: #39cccc !default}\NormalTok{;}
\NormalTok{$olive}\InformationTok{: #3d9970 !default}\NormalTok{;}
\NormalTok{$lime}\InformationTok{: #01ff70 !default}\NormalTok{;}
\NormalTok{$orange}\InformationTok{: #ff851b}\NormalTok{ !default;}
\NormalTok{$fuchsia}\InformationTok{: #f012be}\NormalTok{ !default;}
\NormalTok{$purple}\InformationTok{: #605ca8 !default}\NormalTok{;}
\NormalTok{$maroon}\InformationTok{: #d81b60}\NormalTok{ !default;}
\NormalTok{$black}\InformationTok{: #111 !default}\NormalTok{;}
\NormalTok{$gray-x-light}\InformationTok{: #d2d6de}\NormalTok{ !default;}
\end{Highlighting}
\end{Shaded}

Let's provide our own default with some custom \href{https://colorswall.com/palette/66354/}{colors}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$blue}\InformationTok{: #136377 !default}\NormalTok{;}
\NormalTok{$olive}\InformationTok{: #d8bc66}\NormalTok{ !default;}
\NormalTok{$lime}\InformationTok{: #fcec0c}\NormalTok{ !default;}
\NormalTok{$orange}\InformationTok{: #978d01 !default}\NormalTok{;}
\NormalTok{$maroon}\InformationTok{: #58482c !default}\NormalTok{;}
\NormalTok{$gray-x-light}\InformationTok{: #d1c5c0}\NormalTok{ !default;}
\end{Highlighting}
\end{Shaded}

Now we would have to recompile the whole AdminLTE3 Sass code to account for these changes.
It means, all scss assets must be accessible somewhere: this is what the \texttt{\{fresh\}} package is doing under the \href{https://github.com/dreamRs/fresh/blob/master/R/create_theme.R}{hoods}.
No worries, we'll come back on \texttt{\{fresh\}} in the next Chapter. For now, we rely on the \texttt{\{fresh\}} Sass code stored at
\texttt{system.file("assets/AdminLTE-3.0.4/AdminLTE.scss",\ package\ =\ "fresh")}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(bs4Dash)}

\NormalTok{css <-}\StringTok{ }\KeywordTok{sass}\NormalTok{(}
  \KeywordTok{sass_layer}\NormalTok{(}
    \DataTypeTok{default =} \KeywordTok{c}\NormalTok{(}
      \StringTok{"$lightblue: #136377 !default;"}\NormalTok{,}
      \StringTok{"$olive: #d8bc66 !default;"}\NormalTok{,}
      \StringTok{"$lime: #fcec0c !default;"}\NormalTok{,}
      \StringTok{"$orange: #978d01 !default;"}\NormalTok{,}
      \StringTok{"$maroon: #58482c !default;"}\NormalTok{,}
      \StringTok{"$gray-x-light: #d1c5c0 !default;"}
\NormalTok{    ),}
    \DataTypeTok{rules =} \KeywordTok{sass_file}\NormalTok{(}
      \DataTypeTok{input =} \KeywordTok{system.file}\NormalTok{(}\StringTok{"assets/AdminLTE-3.1.0/AdminLTE.scss"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"fresh"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}


\NormalTok{ui <-}\StringTok{ }\KeywordTok{dashboardPage}\NormalTok{(}
  \KeywordTok{dashboardHeader}\NormalTok{(}\DataTypeTok{title =} \StringTok{"Custom colors"}\NormalTok{),}
  \KeywordTok{dashboardSidebar}\NormalTok{(),}
  \KeywordTok{dashboardBody}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(css)),}
    \CommentTok{# Boxes need to be put in a row (or column)}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{box}\NormalTok{(}
        \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{, }
        \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"plot1"}\NormalTok{, }\DataTypeTok{height =} \DecValTok{250}\NormalTok{), }
        \DataTypeTok{status =} \StringTok{"olive"}
\NormalTok{        ),}
      \KeywordTok{box}\NormalTok{(}
        \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
        \DataTypeTok{status =} \StringTok{"lightblue"}\NormalTok{,}
        \DataTypeTok{title =} \StringTok{"Controls"}\NormalTok{,}
        \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"slider"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{50}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
  \KeywordTok{set.seed}\NormalTok{(}\DecValTok{122}\NormalTok{)}
\NormalTok{  histdata <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{500}\NormalTok{)}

\NormalTok{  output}\OperatorTok{$}\NormalTok{plot1 <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
\NormalTok{    data <-}\StringTok{ }\NormalTok{histdata[}\KeywordTok{seq_len}\NormalTok{(input}\OperatorTok{$}\NormalTok{slider)]}
    \KeywordTok{hist}\NormalTok{(data)}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

You probably noticed a potential issue. We indeed have to rely on a specific version,
namely \texttt{3.1.0}, that is not necessarily the one we want. Therefore, an alternative could
be to download the Sass files from the AdminLTE3, store them in a temp folder and recompile
the code from that folder with new variables. As AdminLTE3 depends on a very specific version
of Bootstrap 4, \texttt{4.5.3}, we also have to recover those dependencies in a separate folder.
We finally edit the original \texttt{adminlte.scss} to change the Bootstrap Sass path:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/*!}
\CommentTok{ *   AdminLTE v3.1.0-rc}
\CommentTok{ *   Author: Colorlib}
\CommentTok{ *   Website: AdminLTE.io <https://adminlte.io>}
\CommentTok{ *   License: Open source - MIT <https://opensource.org/licenses/MIT>}
\CommentTok{ */}

\ErrorTok{// Bootstrap}
\ErrorTok{// ---------------------------------------------------}
\ImportTok{@import} \StringTok{"../bootstrap/scss/functions"}\OperatorTok{;}
\ImportTok{@import} \StringTok{"bootstrap-variables"}\OperatorTok{;}
\ImportTok{@import} \StringTok{"../bootstrap/scss/bootstrap"}\OperatorTok{;}

\ErrorTok{// Variables and Mixins}
\ErrorTok{// ---------------------------------------------------}
\ImportTok{@import} \StringTok{"variables"}\OperatorTok{;}
\ImportTok{@import} \StringTok{"mixins"}\OperatorTok{;}

\ImportTok{@import} \StringTok{"parts/core"}\OperatorTok{;}
\ImportTok{@import} \StringTok{"parts/components"}\OperatorTok{;}
\ImportTok{@import} \StringTok{"parts/extra-components"}\OperatorTok{;}
\ImportTok{@import} \StringTok{"parts/pages"}\OperatorTok{;}
\ImportTok{@import} \StringTok{"parts/plugins"}\OperatorTok{;}
\ImportTok{@import} \StringTok{"parts/miscellaneous"}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In the below demonstration, in addition to change the theme colors, we also modified the
\texttt{\$sidebar-dark-bg} \href{https://github.com/ColorlibHQ/AdminLTE/blob/master/build/scss/_variables.scss\#L112}{variable} to be \texttt{\$lightblue} and \texttt{\$sidebar-light-bg} to \texttt{\$lime}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temp_path <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{())}
\KeywordTok{dir.create}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(temp_path, }\StringTok{"adminlte"}\NormalTok{))}
\KeywordTok{setwd}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(temp_path, }\StringTok{"adminlte"}\NormalTok{))}
\KeywordTok{system}\NormalTok{(}\StringTok{"wget -r -np -k --cut-dirs=4 -nH https://cdn.jsdelivr.net/npm/admin-lte@3.1.0-rc/build/scss/"}\NormalTok{)}
\KeywordTok{dir.create}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(temp_path, }\StringTok{"bootstrap/scss"}\NormalTok{), }\DataTypeTok{recursive =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{setwd}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(temp_path, }\StringTok{"bootstrap/scss"}\NormalTok{))}
\KeywordTok{system}\NormalTok{(}\StringTok{"wget -r -np -k --cut-dirs=3 -nH https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/scss/"}\NormalTok{)}
\NormalTok{adminlte_scss <-}\StringTok{ }\KeywordTok{sprintf}\NormalTok{(}\StringTok{"%s/adminlte/adminlte.scss"}\NormalTok{, temp_path)}

\NormalTok{css <-}\StringTok{ }\KeywordTok{sass}\NormalTok{(}
  \KeywordTok{sass_layer}\NormalTok{(}
    \DataTypeTok{default =} \KeywordTok{c}\NormalTok{(}
      \StringTok{"$lightblue: #136377 !default;"}\NormalTok{,}
      \StringTok{"$olive: #d8bc66 !default;"}\NormalTok{,}
      \StringTok{"$lime: #fcec0c !default;"}\NormalTok{,}
      \StringTok{"$orange: #978d01 !default;"}\NormalTok{,}
      \StringTok{"$maroon: #58482c !default;"}\NormalTok{,}
      \StringTok{"$gray-x-light: #d1c5c0 !default;"}\NormalTok{,}
      \StringTok{"$sidebar-dark-bg: $lightblue !default;"}\NormalTok{,}
      \StringTok{"$sidebar-light-bg: $lime !default;"}
\NormalTok{    ),}
    \DataTypeTok{rules =} \KeywordTok{sass_file}\NormalTok{(}\DataTypeTok{input =}\NormalTok{ adminlte_scss)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{dashboardPage}\NormalTok{(}
  \KeywordTok{dashboardHeader}\NormalTok{(}\DataTypeTok{title =} \StringTok{"Custom colors"}\NormalTok{),}
  \KeywordTok{dashboardSidebar}\NormalTok{(),}
  \KeywordTok{dashboardBody}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(css)),}
    \CommentTok{# Boxes need to be put in a row (or column)}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{box}\NormalTok{(}\KeywordTok{plotOutput}\NormalTok{(}\StringTok{"plot1"}\NormalTok{, }\DataTypeTok{height =} \DecValTok{250}\NormalTok{), }\DataTypeTok{status =} \StringTok{"olive"}\NormalTok{),}

      \KeywordTok{box}\NormalTok{(}
        \DataTypeTok{status =} \StringTok{"lightblue"}\NormalTok{,}
        \DataTypeTok{title =} \StringTok{"Controls"}\NormalTok{,}
        \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"slider"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{50}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{customize-shinybulma}{%
\subsection{\texorpdfstring{Customize \texttt{\{shinybulma\}}}{Customize \{shinybulma\}}}\label{customize-shinybulma}}

For convenience, the Sass code is already included in the book side \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code/tree/master/inst/sass/bulma}{package}.
The goal is to change the main color palette that comprises:

\begin{itemize}
\tightlist
\item
  primary
\item
  info
\item
  success
\item
  warning
\item
  danger
\end{itemize}

In total, bulma exposes 419 Sass \href{https://bulma.io/documentation/customize/concepts/}{variables}!

Among all files, we locate the main variables file and select the relevant variables you want to modify.
Notice you can retrieve all those information: \href{https://bulma.io/documentation/customize/variables/\#initial-variables}{initial variables} and \href{https://bulma.io/documentation/customize/variables/\#variables}{derived variables}.

We assign them new \href{https://blog.depositphotos.com/neon-color-palettes.html}{values}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$turquoise}\InformationTok{: #03a4ff;}
\NormalTok{$cyan}\InformationTok{: #e705be}\NormalTok{;}
\NormalTok{$green}\InformationTok{: #f3d6e9}\NormalTok{;}
\NormalTok{$yellow}\InformationTok{: #fdaf2c}\NormalTok{;}
\NormalTok{$red}\InformationTok{: #ff483e}\NormalTok{;}
\NormalTok{$scheme-main}\InformationTok{: hsl(0, 0%, 4%)}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Particularly, we target the main body color hosted by \texttt{\$scheme-main}. Instead of pointing
to \texttt{\$white}, we change its value to the default \texttt{\$black}. We then Compile the new CSS with \texttt{sass}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{css <-}\StringTok{ }\KeywordTok{sass}\NormalTok{(}
  \KeywordTok{sass_layer}\NormalTok{(}
    \DataTypeTok{default =} \KeywordTok{c}\NormalTok{(}
      \StringTok{"$turquoise: #03a4ff;"}\NormalTok{,}
      \StringTok{"$cyan: #e705be;"}\NormalTok{,}
      \StringTok{"$green: #f3d6e9;"}\NormalTok{,}
      \StringTok{"$yellow: #fdaf2c;"}\NormalTok{,}
      \StringTok{"$red: #ff483e;"}\NormalTok{,}
      \StringTok{"$scheme-main: hsl(0, 0%, 10%);"}
      
\NormalTok{    ),}
    \DataTypeTok{rules =} \KeywordTok{sass_file}\NormalTok{(}\DataTypeTok{input =} \KeywordTok{system.file}\NormalTok{(}\StringTok{"sass/bulma/bulma.sass"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{))}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in sass_layer(default = c("$turquoise: #03a4ff;", "$cyan: #e705be;", :
## partial argument match of 'default' to 'defaults'
\end{verbatim}

Finally, we try the new theme in the following app, shown on Figure \ref{fig:sass-bulma-tiles}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#remotes::install_github("RinteRface/shinybulma")}

\KeywordTok{library}\NormalTok{(shinybulma)}

\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{bulmaPage}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(css)),}
    \KeywordTok{bulmaSection}\NormalTok{(}
      \KeywordTok{bulmaTileAncestor}\NormalTok{(}
        \KeywordTok{bulmaTileParent}\NormalTok{(}
          \DataTypeTok{vertical =} \OtherTok{TRUE}\NormalTok{,}
          \KeywordTok{bulmaTileChild}\NormalTok{(}
            \KeywordTok{bulmaTitle}\NormalTok{(}\StringTok{"Tile 1"}\NormalTok{),}
            \KeywordTok{p}\NormalTok{(}\StringTok{"Put some data here"}\NormalTok{),}
            \DataTypeTok{color =} \StringTok{"link"}
\NormalTok{          ),}
          \KeywordTok{bulmaTileChild}\NormalTok{(}
            \KeywordTok{bulmaTitle}\NormalTok{(}\StringTok{"Tile 2"}\NormalTok{),}
            \StringTok{"Hi Bulma!"}\NormalTok{,}
            \DataTypeTok{color =} \StringTok{"danger"}
\NormalTok{          )}
\NormalTok{        ),}
        \KeywordTok{bulmaTileParent}\NormalTok{(}
          \DataTypeTok{vertical =} \OtherTok{TRUE}\NormalTok{,}
          \KeywordTok{bulmaTileChild}\NormalTok{(}
            \KeywordTok{bulmaTitle}\NormalTok{(}\StringTok{"Tile 3"}\NormalTok{),}
            \KeywordTok{p}\NormalTok{(}\StringTok{"Put some data here"}\NormalTok{),}
            \DataTypeTok{color =} \StringTok{"warning"}
\NormalTok{          ),}
          \KeywordTok{bulmaTileChild}\NormalTok{(}
            \KeywordTok{bulmaTitle}\NormalTok{(}\StringTok{"Tile 3"}\NormalTok{),}
\NormalTok{            (}\StringTok{"Put some data here"}\NormalTok{),}
            \DataTypeTok{color =} \StringTok{"info"}
\NormalTok{          )}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/sass-bulma-tiles} \caption{Custom bulma theme}\label{fig:sass-bulma-tiles}
\end{figure}

\hypertarget{beautify-with-fresh}{%
\chapter{\texorpdfstring{Beautify with \texttt{\{fresh\}}}{Beautify with \{fresh\}}}\label{beautify-with-fresh}}

As shown in the previous chapter, Sass is a powerful tool to customize apps in minutes, in addition to
drastically improve code quality, thereby empowering long term maintenance. Some CSS knowledge are required and it may not be that easy to find the corresponding variables to a specific purpose. For instance, would you be able to guess
what Bootstrap 4 variables are required to customize the \texttt{\{bs4Dash\}} template?

In this chapter, as well as in chapter \ref{beautify-with-bootstraplib}, we show more specific tools to
customize Bootstrap (3 or 4 and more) based templates. Let's start with the first one: \texttt{\{fresh\}}.

\href{https://github.com/dreamRs/fresh}{\{fresh\}} is an R package developed by the \href{https://www.dreamrs.fr/}{dreamRs} team, also authors of \href{https://github.com/dreamRs/shinyWidgets}{shinyWidget} and \href{https://github.com/dreamRs/esquisse}{esquisse}. All dreamRs projects are clearly a great source of inspiration to design outstanding Shiny apps, to such an extent that we highly recommend the reader to explore more about their work!

\hypertarget{fresh-the-big-picture}{%
\section{\texorpdfstring{\texttt{\{fresh\}}, the big picture}{\{fresh\}, the big picture}}\label{fresh-the-big-picture}}

\texttt{\{fresh\}} is built on top of \texttt{\{sass\}} and what you see in Figures \ref{fig:bs4Dash-fresh} and \ref{fig:shinydashboardPlus-fresh} may be done in few minutes! To design a new theme, the main function is \texttt{create\_theme()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{create_theme}\NormalTok{(}
\NormalTok{  ...,}
  \DataTypeTok{theme =} \KeywordTok{c}\NormalTok{(}\StringTok{"default"}\NormalTok{, }\StringTok{"cerulean"}\NormalTok{, }\StringTok{"cosmo"}\NormalTok{, }\StringTok{"cyborg"}\NormalTok{, }\StringTok{"darkly"}\NormalTok{, }\StringTok{"flatly"}\NormalTok{, }\StringTok{"journal"}\NormalTok{,}
    \StringTok{"lumen"}\NormalTok{, }\StringTok{"paper"}\NormalTok{, }\StringTok{"readable"}\NormalTok{, }\StringTok{"sandstone"}\NormalTok{, }\StringTok{"simplex"}\NormalTok{, }\StringTok{"slate"}\NormalTok{, }\StringTok{"spacelab"}\NormalTok{,}
    \StringTok{"superhero"}\NormalTok{, }\StringTok{"united"}\NormalTok{, }\StringTok{"yeti"}\NormalTok{),}
  \DataTypeTok{output_file =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{include_assets =} \OtherTok{FALSE}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{theme} allows to import a \href{https://bootswatch.com/}{Bootswatch} CSS theme, you may already know if you ever used \texttt{\{shinythemes\}}. \textbf{output\_file} controls the output. If provided, \texttt{create\_theme()} creates a CSS file at the specified location. Otherwise, it returns a string value containing the compiles CSS. It is useful in a package context where you don't necessarily want to generate a new theme each time. \textbf{\ldots{}} is where we pass a list of CSS variables, through \texttt{bs4Dash\_*} (specific to \texttt{\{bs4Dash\}}), \texttt{adminlte\_*} (for \texttt{\{shinydashboard\}}) or \texttt{bs\_vars\_*} (for classic \texttt{\{shiny\}} apps) functions, which we describe below.

In general, you'll have to call \texttt{use\_theme()} inside the app UI to load the newly generated theme.

\begin{noteblock}
Note that \texttt{\{bs4Dash\}} and \texttt{\{shinydashboardPlus\}} expose a \textbf{freshTheme} parameter, which does handle the provided theme on the fly.

\end{noteblock}

\hypertarget{customize-bs4dash}{%
\subsection{\texorpdfstring{Customize \texttt{\{bs4Dash\}}}{Customize \{bs4Dash\}}}\label{customize-bs4dash}}

In what follows, we explain how to set a blue ocean theme in only few minutes.

\hypertarget{statuses-and-colors}{%
\subsubsection{Statuses and colors}\label{statuses-and-colors}}

In chapter \ref{sass-customize-bs4Dash}, we showed how to change \texttt{\{bs4Dash\}} colors, with few lines of Sass code. Guess what: \texttt{\{fresh\}} makes it even easier! The \texttt{bs4dash\_status()} and \texttt{bs4Dash\_color()} functions allows to overwrite all the default statuses and colors:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{bs4dash_status}\NormalTok{(}
  \DataTypeTok{primary =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{secondary =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{success =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{info =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{warning =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{danger =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{light =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{dark =} \OtherTok{NULL}
\NormalTok{)}

\KeywordTok{bs4dash_color}\NormalTok{(}
  \DataTypeTok{blue =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{lightblue =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{navy =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{cyan =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{teal =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{olive =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{green =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{lime =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{orange =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{yellow =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{fuchsia =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{purple =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{maroon =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{red =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{black =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{gray_x_light =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{gray_600 =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{gray_800 =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{gray_900 =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{white =} \OtherTok{NULL}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

By default, \texttt{primary} is blue but could become green with just one line of code. Do you recall about section \ref{sass-customize-bs4Dash}, where we customized \texttt{\{bs4Dash\}} colors with Sass? Let's try again with \texttt{\{fresh\}}. We first create the new theme, passing it the new colors and inject it inside the previously mentioned \textbf{freshTheme} parameter:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{library}\NormalTok{(bs4Dash)}
\KeywordTok{library}\NormalTok{(fresh)}

\NormalTok{custom_colors_theme <-}\StringTok{ }\KeywordTok{create_theme}\NormalTok{(}
  \KeywordTok{bs4dash_color}\NormalTok{(}
    \DataTypeTok{lightblue =} \StringTok{"#136377"}\NormalTok{,}
    \DataTypeTok{olive =} \StringTok{"#d8bc66"}\NormalTok{,}
    \DataTypeTok{lime =} \StringTok{"#fcec0c"}\NormalTok{,}
    \DataTypeTok{orange =} \StringTok{"#978d01"}\NormalTok{,}
    \DataTypeTok{maroon =} \StringTok{"#58482c"}\NormalTok{,}
    \DataTypeTok{gray_x_light =} \StringTok{"#d1c5c0"}
\NormalTok{  )}
\NormalTok{)}


\NormalTok{ui <-}\StringTok{ }\KeywordTok{dashboardPage}\NormalTok{(}
  \DataTypeTok{freshTheme =}\NormalTok{ custom_colors_theme,}
  \KeywordTok{dashboardHeader}\NormalTok{(}\DataTypeTok{title =} \StringTok{"Custom colors"}\NormalTok{),}
  \KeywordTok{dashboardSidebar}\NormalTok{(),}
  \KeywordTok{dashboardBody}\NormalTok{(}
    \CommentTok{# Boxes need to be put in a row (or column)}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{box}\NormalTok{(}
        \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
        \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"plot1"}\NormalTok{, }\DataTypeTok{height =} \DecValTok{250}\NormalTok{), }
        \DataTypeTok{status =} \StringTok{"olive"}
\NormalTok{      ),}
      \KeywordTok{box}\NormalTok{(}
        \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
        \DataTypeTok{status =} \StringTok{"lightblue"}\NormalTok{,}
        \DataTypeTok{title =} \StringTok{"Controls"}\NormalTok{,}
        \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"slider"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{50}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
  \KeywordTok{set.seed}\NormalTok{(}\DecValTok{122}\NormalTok{)}
\NormalTok{  histdata <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{500}\NormalTok{)}

\NormalTok{  output}\OperatorTok{$}\NormalTok{plot1 <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
\NormalTok{    data <-}\StringTok{ }\NormalTok{histdata[}\KeywordTok{seq_len}\NormalTok{(input}\OperatorTok{$}\NormalTok{slider)]}
    \KeywordTok{hist}\NormalTok{(data)}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{warningbox}
Note that complex variable names like \texttt{gray-x-light} become \texttt{gray\_x\_light}!

\end{warningbox}

Compared to the approach described in \ref{sass-customize-bs4Dash}, there a few advantages:

\begin{itemize}
\tightlist
\item
  We don't have to specify the \texttt{AdminLTE.scss} location, as \texttt{\{fresh\}} hosts it \href{https://github.com/dreamRs/fresh/tree/master/inst/assets/AdminLTE-3.1.0}{here}.
\item
  We don't have to look for all colors names as they are described along the \texttt{bs4dash\_color} function definition. We even have a description of the default values (as well as statuses in bold), depicted on Figure \ref{fig:fresh-colors-defaults} below.
\end{itemize}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/fresh-colors-defaults} \caption{Default colors provided by {bs4Dash}}\label{fig:fresh-colors-defaults}
\end{figure}

Corporate users will, with no doubt, appreciate that feature that enable to set up a custom internal theme in minutes.

\hypertarget{general-layout}{%
\subsubsection{General Layout}\label{general-layout}}

\texttt{bs4Dash\_layout} exposes variables to control the sidebar width when expanded or collapsed, the sidebar padding, the controlbar width, the main background color and the main content padding. For the blue ocean theme, we change the body background color passing a new value to the \texttt{main\_bg} variable, as below (Figure \ref{fig:fresh-bs4Dash-bodybg}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{layout_vars <-}\StringTok{ }\KeywordTok{bs4dash_layout}\NormalTok{(}\DataTypeTok{main_bg =} \StringTok{"#006994"}\NormalTok{)}
\NormalTok{ocean_theme <-}\StringTok{ }\KeywordTok{create_theme}\NormalTok{(layout_vars)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/fresh-bs4Dash-bodybg} \caption{Customized body background color}\label{fig:fresh-bs4Dash-bodybg}
\end{figure}

We acknowledge the result is not yet consistent but it gives a small glimpse about the package capabilities.

\hypertarget{navbar}{%
\subsubsection{Navbar}\label{navbar}}

As illustrated in the \texttt{\{bs4Dash\}} documentation, the \texttt{dashboardHeader()} has two color flavors, that is \texttt{light} and \texttt{dark}. It defaults to \texttt{light}, meaning that icons and text will be displayed with a darker color, for contrast reasons, and inversely. The \texttt{\{bs4Dash\}} \href{https://dgranjon.shinyapps.io/bs4DashDemo/}{gallery} quite well illustrates this property.

Navbar variables may be found with \texttt{search\_vars\_bs4dash("navbar")}, for example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(tibble)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: package 'tibble' was built under R version 3.6.2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(}\KeywordTok{as_tibble}\NormalTok{(}\KeywordTok{search_vars_bs4dash}\NormalTok{(}\StringTok{"navbar"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 3
##   variable                  value                                       source  
##   <chr>                     <chr>                                       <chr>   
## 1 navbar-nav-link-padding-x 1rem                                        bootstr~
## 2 navbar-brand-font-size    $font-size-lg                               bootstr~
## 3 navbar-brand-height       $navbar-brand-font-size * $line-height-base bootstr~
## 4 navbar-toggler-padding-y  .25rem                                      bootstr~
## 5 navbar-toggler-padding-x  .75rem                                      bootstr~
## 6 navbar-toggler-font-size  $font-size-lg                               bootstr~
\end{verbatim}

We'll be using the \texttt{navbar\_light\_*} variables as follows:

\begin{itemize}
\tightlist
\item
  The navbar color is determined by the \texttt{navbar-light} class. We change the global \texttt{light} status value to the brand new ocean blue with \texttt{bs4dash\_status()}.
\item
  \texttt{navbar\_light\_color} set the navbar text and icon elements to white (\texttt{\#fff}). It is the best choice given the background color we want to apply.
\end{itemize}

We also modified the \texttt{primary} status to be a shade of green:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{navbar_vars <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \KeywordTok{bs4dash_status}\NormalTok{(}\DataTypeTok{light =} \StringTok{"#005475"}\NormalTok{, }\DataTypeTok{primary =} \StringTok{"#00755c"}\NormalTok{), }\CommentTok{# navbar background}
  \KeywordTok{bs4dash_vars}\NormalTok{(}\DataTypeTok{navbar_light_color =} \StringTok{"#fff"}\NormalTok{) }\CommentTok{# put toggler in white}
\NormalTok{)}
\NormalTok{ocean_theme <-}\StringTok{ }\KeywordTok{create_theme}\NormalTok{(layout_vars, navbar_vars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: Using custom variables with bs4dash SCSS files
\end{verbatim}

\hypertarget{text-color-1}{%
\subsubsection{Text color}\label{text-color-1}}

The card text element would not properly be styled without setting the \texttt{white} color to
the global ocean blue theme color, as they would render dark, which is a bad contrast option. Hence, we change the \texttt{white} and \texttt{gray\_900} colors with \texttt{bs4dash\_color()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{inverted_colors <-}\StringTok{ }\KeywordTok{bs4dash_color}\NormalTok{(}\DataTypeTok{gray_900 =} \StringTok{"#fff"}\NormalTok{, }\DataTypeTok{white =} \StringTok{"#005475"}\NormalTok{)}
\NormalTok{ocean_theme <-}\StringTok{ }\KeywordTok{create_theme}\NormalTok{(layout_vars, navbar_vars, inverted_colors)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: Using custom variables with bs4dash SCSS files
\end{verbatim}

\hypertarget{color-contrast}{%
\subsubsection{Color contrast}\label{color-contrast}}

\texttt{bs4dash\_yiq()} fine tunes the \href{https://getbootstrap.com/docs/4.0/getting-started/theming/\#color-contrast}{contrast} between a given color and its background. It relies on the Bootstrap 4 \texttt{color-yiq} function, whose code may be found \href{https://github.com/dreamRs/fresh/blob/master/inst/assets/bootstrap-4.5.2/_functions.scss\#L70}{below}. Interested readers will have a look at the following \href{https://en.wikipedia.org/wiki/Luma_(video)}{article}, that explain better where this calculation is derived from.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{@function}\NormalTok{ color-yiq}\FunctionTok{(}\NormalTok{$color}\OperatorTok{,}\NormalTok{ $dark: $yiq-text-dark}\OperatorTok{,}\NormalTok{ $light: $yiq-text-light}\FunctionTok{)}\NormalTok{ \{}
\NormalTok{  $r: red}\FunctionTok{(}\NormalTok{$color}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  $g: green}\FunctionTok{(}\NormalTok{$color}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  $b: blue}\FunctionTok{(}\NormalTok{$color}\FunctionTok{)}\OperatorTok{;}

\NormalTok{  $yiq: (($r * }\DecValTok{299}\NormalTok{) + ($g * }\DecValTok{587}\NormalTok{) + ($b * }\DecValTok{114}\NormalTok{)) / }\DecValTok{1000}\OperatorTok{;}

  \ImportTok{@if}\NormalTok{ ($yiq >= $yiq-contrasted-threshold) \{}
    \ImportTok{@return}\NormalTok{ $dark}\OperatorTok{;}
\NormalTok{  \} }\ImportTok{@else}\NormalTok{ \{}
    \ImportTok{@return}\NormalTok{ $light}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The function has three major steps:

\begin{itemize}
\tightlist
\item
  Given a color, we extract its three components in the rgb space.
\item
  The \texttt{yiq} value is computed from these contributions, according to the above formula.
\item
  The threshold determines the final color value. If \texttt{yiq} is higher than the threshold, the color is black, and white otherwise.
\end{itemize}

As an example, let's apply this to the default AdminLTE3 primary color \texttt{\#0073b7}, with a threshold value of 150. We included an extra parameters to the \texttt{color-yiq} function, that represents the threshold value (defaulting to 150).

We utilize knowledge from Chapter \ref{beautify-sass}, particularly, the \texttt{sass\_layer()} function to separate functions/mixins from rules and defaults:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{color_yiq <-}\StringTok{ "@function color-yiq($color, $threshold: 150, $dark: $yiq-text-dark, $light: $yiq-text-light) \{}
\StringTok{  $r: red($color);}
\StringTok{  $g: green($color);}
\StringTok{  $b: blue($color);}

\StringTok{  $yiq: (($r * 299) + ($g * 587) + ($b * 114)) / 1000;}

\StringTok{  @if ($yiq >= $threshold) \{}
\StringTok{    @return $dark;}
\StringTok{  \} @else \{}
\StringTok{    @return $light;}
\StringTok{  \}}
\StringTok{\}"}

\NormalTok{background <-}\StringTok{ "}
\StringTok{  $bg: #0073b7 !default;}
\StringTok{  $yiq-text-dark: #111 !default;}
\StringTok{  $yiq-text-light: #fff !default;}
\StringTok{"}
\NormalTok{test_contrast <-}\StringTok{ ".test \{ background: color-yiq($bg); \}"}
\KeywordTok{sass}\NormalTok{(}
  \KeywordTok{sass_layer}\NormalTok{(}
    \DataTypeTok{default =}\NormalTok{ background,}
    \DataTypeTok{declarations =}\NormalTok{ color_yiq,}
    \DataTypeTok{rules =}\NormalTok{ test_contrast}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in sass_layer(default = background, declarations = color_yiq, rules =
## test_contrast): partial argument match of 'default' to 'defaults'
\end{verbatim}

Wait a moment: \texttt{bs4dash\_yiq()} does not expose any \texttt{color} parameter! Indeed, the color is already implicitly applied by the AdminLTE Sass code.

As a last example, we design an app with a slider input controlling the contrast threshold and a radio input color picker to set the \texttt{box} current status color. We dynamically call \texttt{bs4dash\_yiq()} and \texttt{create\_theme}, with an initial threshold of 150 (Bootstrap default) and a dark and light values set to primary and white, respectively. The initial status is primary (blue), and as shown above, we expect the \texttt{yiq} value to be lower than the threshold since the blue color has a relatively light weight for the calculation, thereby fixing the background text color to white. As an exercise, you may try to reduce the threshold until the text becomes black. What is the threshold value. Then, replace the card status from \texttt{primary} to \texttt{warning}. What happens? Why? As yellow is made of green and red, which have the highest contributions in the yiq calculation, this result is not surprising!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{statuses <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"primary"}\NormalTok{ =}\StringTok{ "#0073b7"}\NormalTok{,}
  \StringTok{"secondary"}\NormalTok{ =}\StringTok{ "#6c757d"}\NormalTok{,}
  \StringTok{"success"}\NormalTok{ =}\StringTok{ "#28a745"}\NormalTok{,}
  \StringTok{"info"}\NormalTok{ =}\StringTok{ "#17a2b8"}\NormalTok{,}
  \StringTok{"warning"}\NormalTok{ =}\StringTok{ "#ffc107"}\NormalTok{,}
  \StringTok{"danger"}\NormalTok{ =}\StringTok{ "#dc3545"}
\NormalTok{)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{dashboardPage}\NormalTok{(}
  \KeywordTok{dashboardHeader}\NormalTok{(}\DataTypeTok{title =} \StringTok{"Card with custom contrast"}\NormalTok{),}
  \KeywordTok{dashboardSidebar}\NormalTok{(),}
  \KeywordTok{dashboardBody}\NormalTok{(}
    \CommentTok{# Boxes need to be put in a row (or column)}
    \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"sass"}\NormalTok{),}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{sliderInput}\NormalTok{(}
          \StringTok{"threshold"}\NormalTok{, }
          \StringTok{"Threshold"}\NormalTok{, }
          \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }
          \DataTypeTok{max =} \DecValTok{255}\NormalTok{, }
          \DataTypeTok{value =} \DecValTok{150}
\NormalTok{        ),}
\NormalTok{      shinyWidgets}\OperatorTok{::}\KeywordTok{colorSelectorInput}\NormalTok{(}
        \DataTypeTok{inputId =} \StringTok{"status"}\NormalTok{,}
        \DataTypeTok{label =} \StringTok{"Card Status color"}\NormalTok{,}
        \DataTypeTok{choices =}\NormalTok{ statuses}
\NormalTok{      )}
\NormalTok{    ),}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{box}\NormalTok{(}
        \DataTypeTok{id =} \StringTok{"mybox"}\NormalTok{,}
        \DataTypeTok{solidHeader =} \OtherTok{TRUE}\NormalTok{,}
        \DataTypeTok{title =} \StringTok{"You can see me!"}\NormalTok{,}
        \DataTypeTok{status =} \StringTok{"primary"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{status, \{}
\NormalTok{    status_name <-}\StringTok{ }\KeywordTok{names}\NormalTok{(}\KeywordTok{which}\NormalTok{(statuses }\OperatorTok{==}\StringTok{ }\NormalTok{input}\OperatorTok{$}\NormalTok{status))}
    \KeywordTok{updateBox}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"mybox"}\NormalTok{, }
      \DataTypeTok{action =} \StringTok{"update"}\NormalTok{, }
      \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{status =}\NormalTok{ status_name)}
\NormalTok{    )}
\NormalTok{  \})}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{sass <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
    \KeywordTok{use_theme}\NormalTok{(}\KeywordTok{css}\NormalTok{())}
\NormalTok{  \})}
\NormalTok{  css <-}\StringTok{ }\KeywordTok{reactive}\NormalTok{(\{}
    \CommentTok{# Recover the hex code since bs4dash_yiq does not accept names}
    
    \KeywordTok{create_theme}\NormalTok{(}
      \KeywordTok{bs4dash_yiq}\NormalTok{(}
        \DataTypeTok{contrasted_threshold =}\NormalTok{ input}\OperatorTok{$}\NormalTok{threshold, }
        \DataTypeTok{text_dark =} \StringTok{"#111"}\NormalTok{, }
        \DataTypeTok{text_light =}\StringTok{"#fff"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The output is shown Figure \ref{fig:color-contrast-yiq}

\textbackslash begin\{figure\}
\includegraphics[width=1\linewidth]{images/beautify/color-contrast-yiq} \textbackslash caption\{bs4dash\_yiq in action\}\label{fig:color-contrast-yiq}
\textbackslash end\{figure\}

\hypertarget{sidebar}{%
\subsubsection{Sidebar}\label{sidebar}}

Like \texttt{dashboardHeader()}, \texttt{dashboardSidebar()} exposes two flavors, namely \texttt{light} and \texttt{dark}. Since we set the sidebar to be \texttt{light}, we leverage the \texttt{bs4Dash\_sidebar\_light} helper. We set the main background (\texttt{bg} variable) to ocean blue and set the menu color (\texttt{color} variable) to white, so as to have a better contrast. Additionally, we invert the \texttt{text\_dark} and \texttt{text\_light} colors for an even better contrast with \texttt{bs4dash\_yiq()}. In short, the higher the \texttt{contrasted\_threshold} parameter the less sensitive is the change.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sidebar_vars <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \KeywordTok{bs4dash_yiq}\NormalTok{(}\DataTypeTok{contrasted_threshold =} \DecValTok{10}\NormalTok{, }\DataTypeTok{text_dark =} \StringTok{"#FFF"}\NormalTok{, }\DataTypeTok{text_light =} \StringTok{"#272c30"}\NormalTok{),}
  \KeywordTok{bs4dash_sidebar_light}\NormalTok{(}
    \DataTypeTok{bg =} \StringTok{"#005475"}\NormalTok{, }
    \DataTypeTok{color =} \StringTok{"#FFF"}\NormalTok{,}
    \DataTypeTok{hover_color =} \StringTok{"#FFF"}\NormalTok{,}
    \DataTypeTok{submenu_color =} \StringTok{"#FFF"}\NormalTok{, }
    \DataTypeTok{submenu_hover_color =} \StringTok{"#FFF"}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{ocean_theme <-}\StringTok{ }\KeywordTok{create_theme}\NormalTok{(layout_vars, navbar_vars, inverted_colors, sidebar_vars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: Using custom variables with bs4dash SCSS files
\end{verbatim}

As the \texttt{\{fresh\}} theme does not apply to static plots, since they are not HTML element and not part of the DOM, we leverage the \href{https://rstudio.github.io/thematic/}{\texttt{\{thematic\}}} package, that in short, provides a sort of CSS interface for base R plots, ggplot and lattice. Specifically, in the Shiny context, we choose \texttt{thematic\_shiny()}. By default, it sets the appropriate background, foreground and accent colors. The final product is shown Figure \ref{fig:fresh-bs4Dash-final} and may be run with \texttt{customize\_bs4Dash()} from the book side package:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(OSUICode)}
\KeywordTok{customize_bs4Dash}\NormalTok{(ocean_theme)}
\end{Highlighting}
\end{Shaded}

You may notice the inappropriate \texttt{sliderInput} style. This is because it is not a Bootstrap 4 element. In this case, you'll have to create custom CSS rules targeting the slider labels and scale.

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/fresh-bs4Dash-final} \caption{Ocean theme for {bs4Dash}}\label{fig:fresh-bs4Dash-final}
\end{figure}

Below is another example of a custom dark theme, whose code may be found right after Figure \ref{fig:bs4Dash-fresh}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/bs4Dash-fresh} \caption{Few lines of code to create a bs4Dash dark theme!}\label{fig:bs4Dash-fresh}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dark_theme <-}\StringTok{ }\KeywordTok{create_theme}\NormalTok{(}
  \KeywordTok{bs4dash_vars}\NormalTok{(}
    \DataTypeTok{navbar_light_color =} \StringTok{"#bec5cb"}\NormalTok{,}
    \DataTypeTok{navbar_light_active_color =} \StringTok{"#FFF"}\NormalTok{,}
    \DataTypeTok{navbar_light_hover_color =} \StringTok{"#FFF"}
\NormalTok{  ),}
  \KeywordTok{bs4dash_yiq}\NormalTok{(}\DataTypeTok{contrasted_threshold =} \DecValTok{10}\NormalTok{, }\DataTypeTok{text_dark =} \StringTok{"#FFF"}\NormalTok{, }\DataTypeTok{text_light =} \StringTok{"#272c30"}\NormalTok{),}
  \KeywordTok{bs4dash_layout}\NormalTok{(}\DataTypeTok{main_bg =} \StringTok{"#353c42"}\NormalTok{),}
  \KeywordTok{bs4dash_sidebar_dark}\NormalTok{(}
    \DataTypeTok{bg =} \StringTok{"#272c30"}\NormalTok{, }\DataTypeTok{color =} \StringTok{"#bec5cb"}\NormalTok{, }\DataTypeTok{hover_color =} \StringTok{"#FFF"}\NormalTok{,}
    \DataTypeTok{submenu_bg =} \StringTok{"#272c30"}\NormalTok{, }\DataTypeTok{submenu_color =} \StringTok{"#FFF"}\NormalTok{, }\DataTypeTok{submenu_hover_color =} \StringTok{"#FFF"}
\NormalTok{  ),}
  \KeywordTok{bs4dash_status}\NormalTok{(}\DataTypeTok{dark =} \StringTok{"#272c30"}\NormalTok{),}
  \KeywordTok{bs4dash_color}\NormalTok{(}\DataTypeTok{gray_900 =} \StringTok{"#FFF"}\NormalTok{, }\DataTypeTok{white =} \StringTok{"#272c30"}\NormalTok{)}
\NormalTok{)}

\KeywordTok{customize_bs4Dash}\NormalTok{(dark_theme)}
\end{Highlighting}
\end{Shaded}

\hypertarget{customize-shinydashboard}{%
\subsection{\texorpdfstring{Customize \texttt{\{shinydashboard\}}}{Customize \{shinydashboard\}}}\label{customize-shinydashboard}}

Similarly, \texttt{\{fresh\}} supports \texttt{\{shinydashboard\}} powered apps. In few lines of code, you may definitely provide a cyberpunk look and feel to your favorite shiny dashboard (Figure \ref{fig:shinydashboardPlus-fresh}). \texttt{\{shinydashboardPlus\}} (\href{https://rinterface.github.io/shinydashboardPlus/articles/more-skins.html\#fresh}{v2}) has a plug and play support for \texttt{\{fresh\}} where the theme has to be passed to the \texttt{dashboardPage} \emph{freshTheme} parameter (it would also seamlessly work with \texttt{\{shinydashboard\}}). We start by creating the theme with \texttt{adminlte\_colors()}, \texttt{adminlte\_sidebar()} and \texttt{adminlte\_global()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cyberpunk_theme <-}\StringTok{ }\KeywordTok{create_theme}\NormalTok{(}
  \KeywordTok{adminlte_color}\NormalTok{(}
    \DataTypeTok{green =} \StringTok{"#3fff2d"}\NormalTok{,}
    \DataTypeTok{blue =} \StringTok{"#2635ff"}\NormalTok{,}
    \DataTypeTok{red =} \StringTok{" #ff2b2b"}\NormalTok{,}
    \DataTypeTok{yellow =} \StringTok{"#feff6e"}\NormalTok{,}
    \DataTypeTok{fuchsia =} \StringTok{"#ff5bf8"}\NormalTok{,}
    \DataTypeTok{navy =} \StringTok{"#374c92"}\NormalTok{,}
    \DataTypeTok{purple =} \StringTok{"#615cbf"}\NormalTok{,}
    \DataTypeTok{maroon =} \StringTok{"#b659c9"}\NormalTok{,}
    \DataTypeTok{light_blue =} \StringTok{"#5691cc"}
\NormalTok{  ),}
  \KeywordTok{adminlte_sidebar}\NormalTok{(}
    \DataTypeTok{dark_bg =} \StringTok{"#D8DEE9"}\NormalTok{,}
    \DataTypeTok{dark_hover_bg =} \StringTok{"#81A1C1"}\NormalTok{,}
    \DataTypeTok{dark_color =} \StringTok{"#2E3440"}
\NormalTok{  ),}
  \KeywordTok{adminlte_global}\NormalTok{(}
    \DataTypeTok{content_bg =} \StringTok{"#aaaaaa"}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The demonstration may be run with, the result being shown on Figure \ref{fig:shinydashboardPlus-fresh}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{customize_shinydashboard}\NormalTok{(cyberpunk_theme)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/cyberpunk_shinydashboard} \caption{Cyberpunk shinydashboard}\label{fig:shinydashboardPlus-fresh}
\end{figure}

\hypertarget{beautify-with-bootstraplib}{%
\chapter{\texorpdfstring{Beautify with \texttt{\{bslib\}}}{Beautify with \{bslib\}}}\label{beautify-with-bootstraplib}}

\texttt{\{bslib\}} \citep{R-bslib} is a package developed by RStudio. It is built on top \texttt{\{sass\}} like \texttt{\{fresh\}} \citep{R-fresh}.

\hypertarget{disclaimer}{%
\section{Disclaimer}\label{disclaimer}}

\begin{importantblock}
This feature requires \href{https://blog.rstudio.com/2021/02/01/shiny-1-6-0/}{\texttt{\{shiny\}\ \textgreater{}=\ 1.6.0}}.

\end{importantblock}

\hypertarget{plug-and-play-customization}{%
\section{Plug and play customization}\label{plug-and-play-customization}}

Like \texttt{\{fresh\}}, \texttt{\{bslib\}} offers a high level set of functions allowing to quickly customize shiny apps. For many users, this step will be enough. \texttt{bs\_theme()} seamlessly modifies the main CSS properties like:

\begin{itemize}
\tightlist
\item
  The background color, namely \texttt{bg}.
\item
  The foreground color, namely \texttt{fg}.
\item
  Change default theme colors, also called \href{https://getbootstrap.com/docs/4.1/utilities/colors/}{accents}.
\item
  Modify the \href{https://rstudio.github.io/bslib/articles/theming.html\#main-colors-fonts}{font}. This leverages the \texttt{font\_google()}, \texttt{font\_face()} and \texttt{font\_link()} functions. In practice, \texttt{font\_google()} caches the font resources so that they are always available to the user.
\end{itemize}

Additionally, it gives the flexibility to choose Bootstrap version with \texttt{version\_default()}. As shown in Chapter \ref{web-dependencies}, Shiny primarily relies on Bootstrap 3. This function has 3 flavors:

\begin{itemize}
\tightlist
\item
  Bootstrap 3, with \texttt{"3"}.
\item
  Bootstrap 4 + compatibility with Bootstrap 3, with \texttt{"4"}.
\end{itemize}

Advanced users appreciate a \texttt{...} slot to add extra variables through \texttt{bs\_add\_variables()}, with literally hundreds of choices.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(bslib)}

\KeywordTok{bs_theme}\NormalTok{(}
  \DataTypeTok{version =} \KeywordTok{version_default}\NormalTok{(),}
  \DataTypeTok{bootswatch =} \OtherTok{NULL}\NormalTok{,}
\NormalTok{  ...,}
  \DataTypeTok{bg =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{fg =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{primary =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{secondary =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{success =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{info =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{warning =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{danger =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{base_font =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{code_font =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{heading_font =} \OtherTok{NULL}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{bs\_update\_theme()} is able to update a give theme object, generated with \texttt{bs\_theme()}.

At any time, developers may preview to resulting theme with \texttt{bs\_theme\_preview()}, passing the newly created theme as main parameter. For instance:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\NormalTok{neon_theme <-}\StringTok{ }\KeywordTok{bs_theme}\NormalTok{(}
  \DataTypeTok{bg =} \StringTok{"#000000"}\NormalTok{, }
  \DataTypeTok{fg =} \StringTok{"#FFFFFF"}\NormalTok{, }
  \DataTypeTok{primary =} \StringTok{"#9600FF"}\NormalTok{, }
  \DataTypeTok{secondary =} \StringTok{"#1900A0"}\NormalTok{,}
  \DataTypeTok{success =} \StringTok{"#38FF12"}\NormalTok{,}
  \DataTypeTok{info =} \StringTok{"#00F5FB"}\NormalTok{,}
  \DataTypeTok{warning =} \StringTok{"#FFF100"}\NormalTok{,}
  \DataTypeTok{danger =} \StringTok{"#FF00E3"}\NormalTok{,}
  \DataTypeTok{base_font =} \StringTok{"Marker Felt"}\NormalTok{,}
  \DataTypeTok{heading_font =} \StringTok{"Marker Felt"}\NormalTok{,}
  \DataTypeTok{code_font =} \StringTok{"Chalkduster"}
\NormalTok{)}
\KeywordTok{bs_theme_preview}\NormalTok{(neon_theme, }\DataTypeTok{with_themer =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This gives the result shown in Figure \ref{fig:bootstraplib-theme-preview}.

\textbackslash begin\{figure\}
\includegraphics[width=1\linewidth]{images/beautify/bootstraplib-theme-preview} \textbackslash caption\{bs\_theme\_preview feature in action\}\label{fig:bootstraplib-theme-preview}
\textbackslash end\{figure\}

Passing \texttt{with\_themer\ =\ TRUE} will show a live theming tools to modify the current theme.

Let's try with another example. We would like to bring a refreshment to the Bootstrap UI elements with one of the most modern UI kit to date, namely \href{https://jdan.github.io/98.css/}{98.css}, a windows 98 CSS kit. The CSS assets may be accessed from \href{https://cdn.jsdelivr.net/npm/98.css@0.1.16/dist/98.min.css}{jsdelivr}, as shown below. \texttt{\{bslib\}} exposes neat tools to import extra CSS in the current theme, such as \texttt{bs\_add\_rules()}, which calls \texttt{sass::sass\_file()} under the hood:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{theme }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{bs_add_rules}\NormalTok{(}
    \StringTok{'@import "https://cdn.jsdelivr.net/npm/98.css@0.1.16/dist/98.min.css"'}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

The three theme colors are \texttt{\#c0c0c0} for the background and all colors (except primary), \texttt{\#03158b} for primary and \texttt{\#222222} for the text. We also disable the rounded option so that button borders stay squared.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{windows98_theme <-}\StringTok{ }\KeywordTok{bs_theme}\NormalTok{(}
  \DataTypeTok{bg =} \StringTok{"#c0c0c0"}\NormalTok{, }
  \DataTypeTok{fg =} \StringTok{"#222222"}\NormalTok{, }
  \DataTypeTok{primary =} \StringTok{"#03158b"}\NormalTok{,}
  \DataTypeTok{base_font =} \KeywordTok{c}\NormalTok{(}\StringTok{"Times"}\NormalTok{, }\StringTok{"Arial"}\NormalTok{), }
  \DataTypeTok{secondary =} \StringTok{"#c0c0c0"}\NormalTok{, }
  \DataTypeTok{success =} \StringTok{"#c0c0c0"}\NormalTok{, }
  \DataTypeTok{danger =} \StringTok{"#c0c0c0"}\NormalTok{, }
  \DataTypeTok{info =} \StringTok{"#c0c0c0"}\NormalTok{, }
  \DataTypeTok{light =} \StringTok{"#c0c0c0"}\NormalTok{, }
  \DataTypeTok{dark =} \StringTok{"#c0c0c0"}\NormalTok{, }
  \DataTypeTok{warning =} \StringTok{"#c0c0c0"}\NormalTok{,}
  \StringTok{"font-size-base"}\NormalTok{ =}\StringTok{ "0.75rem"}\NormalTok{, }
  \StringTok{"enable-rounded"}\NormalTok{ =}\StringTok{ }\OtherTok{FALSE}
\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{bs_add_rules}\NormalTok{(}
    \StringTok{'@import "https://cdn.jsdelivr.net/npm/98.css@0.1.16/dist/98.min.css"'}
\NormalTok{  ) }

\NormalTok{windows98_theme }\OperatorTok{%>%}\StringTok{ }\KeywordTok{bs_theme_preview}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

When you run the above demonstration, you'll notice that the slider input is not properly
styled. It's not surprising since the slider is not shaped by Bootstrap but \href{http://ionden.com/a/plugins/ion.rangeSlider/}{Ion.RangeSlider}. Therefore, if you want a better appearance, like in \href{https://jdan.github.io/98.css/\#slider}{98.css}, we would need extra work. The output is shown Figure \ref{fig:bslib-windows-98}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/beautify/bslib-windows-98} \caption{Modern Windows 98 theme for Shiny}\label{fig:bslib-windows-98}
\end{figure}

\hypertarget{dynamic-theming}{%
\section{Dynamic theming}\label{dynamic-theming}}

Now, let's say you design an app and want to give the choice between the vanilla shiny design and your new cyberpunk theme, created in the previous section. We leverage the new \texttt{session\$setCurrentTheme} tool that allows to pass \texttt{\{bslib\}} generated themes to JavaScript through the session object. Our Shiny app contains a toggle, which value is either TRUE or FALSE. On the JavaScript side, we first create a custom shiny input with \texttt{Shiny.setInputValue} that get the current mode value from the toggle. If TRUE, then the custom theme is applied by \texttt{session\$setCurrentTheme} in an \texttt{observeEvent}.

Like for \texttt{\{fresh\}}, the \texttt{\{bslib\}} theme does not apply to static plots (they are not HTML elements). Therefore we leverage \texttt{\{thematic\}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(thematic)}

\NormalTok{theme_toggle <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"custom-control custom-switch"}\NormalTok{, }
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{input}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"custom_mode"}\NormalTok{, }\DataTypeTok{type =} \StringTok{"checkbox"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"custom-control-input"}\NormalTok{,}
      \DataTypeTok{onclick =} \KeywordTok{HTML}\NormalTok{(}\StringTok{"Shiny.setInputValue('dark_mode', document.getElementById('custom_mode').value);"}\NormalTok{)}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{label}\NormalTok{(}
      \StringTok{"Custom mode?"}\NormalTok{, }\StringTok{`}\DataTypeTok{for}\StringTok{`}\NormalTok{ =}\StringTok{ "custom_mode"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"custom-control-label"}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{default <-}\StringTok{ }\KeywordTok{bs_theme}\NormalTok{()}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{theme =}\NormalTok{ default, }
  \KeywordTok{theme_toggle}\NormalTok{(),}
  \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
    \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{  ),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{custom_mode, \{}
\NormalTok{    session}\OperatorTok{$}\KeywordTok{setCurrentTheme}\NormalTok{(}
      \ControlFlowTok{if}\NormalTok{ (input}\OperatorTok{$}\NormalTok{custom_mode) neon_theme }\ControlFlowTok{else}\NormalTok{ default}
\NormalTok{    )}
\NormalTok{  \})}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{2}\NormalTok{)}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{thematic_shiny}\NormalTok{()}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\textbf{Note}: An issue with \texttt{shiny::bindCache} described \href{https://github.com/rstudio/shiny/issues/3208}{here}, with shiny 1.6.

\hypertarget{custom-elements}{%
\section{Custom elements}\label{custom-elements}}

For other elements than core shiny components like \texttt{numericInput} or \texttt{\{thematic\}} compatible elements such as \texttt{plotOutput},
\texttt{\{bslib\}} provides tools to create dynamically themeable custom components.

Let's take the example of a simple card where the Sass code is defined below:

\begin{itemize}
\tightlist
\item
  \texttt{.supercard} has a shadow, takes half of the page width and has a fixed height.
  Notice the \texttt{background-color} that takes the value of the \texttt{\$primary} SAAS variable,
  inherited from Bootstrap 4.
\item
  \texttt{.supercard\_body} adds padding to the card body content.
\end{itemize}

\begin{verbatim}
.supercard {
    box-shadow: 0 4px 10px 0 rgb(0, 0, 0), 0 4px 20px 0 rgb(0, 0, 0);
    width: 50%;
    height: 200px;
    background-color: $primary;
    
    .supercard_body {
      padding: 0.01em 16px;
    }
}
\end{verbatim}

Below, for convenience, we put that Sass code inside a R string, even though best practice would
be to save it in a file and compile it with \texttt{sass::sass\_file}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sass_str <-}\StringTok{ "}
\StringTok{  .supercard \{}
\StringTok{    box-shadow: 0 4px 10px 0 rgb(0, 0, 0), 0 4px 20px 0 rgb(0, 0, 0);}
\StringTok{    width: 50%;}
\StringTok{    height: 200px;}
\StringTok{    }
\StringTok{    background-color: $primary;}
\StringTok{    .supercard_body \{}
\StringTok{      padding: 0.01em 16px;}
\StringTok{    \}}
\StringTok{\}"}
\end{Highlighting}
\end{Shaded}

If you try to run \texttt{sass::sass(input\ =\ sass\_str)},
it will fail, as \texttt{\$primary} is not defined. Now the goal is to link this custom Sass code
to the main app theme, created with \texttt{bs\_theme}. We leverage the \texttt{bs\_dependency} function where:

\begin{itemize}
\tightlist
\item
  \texttt{input} refers to a list of Sass rules, that is \texttt{sass\_str} in our example.
\item
  \texttt{theme} is a theme generated with \texttt{bs\_theme}.
\item
  \texttt{name} and \texttt{version} are metadata.
\end{itemize}

In case we are not in a \texttt{\{bslib\}} context, ie the app does not pass a \texttt{bs\_theme} element,
we create a fallback containing the card CSS code.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(htmltools)}
\NormalTok{super_card_dependency <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(theme) \{}
  
\NormalTok{  dep_name <-}\StringTok{ "supercard"}
\NormalTok{  dep_version <-}\StringTok{ "1.0.0"}
  
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is_bs_theme}\NormalTok{(theme)) \{}
    \KeywordTok{bs_dependency}\NormalTok{(}
      \DataTypeTok{input =}\NormalTok{ sass_str,}
      \DataTypeTok{theme =}\NormalTok{ theme,}
      \DataTypeTok{name =}\NormalTok{ dep_name,}
      \DataTypeTok{version =}\NormalTok{ dep_version}
\NormalTok{    )}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{htmlDependency}\NormalTok{(}
      \DataTypeTok{name =}\NormalTok{ dep_name,}
      \DataTypeTok{version =}\NormalTok{ dep_version,}
      \DataTypeTok{src =} \StringTok{"supercard-1.0.0/css"}\NormalTok{,}
      \DataTypeTok{stylesheet =} \StringTok{"super-card.css"}\NormalTok{,}
      \DataTypeTok{package =} \StringTok{"OSUICode"}
\NormalTok{    )}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As shown, in Chapter \ref{htmltools-dependencies}, we have to add this dependency to the card
tag. Importantly, we wrap it inside \texttt{bs\_dependency\_defer} that enables us to dynamically update the theme on the server
side, each time \texttt{session\$setCurrentTheme} is invoked.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{super_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"supercard"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"supercard_body"}\NormalTok{, ...),}
    \KeywordTok{bs_dependency_defer}\NormalTok{(super_card_dependency)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We then create two simple theme, namely
white and dark and run the app:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{white_theme <-}\StringTok{ }\KeywordTok{bs_theme}\NormalTok{()}
\NormalTok{dark_theme <-}\StringTok{ }\NormalTok{white_theme }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{bs_theme_update}\NormalTok{(}\DataTypeTok{bg =} \StringTok{"black"}\NormalTok{, }\DataTypeTok{fg =} \StringTok{"white"}\NormalTok{, }\DataTypeTok{primary =} \StringTok{"orange"}\NormalTok{)}


\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{theme =}\NormalTok{ white_theme,}
  \KeywordTok{theme_toggle}\NormalTok{(),}
  \KeywordTok{br}\NormalTok{(),}
  \KeywordTok{super_card}\NormalTok{(}\StringTok{"Hello World!"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{custom_mode, \{}
\NormalTok{    session}\OperatorTok{$}\KeywordTok{setCurrentTheme}\NormalTok{(}
      \ControlFlowTok{if}\NormalTok{ (input}\OperatorTok{$}\NormalTok{custom_mode) dark_theme }\ControlFlowTok{else}\NormalTok{ white_theme}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The reader is invited to exploit the \texttt{run\_with\_themer} capabilities, that allows
to dynamically modify the current them, as shown Figure \ref{fig:bslib-custom-component}.

\textbackslash begin\{figure\}
\includegraphics[width=1\linewidth]{images/beautify/bslib-custom-component} \textbackslash caption\{bs\_theme\_preview with custom component\}\label{fig:bslib-custom-component}
\textbackslash end\{figure\}

Below, we try without passing any theme to \texttt{fluidPage}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}\KeywordTok{super_card}\NormalTok{(}\StringTok{"Hello World!"}\NormalTok{))}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{further-resources}{%
\section{Further resources}\label{further-resources}}

The reader will refer to the \texttt{\{bslib\}} various \href{https://rstudio.github.io/bslib/articles/theming.html}{vignettes}.

\hypertarget{part-unleash-interactivity-with-javascript}{%
\part*{Unleash interactivity with JavaScript}\label{part-unleash-interactivity-with-javascript}}


\hypertarget{survival-kit-javascript}{%
\chapter{JavaScript for Shiny}\label{survival-kit-javascript}}

To understand how Shiny works from inside, especially how inputs are handled, we'll gradually dive into its core which contains a substantial amount of JavaScript (JS).

\begin{warningbox}
This chapter is a very brief introduction to JS and jQuery but still necessary as this book is supposed to be standalone. Advanced JS users may skip this part. If you wish to know more about this language, resources like MDN web docs by Mozilla is an excellent \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript}{resource}.

\end{warningbox}

\hypertarget{shiny-javascript-sources}{%
\section{Shiny JavaScript sources}\label{shiny-javascript-sources}}

\begin{importantblock}
Since commit \href{https://github.com/rstudio/shiny/commit/1b8635db327a753007b1d7d052b138353745d251}{\texttt{1b8635d}},
the whole JS core has been converted to TypeScript, to produce better JS code. As this book was written before these changes, we'll point the user to the code prior to \texttt{1b8635d}, that is this \href{https://github.com/rstudio/shiny/tree/60db1e02b03d8e6fb146c9bb1bbfbce269231add}{state}. Practically, the underlying mechanisms remain \textbf{exactly} the same.

\end{importantblock}

Let's have a look at the \texttt{\{shiny\}} \citep{R-shiny} github \href{https://github.com/rstudio/shiny/tree/60db1e02b03d8e6fb146c9bb1bbfbce269231add}{project}. As a R package, it is composed of standard folders like \texttt{R}, \texttt{man}, \texttt{tests} and other elements. The \texttt{inst} folder contains resources for external dependencies like \href{https://getbootstrap.com/docs/3.3/}{Bootstrap 3}, \href{https://jquery.com/}{jQuery}, \href{https://datatables.net/}{datatables}, \href{https://fontawesome.com/}{fontawesome}, \ldots{} mentioned in Chapter \ref{web-dependencies} sorted in the \texttt{www/shared} sub-folder as well as the whole CSS and JS Shiny codes. Notice the presence of minified files like \texttt{shiny.min.js} and non minified elements such as \texttt{shiny.css}. Overall, the minification process reduces the loading time of a web page by removing comments, extra spaces, thereby decreasing the file size. For instance \texttt{shiny.js} has more than 6500 lines of code (240kb), while \texttt{shiny.min.js} is only 91.4kb.

Notice the \texttt{srcjs/} folder shown in Figure \ref{fig:shiny-js-sources}. It actually contains all pieces to reconstruct the whole \texttt{shiny.js} file.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-js-sources} \caption{Shiny JavaScript sources}\label{fig:shiny-js-sources}
\end{figure}

Since in Chapter \ref{shiny-input-system} we'll use some of those scripts, a little understanding of the basic underlying JavaScript concepts is necessary.

\hypertarget{introduction-to-javascript}{%
\section{Introduction to JavaScript}\label{introduction-to-javascript}}

JavaScript was created in 1995 by Brendan Eich and is also known as ECMAScript (ES). Interestingly, you might have heard about ActionScript, which is no more than an implementation of ES by Adobe Systems. Nowadays, JavaScript is the centerpiece of web development across all websites.

Here is a quick example. If you have a personal blog, you probably know \href{https://gohugo.io/}{Hugo} or \href{https://jekyllrb.com/}{Jekyll}, especially the R interfaces like \href{https://bookdown.org/yihui/blogdown/}{blogdown} \citep{R-blogdown}. These tools allow one to rapidly develop a nice looking blog in just a few minutes, focusing on the content rather than technical aspects, which is really the point! Now, if you open the HTML inspector introduced in Chapter \ref{web-intro-html}, click on the elements tab, which may open by default, and uncollapse the \texttt{\textless{}head\textgreater{}} tag, you see that a lot of scripts are included, as shown in Figure \ref{fig:scripts-list}. Similarly for the \texttt{\textless{}body\textgreater{}} tag.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/scripts-list} \caption{A website is full of JavaScript}\label{fig:scripts-list}
\end{figure}

There are three ways to include scripts in an HTML document:

\begin{itemize}
\tightlist
\item
  Use the \texttt{\textless{}script\textgreater{}} tag with the JS code inside
\item
  Add the \texttt{onclick} attribute to an HTML tag (preferably a button) to trigger JS as soon as it is clicked (This is similar to event listeners, see below)
\item
  Import an external file containing the JS code and only
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<script}\OtherTok{ type=}\StringTok{"text/javascript"}\KeywordTok{>}
\CommentTok{// JS code here}
\KeywordTok{</script>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<button}\OtherTok{ id=}\StringTok{"hello"}\OtherTok{ onclick=}\StringTok{"jsFunction()"}\KeywordTok{>}\NormalTok{Hello World}\KeywordTok{</button>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{<!-- We use the src attribute to link the external file -->}
\KeywordTok{<script}\OtherTok{ type=}\StringTok{"text/javascript"}\OtherTok{ src=}\StringTok{"file.js"}\KeywordTok{>}
\end{Highlighting}
\end{Shaded}

Whether to choose the first, second or third method depends on the content of your script. If we consider the JS library jQuery, it unfortunately contains so much code making it a challenge to understand. This often makes users avoid the first method.

\hypertarget{setup}{%
\section{Setup}\label{setup}}

Like \href{https://www.r-project.org/}{R} or \href{https://www.python.org/}{Python}, JavaScript (JS) is an interpreted language. It is executed client-side, in other words in the browser. This also means that JS code may not be run without a suitable tool. In the following, we'll list some tools to test JS code, even though JS may also be run through the web browser developer tools, as demonstrated in section \ref{shiny-js-inspector}.

\hypertarget{install-node}{%
\subsection{Node}\label{install-node}}

\href{https://nodejs.org/en/}{Node} contains an interpreter for JS as well as a dependencies manager, npm (Node Package Manager). To install Node on your computer, browse to the website and follow the installation instructions. Afterwards, open a terminal and check if

\begin{verbatim}
$ which node
$ node --version
\end{verbatim}

returns something. If not, Node may not be properly \href{https://www.taniarascia.com/how-to-install-and-use-node-js-and-npm-mac-and-windows/}{installed}.

\begin{noteblock}
If you prefer not installing Node, there exists alternatives like \href{https://repl.it/languages/nodejs}{repl.it}, offering a Node.js online compiler environment. This will be more than enough to follow this part.

\end{noteblock}

\hypertarget{choose-a-good-ide}{%
\subsection{Choose a good IDE}\label{choose-a-good-ide}}

Personally, I really like \href{https://code.visualstudio.com}{VSCode} for coding with JS, as it contains a Node interpreter allowing you to seamlessly execute any JS code. As a side note, I encourage you to try the dracula color theme, which is my favorite! As R user, I also like \href{https://rstudio.com/products/rstudio/}{Rstudio IDE}, provided that you have Node installed. Below, we will explain how to run a JS code in both IDE's. In section \ref{shiny-js-inspector}, we will show how to manipulate JS code directly in the web browser, through the HTML inspector. This is the method we will mostly use in the remaining of the book since we will also work with HTML and CSS at the same time.

\hypertarget{first-script}{%
\subsection{First Script}\label{first-script}}

Let's write our first script:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You notice that all instruction end by \texttt{;}. You can run this script either in Rstudio IDE or VSCode.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/script-vscode} \caption{Run JS in VSCode}\label{fig:script-vscode}
\end{figure}

In VSCode, clicking on the run arrow (top center) of Figure \ref{fig:script-vscode}, triggers the \texttt{node\ hello.js} command, which tells Node to run the script. We see the result in the right panel (code=0 means the execution is fine and we even have the compute time). To run this script in the RStudio IDE, one needs to click on the terminal tab (you could also open a basic terminal) and type \texttt{node\ hello.js} (or \texttt{node\ mycustompath/hello.js} if you are not in the folder containing the script). You should see the Hello World message in the console (see Figure \ref{fig:script-rstudio}).

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/script-rstudio} \caption{Run JS in a terminal}\label{fig:script-rstudio}
\end{figure}

\hypertarget{programming-with-js-basis}{%
\section{Programming with JS: basis}\label{programming-with-js-basis}}

We are now all set to introduce the basis of JS. As many languages, JS is made of variables and instructions. All instructions end by the \texttt{;} symbol.

\hypertarget{js-types}{%
\subsection{JS types}\label{js-types}}

JS defines several types:

\begin{itemize}
\tightlist
\item
  Number: does not distinguish between integers and others (in R for instance, numeric contains integers and double)
\item
  String: characters (`blabla')
\item
  Boolean: true/false
\end{itemize}

To check the type of an element, we may use the \texttt{typeof} operator.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof} \DecValTok{1}\OperatorTok{;} \CommentTok{// number}
\KeywordTok{typeof} \StringTok{'pouic'}\OperatorTok{;} \CommentTok{// string}
\end{Highlighting}
\end{Shaded}

\begin{importantblock}
In JS, \texttt{typeof} is not a function like in R!!! Therefore don't write \texttt{typeof(\textquotesingle{}string\textquotesingle{});}.

\end{importantblock}

\hypertarget{variables-1}{%
\subsection{Variables}\label{variables-1}}

Variables are key elements to programming languages. They allow to store intermediate results and do other manipulations. In JS, a variable is defined by:

\begin{itemize}
\tightlist
\item
  a type
\item
  a name
\item
  a value
\end{itemize}

\begin{importantblock}

A valid variable name:

\begin{itemize}
\tightlist
\item
  Doesn't use a reserved JS name like \texttt{typeof}!
\item
  Doesn't start with a number (123soleil)!
\item
  Doesn't include any space (total price)!
\end{itemize}


\end{importantblock}

Besides, code style is a critical element in programming, increasing readability, and general consistence. There are several styles, the main ones being \texttt{snake\_case} and \texttt{camelCase}. I personally use the \texttt{camelCase} syntax to write variables in JS.

There are two ways to create variables in JavaScript.

\hypertarget{const}{%
\subsubsection{Const}\label{const}}

In JavaScript, a variable may be created with \texttt{const}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ n }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{n }\OperatorTok{=} \DecValTok{2}\OperatorTok{;} \CommentTok{// error}
\KeywordTok{const}\NormalTok{ n }\OperatorTok{=} \DecValTok{3}\OperatorTok{;} \CommentTok{// error}
\KeywordTok{const}\NormalTok{ a}\OperatorTok{;}
\NormalTok{a }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// errors}
\end{Highlighting}
\end{Shaded}

As shown above, such variables:

\begin{itemize}
\tightlist
\item
  Cannot be modified
\item
  Cannot share the same name
\item
  Must be assigned a value
\end{itemize}

\hypertarget{let}{%
\subsubsection{let}\label{let}}

Another way to define a variable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ myVariable }\OperatorTok{=} \StringTok{'welcome'}\OperatorTok{;}
\NormalTok{myVariable }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(myVariable)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Then we may use all mathematical operators to manipulate our variables.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ myNumber }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// affectation}
\NormalTok{myNumber}\OperatorTok{--;} \CommentTok{// decrement}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(myNumber)}\OperatorTok{;} \CommentTok{// print 0}
\end{Highlighting}
\end{Shaded}

\begin{noteblock}

List of numerical operators in JS:

\begin{itemize}
\tightlist
\item
  \texttt{+}
\item
  \texttt{-}
\item
  \texttt{*}
\item
  \texttt{/}
\item
  \texttt{\%\ (modulo)}
\item
  \texttt{++} (incrementation)
\item
  \texttt{-\/-} (decrementation)
\end{itemize}


\end{noteblock}

\begin{noteblock}
To concatenate two strings, we use the\texttt{+} symbol.

\end{noteblock}

You may also know \texttt{var} to declare variables. What is the difference with \texttt{let}? It is mainly a scope \href{https://www.w3schools.com/js/js_let.asp}{reason}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ i }\OperatorTok{=} \DecValTok{2}\OperatorTok{;} \CommentTok{// this will modify i globally, not locally}
\OperatorTok{\}}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VerbatimStringTok{`i is }\SpecialCharTok{$\{}\NormalTok{i}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}\OperatorTok{;} \CommentTok{// i is 2.}

\KeywordTok{let}\NormalTok{ j }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ j }\OperatorTok{=} \DecValTok{2}\OperatorTok{;} \CommentTok{// j is only declared locally and not globally!}
\OperatorTok{\}}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VerbatimStringTok{`j is }\SpecialCharTok{$\{}\NormalTok{j}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}\OperatorTok{;} \CommentTok{// j is 1}
\end{Highlighting}
\end{Shaded}

You will see later that we still use \texttt{var} in the shiny core and many other R packages.

\hypertarget{conditions}{%
\subsection{Conditions}\label{conditions}}

Below are the operators to check conditions.

\begin{noteblock}

\begin{itemize}
\tightlist
\item
  \texttt{===} (A equal value, equal type B)
\item
  \texttt{==} (A equal to B)
\item
  \texttt{!==} (A not equal value or not equal type B)
\item
  \texttt{!=} (A not equal to B)
\item
  \texttt{\textgreater{}}, \texttt{\textgreater{}=}
\item
  \texttt{\textless{}}, \texttt{\textless{}=}
\item
  \texttt{AND} (A AND B) or \texttt{\&\&}
\item
  \texttt{OR} (A OR B) or \texttt{\textbar{}\textbar{}}
\end{itemize}


\end{noteblock}

\begin{importantblock}
Importantly, prefer \texttt{===} and \texttt{!==} to compare elements since \texttt{5\ ==\ "5"} would return \texttt{true}, generally not what you want!

\end{importantblock}

To test conditions there exists several ways:

\begin{itemize}
\tightlist
\item
  \texttt{if\ (condition)\ \{\ console.log(\textquotesingle{}Test\ passed\textquotesingle{});\ \}}
\item
  \texttt{if\ (condition)\ \{\ instruction\ A\}\ else\ \{\ instruction\ B\ \}}
\end{itemize}

The ternary operator is a shortcut \texttt{condition\ ?\ instruction\ if\ true\ :\ instruction\ if\ false} that may be chained. For complex instructions, we recommend not using it, as it may affect code readability.

Whenever a lot of possible conditions have to be evaluated, it is better to choose the \texttt{switch}.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch}\NormalTok{ (variable) }\OperatorTok{\{}
  \ControlFlowTok{case} \DataTypeTok{val1}\OperatorTok{:} \CommentTok{// instruction 1}
  \ControlFlowTok{break}\OperatorTok{;} \CommentTok{// don't forget the break!}
  \ControlFlowTok{case} \DataTypeTok{val2}\OperatorTok{:}  \CommentTok{// instruction 2}
  \ControlFlowTok{break}\OperatorTok{;}
  \ControlFlowTok{default}\OperatorTok{:} \CommentTok{// when none of val1 and val2 are satisfied}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{objects}{%
\subsection{Objects}\label{objects}}

JavaScript is an object oriented programming language (like Python). An object is defined by:

\begin{itemize}
\tightlist
\item
  a type
\item
  some properties
\item
  some methods (to manipulate properties)
\end{itemize}

Let's construct our first object:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ me }\OperatorTok{=} \OperatorTok{\{}
  \DataTypeTok{name }\OperatorTok{:} \StringTok{'Divad'}\OperatorTok{,}
  \DataTypeTok{age }\OperatorTok{:} \DecValTok{29}\OperatorTok{,}
  \DataTypeTok{music }\OperatorTok{:} \StringTok{''}\OperatorTok{,}
  \DataTypeTok{printName}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VerbatimStringTok{`I am }\SpecialCharTok{$\{}\KeywordTok{this}\NormalTok{.}\AttributeTok{name}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}

\VariableTok{me}\NormalTok{.}\AttributeTok{geek} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;} \CommentTok{// works (see const variables above)}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VariableTok{JSON}\NormalTok{.}\AttributeTok{stringify}\NormalTok{(me))}\OperatorTok{;} \CommentTok{// print a human readable object.}
  
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VariableTok{me}\NormalTok{.}\AttributeTok{name}\NormalTok{)}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VariableTok{me}\NormalTok{.}\AttributeTok{age}\NormalTok{)}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VariableTok{me}\NormalTok{.}\AttributeTok{music}\NormalTok{)}\OperatorTok{;}
\CommentTok{// don't repeat yourself!!!}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ key }\KeywordTok{in}\NormalTok{ me) }\OperatorTok{\{} \CommentTok{// here is it ok to use `in`}
 \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VerbatimStringTok{`me[}\SpecialCharTok{$\{}\NormalTok{key}\SpecialCharTok{\}}\VerbatimStringTok{] is }\SpecialCharTok{$\{}\NormalTok{me[key]}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}

\VariableTok{me}\NormalTok{.}\AttributeTok{printName}\NormalTok{()}\OperatorTok{;}

\NormalTok{me }\OperatorTok{=} \OperatorTok{\{}
  \DataTypeTok{name}\OperatorTok{:} \StringTok{'Paul'}\OperatorTok{,}
  \DataTypeTok{age}\OperatorTok{:} \DecValTok{40}
\OperatorTok{\}} \CommentTok{// error (see const variables above)}
\end{Highlighting}
\end{Shaded}

Some comments on the above code:

\begin{itemize}
\tightlist
\item
  To access an object property, we use \texttt{object.\textless{}propertiy\_name\textgreater{}}.
\item
  To print a human readable version of the object, \texttt{JSON.stringify} will do the job.
\item
  We introduced string interpolation with \texttt{\$\{*\}}. \texttt{*} may be any valid expression.
\item
  Methods are accessed like properties (we may also pass parameters). We use \texttt{this} to refer to the object itself. Take note, we will see it a lot!
\end{itemize}

In JavaScript, there are already predefined objects to interact with arrays, dates.

\hypertarget{arrays}{%
\subsubsection{Arrays}\label{arrays}}

An array is a structure allowing to store information for instance:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ table }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\OperatorTok{,} \StringTok{'plop'}\NormalTok{]}\OperatorTok{;}
\VariableTok{table}\NormalTok{.}\AttributeTok{push}\NormalTok{(}\StringTok{'hello'}\NormalTok{)}\OperatorTok{;}
\NormalTok{table }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{]}\OperatorTok{;} \CommentTok{// error (as explain in above in the variable part)}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(table)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Array may be nested:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ nested }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\OperatorTok{,}\NormalTok{ [}\StringTok{'a'}\OperatorTok{,}\NormalTok{ [}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{]]}\OperatorTok{,} \StringTok{'plop'}\NormalTok{]}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(nested)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In arrays, elements may be accessed by their index, but as mentioned before, the first index is 0 (not 1 like in R). A convenient way to print all array's elements is to use an iteration:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ nested }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\OperatorTok{,}\NormalTok{ [}\StringTok{'a'}\OperatorTok{,}\NormalTok{ [}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{]]}\OperatorTok{,} \StringTok{'plop'}\NormalTok{]}\OperatorTok{;}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\KeywordTok{of}\NormalTok{ nested) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(i)}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// or with the classic approach}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{<} \VariableTok{nested}\NormalTok{.}\AttributeTok{length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(nested[i])}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Note that the \texttt{length} method returns the size of an array and is very convenient in for loops. Below is a table referencing the principal methods for arrays (we will use some of them later).

\begin{longtable}[]{@{}cc@{}}
\toprule
Method/Property & Description\tabularnewline
\midrule
\endhead
length & Return the number of elements in an array\tabularnewline
Join(string separator) & Transform an array in a string\tabularnewline
concat(array1, array2) & Assemble 2 arrays\tabularnewline
pop() & Remove the last element of an array\tabularnewline
shift() & Remove the first element of an array\tabularnewline
unshift(el1, el2, \ldots) & Insert elements at the beginning of an array\tabularnewline
push(el1, el2, \ldots) & Add extra elements at the end of an array\tabularnewline
sort() & Sort array elements by increasing value of alphabetical order\tabularnewline
reverse() & Symetric of sort()\tabularnewline
\bottomrule
\end{longtable}

Quite honestly, we mainly use \texttt{push} and \texttt{length} in the next chapters.

\hypertarget{strings}{%
\subsubsection{Strings}\label{strings}}

Below are the main methods related to the String object (character in R).

\begin{longtable}[]{@{}cc@{}}
\toprule
Method/Property/Operator & Description\tabularnewline
\midrule
\endhead
+ (operator) & String concatenation\tabularnewline
length & String length\tabularnewline
indexOf() & Gives the position of the character following the input string\tabularnewline
toLowerCase() & Put the string in small letters\tabularnewline
toUpperCase() & Put the string in capital letters\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{math}{%
\subsubsection{Math}\label{math}}

Below we mention some useful methods to handle mathematical objects.

\begin{longtable}[]{@{}cc@{}}
\toprule
Method & Description\tabularnewline
\midrule
\endhead
parseInt() & Convert a string to integer\tabularnewline
parseFloat() & Conversion to floating number\tabularnewline
\bottomrule
\end{longtable}

All classic functions like \texttt{sqrt}, trigonometric functions are of course available. We call them with the \texttt{Math.*} prefix.

\hypertarget{iterations}{%
\subsection{Iterations}\label{iterations}}

Iterations allow to repeat an instruction or a set of instructions multiple times. Let's assume we have an array containing 100000 random numbers. How would you do to automatically print them? This a what we are going to see below!

\hypertarget{for-loops}{%
\subsubsection{For loops}\label{for-loops}}

The for loop has multiple uses. Below is a classic case where we start by defining the index (variable). We then set an upper bound (the array length) and we finish by incrementing the index value. The code between curly braces is then executed.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ table }\OperatorTok{=}\NormalTok{ [...}\AttributeTok{Array}\NormalTok{(}\DecValTok{100}\NormalTok{).}\AttributeTok{keys}\NormalTok{()]}\OperatorTok{;} \CommentTok{// create an empty array of length 100 (so from 0 to 99, not from 1 to 100 like in R!!!)}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{<} \VariableTok{table}\NormalTok{.}\AttributeTok{length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) }\OperatorTok{\{}
    \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(table[i])}\OperatorTok{;} 
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The way we created the array is a bit special and deserves some explanations:

\begin{itemize}
\tightlist
\item
  \texttt{Array} is a method to define a new array. We call it this way \texttt{Array(arrayLength)} since we don't want to write 100 values 1 by 1. But if you try \texttt{console.log(Array(10));} you will get \texttt{{[}\ \textless{}10\ empty\ items\textgreater{}\ {]}}, meaning that 10 slots are available but nothing is inside yet.
\item
  \texttt{keys} defines keys for each table index. As a reminder, since \texttt{Array(10)} is an object (check with \texttt{console.log(typeof\ Array(10));}) we may use \texttt{Array(10).keys()}. This creates an Array Iterator.
\item
  \texttt{...} is a \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax}{spread syntax}, and is called with an iterable object (see above).
\end{itemize}

\begin{importantblock}
Contrary to R, JavaScript index starts from 0 (not from 1)! This is good to keep in mind when we will mix both R and JS.

\end{importantblock}

Let's have a look at the \texttt{forEach} method for arrays (introduced in ES5):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ letters }\OperatorTok{=}\NormalTok{ [}\StringTok{"a"}\OperatorTok{,} \StringTok{"b"}\OperatorTok{,} \StringTok{"c"}\OperatorTok{,} \StringTok{"d"}\NormalTok{]}\OperatorTok{;}
\VariableTok{letters}\NormalTok{.}\AttributeTok{forEach}\NormalTok{((letter) }\KeywordTok{=>} \OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(letter)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Below is another way to create a for loop (introduced in ES6):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ samples }\OperatorTok{=}\NormalTok{ [}\StringTok{'blabla'}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \KeywordTok{null}\NormalTok{]}\OperatorTok{;} \CommentTok{// this is an array!}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ sample }\KeywordTok{of}\NormalTok{ samples) }\OperatorTok{\{}
 \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(sample)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

What \texttt{for} loop should we use? The answer is: it depends on the situation! Actually, there even exists other ways (replace \texttt{of} by \texttt{in} and you get the indexes of the array, like with the first code, but this is really \href{https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/}{not recommended}).

\hypertarget{other-iterations-while}{%
\subsubsection{Other iterations: while}\label{other-iterations-while}}

While loops are another way to iterate, as long as the condition defined is TRUE. The incrementation step is done at the end of the instruction.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ h }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{while}\NormalTok{ (i }\OperatorTok{<=}\NormalTok{ h) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(i)}\OperatorTok{;}
\NormalTok{  i}\OperatorTok{++;} \CommentTok{// we need to increment to avoid infinite loop}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{functions-1}{%
\subsection{Functions}\label{functions-1}}

Functions are useful to wrap a succession of instructions to accomplish a given task. Defining functions allows programmers to save time (less copy and paste, less search and replace), make less errors and easily share code. In modern JavaScript (ES6), functions are defined as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ a }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fun }\OperatorTok{=}\NormalTok{ (parm1}\OperatorTok{,}\NormalTok{ parm2) }\KeywordTok{=>} \OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(a)}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ p }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
  \ControlFlowTok{return} \VariableTok{Math}\NormalTok{.}\AttributeTok{max}\NormalTok{(parm1}\OperatorTok{,}\NormalTok{ parm2)}\OperatorTok{;} \CommentTok{// I use the Math object that contains the max method}
\OperatorTok{\}}
\KeywordTok{let}\NormalTok{ res }\OperatorTok{=} \AttributeTok{fun}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(res)}\OperatorTok{;} \CommentTok{// prints a and 2. a global}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(p)}\OperatorTok{;} \CommentTok{// fails because p was defined inside the function}
\end{Highlighting}
\end{Shaded}

This above functions computes the maximum of 2 provided numbers. Some comments about scoping rules: variables defined inside the function are available for the function, but are not available outside the function definition. It should be noted that functions may use global variables defined outside of it.

\hypertarget{about-js-modules}{%
\subsubsection{Export functions: about modules}\label{about-js-modules}}

What happens if you wrote 100 functions that you want to reuse in different scripts? To prevent copying and pasting, we will now introduce the concept of modules. Let's save the below function in a script \texttt{utils.js}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ findMax }\OperatorTok{=}\NormalTok{ (parm1}\OperatorTok{,}\NormalTok{ parm2) }\KeywordTok{=>} \OperatorTok{\{}
  \ControlFlowTok{return} \VariableTok{Math}\NormalTok{.}\AttributeTok{max}\NormalTok{(parm1}\OperatorTok{,}\NormalTok{ parm2)}\OperatorTok{;} \CommentTok{// I use the Math object that contains the max method}
\OperatorTok{\}}

\VariableTok{module}\NormalTok{.}\AttributeTok{exports} \OperatorTok{=} \OperatorTok{\{}
  \DataTypeTok{findMax }\OperatorTok{:}\NormalTok{ findMax}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

We create a \texttt{test.js} script in the same folder that calls the \texttt{findMax} function. To do this, we import the corresponding module:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \OperatorTok{\{}\NormalTok{ findMax }\OperatorTok{\}} \OperatorTok{=} \AttributeTok{require}\NormalTok{(}\StringTok{'./utils.js'}\NormalTok{)}\OperatorTok{;}
\AttributeTok{findMax}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;} \CommentTok{// prints 2}
\end{Highlighting}
\end{Shaded}

\hypertarget{event-listeners}{%
\subsection{Event listeners}\label{event-listeners}}

When you explore a web application, clicking on a button usually triggers something like a computation, a modal or an alert. How does this work? In JavaScript, interactivity plays a critical role. Indeed, you want the web application to react to user inputs like mouse clicks or keyboard events. Below we introduce DOM events.

Let's consider a basic HTML button.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<button}\OtherTok{ id=}\StringTok{"mybutton"}\KeywordTok{>}\NormalTok{Go!}\KeywordTok{</button>}
\end{Highlighting}
\end{Shaded}

On the JavaScript side, we first capture the button element using its id selector (\texttt{getElementById}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ btn }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{'mybutton'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We then apply the \texttt{addEventListener} method. In short, an event listener is a program that triggers when a given event occurs (we can add multiple event listeners per HTML element). It takes 2 main parameters:

\begin{itemize}
\tightlist
\item
  the event: click, change, mouseover, \ldots{}
\item
  the function to call
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{btn}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \AttributeTok{alert}\NormalTok{(}\StringTok{'Thanks!'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{noteblock}

We could compare the JavaScript events to Shiny \texttt{observeEvent} in which we are listening to a specific user input:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{observeEvent}\NormalTok{(trigger, \{}
  \CommentTok{# instructions}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}


\end{noteblock}

\hypertarget{jquery}{%
\section{jQuery}\label{jquery}}

\hypertarget{introduction-1}{%
\subsection{Introduction}\label{introduction-1}}

\href{https://jquery.com}{jQuery} is a famous JavaScript library providing a user friendly interface to manipulate the DOM and is present in almost all actual websites. It is slightly easier (understand more convenient to use) than vanilla JS, even though web developers tend to avoid it to go back to vanilla JS (Bootstrap 5, the next iteration of Bootstrap will not rely on jQuery anymore). To use jQuery in a web page, we must include its code either by downloading the code and putting the minified JS file in our HTML or setting a link to a CDN:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!doctype }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
    \KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"utf-8"}\KeywordTok{>}
    \KeywordTok{<title>}\NormalTok{Including jQuery}\KeywordTok{</title>}
    \CommentTok{<!-- How to include jQuery -->}
    \KeywordTok{<script}\OtherTok{ src=}\StringTok{"https://code.jquery.com/jquery-3.5.0.js"}\KeywordTok{></script>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
   
    \KeywordTok{<p>}\NormalTok{Hello World}\KeywordTok{</p>}
  
  \KeywordTok{<script>}
    \AttributeTok{$}\NormalTok{(}\StringTok{'p'}\NormalTok{).}\AttributeTok{css}\NormalTok{(}\StringTok{'color'}\OperatorTok{,} \StringTok{'red'}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{</script>}
   
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

\hypertarget{syntax}{%
\subsection{Syntax}\label{syntax}}

Below is a minimal jQuery code representing its philosophy (``write less, do more.''):

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(selector).}\AttributeTok{action}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The selector slot stands for any jQuery selector like class, id, element, {[}attribute{]}, :input (will select all input elements) and many \href{https://www.w3schools.com/jquery/jquery_ref_selectors.asp}{more}. As a reminder, let's consider the following example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<p}\OtherTok{ class=}\StringTok{"text"}\KeywordTok{>}\NormalTok{Hello World}\KeywordTok{</p>}
\end{Highlighting}
\end{Shaded}

To select and interact with this element, we use JavaScript and jQuery:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ inner }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementsByClassName}\NormalTok{(}\StringTok{'text'}\NormalTok{).}\AttributeTok{innerHTML}\OperatorTok{;} \CommentTok{// vanilla JS}
\KeywordTok{let}\NormalTok{ inner }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'.text'}\NormalTok{).}\AttributeTok{html}\NormalTok{()}\OperatorTok{;} \CommentTok{// jQuery}
\end{Highlighting}
\end{Shaded}

This is of course possible to chain selectors:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<ul}\OtherTok{ class=}\StringTok{"list"}\KeywordTok{>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{1}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{2}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{3}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\OtherTok{ id=}\StringTok{"precious-item"}\KeywordTok{>}\NormalTok{4}\KeywordTok{</li>}
\KeywordTok{</ul>}

\KeywordTok{<ul}\OtherTok{ class=}\StringTok{"list"}\OtherTok{ id=}\StringTok{"list2"}\KeywordTok{>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{1}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{2}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{3}\KeywordTok{</li>}
  \KeywordTok{<li}\OtherTok{ class=}\StringTok{"item"}\KeywordTok{>}\NormalTok{4}\KeywordTok{</li>}
\KeywordTok{</ul>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ items }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'.list .item'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will return an array containing 8 li tags}
\KeywordTok{let}\NormalTok{ otherItems }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#list2 .item'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will select only li tags from the second ul element}
\KeywordTok{let}\NormalTok{ lists }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'ul'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will return an array with 2 ul elements}
\KeywordTok{let}\NormalTok{ firstItem }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#list2:first-child'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will return the first li element of the second ul.}
\end{Highlighting}
\end{Shaded}

\hypertarget{useful-functions}{%
\subsection{Useful functions}\label{useful-functions}}

There exist filtering functions dedicated to simplify item \href{https://api.jquery.com/category/traversing/}{selection}. Below are is a list containing the mostly used in Shiny.

\hypertarget{travel-in-the-dom}{%
\subsubsection{Travel in the DOM}\label{travel-in-the-dom}}

\begin{longtable}[]{@{}cc@{}}
\toprule
\begin{minipage}[b]{0.42\columnwidth}\centering
Method\strut
\end{minipage} & \begin{minipage}[b]{0.52\columnwidth}\centering
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.42\columnwidth}\centering
children()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get the children of each element passed in the selector (important: only travels a single level down the DOM tree)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
first()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Given an list of elements, select the first item\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
last()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Given an list of elements, select the last item\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
find()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Look for a descendant of the selected element(s) that could be multiple levels down in the DOM\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
closest()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Returns the first ancestor matching the condition (travels up in the DOM)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
filter()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Fine tune element selection by applying a filter. Only return element for which the condition is true\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
siblings()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get all siblings of the selected element(s)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
next()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get the immediately following sibling\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
prev()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get the immediately preceding sibling\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
not()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Given an existing set of selected elements, remove element(s) that match the given condition\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{manipulate-tags}{%
\subsubsection{Manipulate tags}\label{manipulate-tags}}

Below is a list of the main jQuery \href{https://api.jquery.com/category/manipulation/}{methods} to manipulate tags (adding class, css property\ldots)

\begin{longtable}[]{@{}cc@{}}
\toprule
\begin{minipage}[b]{0.42\columnwidth}\centering
Method\strut
\end{minipage} & \begin{minipage}[b]{0.52\columnwidth}\centering
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.42\columnwidth}\centering
addClass()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Add class or multiple classes to the set of matched elements\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
hasClass()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Check if the matched element(s) have a given class\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
removeClass()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Remove class or multiple classes to the set of matched elements\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
attr()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get or set the value of a specific attribute\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
after()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Insert content after\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
before ()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Insert content before\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
css()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get or set a css property\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
remove()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Remove element(s) from the DOM\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.42\columnwidth}\centering
val()\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\centering
Get the current value of the matched element(s)\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

TO DO: add more methods

\hypertarget{chaining-jquery-methods}{%
\subsection{Chaining jQuery methods}\label{chaining-jquery-methods}}

A lot of jQuery methods may be chained, that is like pipe operations in R.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<ul>}
  \KeywordTok{<li>}\NormalTok{Item 1}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 2}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 3}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 4}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 5}\KeywordTok{</li>}
\KeywordTok{</ul>}
\end{Highlighting}
\end{Shaded}

We end the chain by \texttt{;} and each step is indented by 2 spaces in the right direction:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\StringTok{'ul'}\NormalTok{)}
\NormalTok{  .}\AttributeTok{first}\NormalTok{()}
\NormalTok{  .}\AttributeTok{css}\NormalTok{(}\StringTok{'color'}\OperatorTok{,} \StringTok{'green'}\NormalTok{) }\CommentTok{// add some style with css}
\NormalTok{  .}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\OperatorTok{,} \StringTok{'myAwesomeItem'}\NormalTok{) }\CommentTok{// add an id attribute}
\NormalTok{  .}\AttributeTok{addClass}\NormalTok{(}\StringTok{'amazing-ul'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{iterations-1}{%
\subsection{Iterations}\label{iterations-1}}

Like in vanilla JavaScript, it is possible to do iterations in jQuery. Let's consider the following HTML elements:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<ul>}
  \KeywordTok{<li>}\NormalTok{Item 1}\KeywordTok{</li>}
  \KeywordTok{<li>}\NormalTok{Item 2}\KeywordTok{</li>}
\KeywordTok{</ul>}
\end{Highlighting}
\end{Shaded}

We apply the \texttt{each} method to change the style of each matched element step by step:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\StringTok{'li'}\NormalTok{).}\AttributeTok{each}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(}\KeywordTok{this}\NormalTok{).}\AttributeTok{css}\NormalTok{(}\StringTok{'visibility'}\OperatorTok{,} \StringTok{'hidden'}\NormalTok{)}\OperatorTok{;} \CommentTok{// will hide all li items}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{noteblock}
Notice that the following code \texttt{\$(\textquotesingle{}li\textquotesingle{}).css(\textquotesingle{}visibility\textquotesingle{},\ \textquotesingle{}hidden\textquotesingle{});} will do exactly the same! This is explained by the implicit iteration process handled by most of jQuery methods.

\end{noteblock}

The \texttt{map} methods has a different purpose. It creates a new object based on the provided one.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ items }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\NormalTok{]}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ threshold }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}

\KeywordTok{let}\NormalTok{ filteredItems }\OperatorTok{=} \VariableTok{$}\NormalTok{.}\AttributeTok{map}\NormalTok{(items}\OperatorTok{,} \KeywordTok{function}\NormalTok{(i) }\OperatorTok{\{}
  \CommentTok{// removes all items > threshold}
  \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{>}\NormalTok{ threshold) }
    \ControlFlowTok{return} \KeywordTok{null}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ i}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{good-practice}{%
\subsection{Good practice}\label{good-practice}}

It is recommended to wrap any jQuery code as follows:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{ready}\NormalTok{(}\KeywordTok{function}\NormalTok{()}\OperatorTok{\{}
  \CommentTok{// your code}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// or a shortcut}

\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// your code}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{importantblock}
Indeed, do you guess what would happen if you try to modify an element that does not even exist? The code above will make sure that the document is ready before starting any jQuery manipulation.

\end{importantblock}

\hypertarget{events}{%
\subsection{Events}\label{events}}

In jQuery there exists a significant number methods related to events. Below are the most popular:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{click}\NormalTok{()}\OperatorTok{;} \CommentTok{// click event}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{change}\NormalTok{()}\OperatorTok{;} \CommentTok{// trigger change on an element}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
 \CommentTok{// whatever}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;} \CommentTok{// attach an event handler function. Here we add click for the example}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{one}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
 \CommentTok{// whatever}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;} \CommentTok{// the difference with on is that one will trigger only once}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{resize}\NormalTok{()}\OperatorTok{;} \CommentTok{// useful to trigger plot resize in Shiny so that they correctly fit their container}
\AttributeTok{$}\NormalTok{(element).}\AttributeTok{trigger}\NormalTok{(}\StringTok{'change'}\NormalTok{) }\CommentTok{// similar to $(element).change(); You will find it in the Shiny core.}
\end{Highlighting}
\end{Shaded}

The \texttt{.on} event is frequently used in Shiny since it allows to pass custom events which are not part of the JS predefined events. For instance \texttt{\{shinydashboard\}} \citep{R-shinydashboard} relies on a specific HTML/JavaScript/CSS template including a homemade API for handling the dashboard events. Don't worry if this section is not clear at the moment. We will see practical examples in the following chapters.

\hypertarget{extending-objects}{%
\subsection{Extending objects}\label{extending-objects}}

A last feature we need to mention about jQuery is the ability to extend objects with additional properties and/or method.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// jQuery way}
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ object1 }\OperatorTok{=} \OperatorTok{\{} \DataTypeTok{apple}\OperatorTok{:} \DecValTok{0} \OperatorTok{\};}
  \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(object1}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{print}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
      \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\KeywordTok{this}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \VariableTok{object1}\NormalTok{.}\AttributeTok{print}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

With vanilla JS we would use \texttt{Object.defineProperty}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// pure JavaScript}
\VariableTok{Object}\NormalTok{.}\AttributeTok{defineProperty}\NormalTok{(object1}\OperatorTok{,} \StringTok{'print'}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{value}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\KeywordTok{this}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{writable}\OperatorTok{:} \KeywordTok{false}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{shiny-js-inspector}{%
\section{Shiny, JavaScript and the HTML inspector}\label{shiny-js-inspector}}

In the above part we gave some elementary JS knowledge. This section comes back to the main point of this book, that is Shiny. We describe how to leverage the developer tools so as to test,run and debug JavaScript code related to a Shiny app.

\hypertarget{the-console-panel}{%
\subsection{The console panel}\label{the-console-panel}}

While developing JS code, we often put some \texttt{console.log(var)} calls to track the content of a given variable and check that our code is doing what it is supposed to do. The resulting messages, errors or warnings are printing in the console, also called a Read-eval-print loop (REPL) suitable to experiment and practice your new JS/jQuery skills.

\hypertarget{a-real-repl}{%
\subsubsection{A real REPL}\label{a-real-repl}}

As a warm up, run the shiny app below and open the Chrome DevTools. Notice the 2 \texttt{Console} tabs (next to \texttt{Elements} and at the bottom), as depicted in Figure \ref{fig:dom-console}. I prefer using the bottom one to still see the \texttt{Elements} tab and preview DOM modifications in real time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{()}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/dom-console} \caption{Console panel in the DevTools}\label{fig:dom-console}
\end{figure}

Interestingly, you may access any element contained in the window. Copy and paste \texttt{\$("body").addClass("plop");} in the prompt. Notice what happens in the \texttt{Elements} tab.

\hypertarget{track-errors-and-warnings}{%
\subsubsection{Track errors and warnings}\label{track-errors-and-warnings}}

As discussed earlier in the book, a lot of Shiny app issues on \href{https://stackoverflow.com/}{Stack Overflow} or in the \href{https://community.rstudio.com/}{RStudio community} could be more easily solved by quickly inspecting the console.

\hypertarget{broken-shiny-app-debug}{%
\subsection{Debug Shiny/JS code with the inspector}\label{broken-shiny-app-debug}}

To debug Shiny apps from the inspector, you all your scripts have to be in a folder accessible by the app like the \texttt{www/} folder or by using \texttt{shiny::addResourcePath}. Moreover,
if you have minified files, there must be \href{https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/}{source maps}, which will allow to reconstruct the original scripts, that is as they were before the minification process. For instance, Shiny has the \texttt{shiny.min.js.map}. In practice, most R packages bundling HTML templates do not ship these files since they could be quite large (see package size restriction for CRAN). The \href{https://framework7.io/}{framework7} HTML template, on top of which is built \texttt{\{shinyMobile\}} {[}R-shinyMobile{]} has source maps but the size can reach 5MB which is obviously too big to include in the R package.

In the following, we consider a very simple shiny app deployed on \href{https://www.shinyapps.io/}{shinyapps.io}, where a notification is displayed with JavaScript as soon as a user clicks an action button. I also made some typos in my code and the goal is to find and fix them.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Browse to the \href{https://dgranjon.shinyapps.io/debug_app_in_web_browser/}{app}
\item
  Open the Chrome DevTools
\item
  Click on the action button (I am pretty sure you clicked before step 2 ;))
\item
  As expected and shown Figure \ref{fig:dom-debug-shiny-error}, the console displays an
  error message: \texttt{Uncaught\ TypeError:\ Cannot\ read\ property\ \textquotesingle{}show\textquotesingle{}\ of\ undefined}. Sounds good isn't it?
\end{enumerate}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/dom-debug-shiny-error} \caption{Error in the console panel}\label{fig:dom-debug-shiny-error}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Expand the error message to show the stack trace. We see that the error occurred during an \texttt{onclick} event calling the \texttt{sendNotif} function. Interestingly, we can open this file by clicking on the provided link (notif.js:2). You should get a layout similar to Figure \ref{fig:dom-debug-shiny-sources}, depending on your screen width.
\end{enumerate}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/dom-debug-shiny-sources} \caption{Inspect the source causing the error}\label{fig:dom-debug-shiny-sources}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\item
  Let's briefly describe Figure \ref{fig:dom-debug-shiny-sources}. On the left side, you can navigate through all files accessible by the web server, that is shiny internal resources, shiny external dependencies (like Bootstrap 3) as well as your own scripts. If the app is deployed on shinyapps.io, all scripts are located in a folder starting by \texttt{\_w\_}, which corresponds to the shinyapps.io workerId (this is a detail and not important to understand. See more \href{https://github.com/rstudio/shiny/blob/master/R/shiny.R\#L69}{here}). The central part contains any opened script like a classic IDE. The right side displays debugging tools which you may trigger by clicking on the corresponding accordion. The scope shows all variables/object values at a break point, watch allows to track specific elements and Event listener Breakpoints allows to stop at given listener type. We could create a new ``watcher'' by entering \texttt{typeof\ message} and clicking the add icon to check the message type within the \texttt{sendNotif} function. Watched expressions are saved when you close the browser.
\item
  Put a break point line 2 by clicking on the left side of the center panel and click again on the action button to trigger the break point. I also additionally set 2 Watch Expressions (for message and duration) which type is string and number, respectively, as depicted on Figure \ref{fig:dom-debug-shiny-breakpoint}. According to the results, nothing seems wrong for the function arguments.
\end{enumerate}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/dom-debug-shiny-breakpoint} \caption{Inspection of the scope at the breakpoint}\label{fig:dom-debug-shiny-breakpoint}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\tightlist
\item
  The error message \texttt{Uncaught\ TypeError:\ Cannot\ read\ property\ \textquotesingle{}show\textquotesingle{}\ of\ undefined} actually means that \texttt{notification} does not exist. Try yourself by typing \texttt{Shiny.notification} in the console. You'll get \texttt{undefined}. Instead, the console suggests
  \texttt{Shiny.notifications}. Let's replace the wrong code in the \texttt{notif.js} script and then save it.
  Click on the ``Resume script execution'' blue button (top left of the right panel). Notice that a notification is displayed and no more error is thrown.
\end{enumerate}

Congrats! You've just debugged your first shiny app from the web inspector. In practice, your code is probably much more complex than this example but the workflow remains the same.

\hypertarget{shiny-js-object}{%
\subsection{The Shiny JavaScript object}\label{shiny-js-object}}

The \texttt{Shiny} object is exported at the top of the \texttt{shiny.js} file. In other words, this means that we may use this object and any of its properties within the HTML inspector console tab, in any JavaScript file or shiny app as below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      console.log(Shiny);}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

This object contains many properties and methods as shown in Figure \ref{fig:shiny-object}. Some of particular interest, such as like \texttt{Shiny.setInputValue}, \texttt{Shiny.addCustomMessageHandler}, \texttt{Shiny.shinyapps}, \texttt{Shiny.bindAll}, will be detailed later in Chapters \ref{shiny-input-system} and \ref{shiny-custom-handler}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-object} \caption{The Shiny JavaScript object}\label{fig:shiny-object}
\end{figure}

\begin{warningbox}
At this point, users may find \texttt{options(shiny.minified\ =\ FALSE)} convenient to debug the Shiny.js core.

\end{warningbox}

\hypertarget{exercises-2}{%
\section{Exercises}\label{exercises-2}}

Because the JavaScript console is a REPL, all JavaScript exercises may be done inside, except exercise 3 which also involves HTML. In that case, the reader may browse to \href{https://jsfiddle.net/}{jsfiddle}.

\hypertarget{exercise-1-define-variables}{%
\subsection{Exercise 1: define variables}\label{exercise-1-define-variables}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Play with the example below
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ myNumber }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// affectation}
\NormalTok{myNumber}\OperatorTok{--;} \CommentTok{// decrement}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(myNumber)}\OperatorTok{;} \CommentTok{// print 0}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercise-2-define-objects}{%
\subsection{Exercise 2: define objects}\label{exercise-2-define-objects}}

Below is an object skeleton.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ me }\OperatorTok{=} \OperatorTok{\{}
  \DataTypeTok{name }\OperatorTok{:} \OperatorTok{,}
  \DataTypeTok{age }\OperatorTok{:} \OperatorTok{,}
  \DataTypeTok{music }\OperatorTok{:} \OperatorTok{,}
  \DataTypeTok{printName}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VerbatimStringTok{`I am }\SpecialCharTok{$\{\}}\VerbatimStringTok{`}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Fill it with some random values.
\item
  Access the name property.
\item
  Create the printAge method, which returns the age. Hint: \texttt{this} refers to the object itself. For instance \texttt{this.name} gives the name property.
\end{enumerate}

\hypertarget{exercise-3-jquery}{%
\subsection{Exercise 3: jQuery}\label{exercise-3-jquery}}

\href{https://jsfiddle.net/}{JSFiddle} allows to insert HTML, CSS and JavaScript to test
code, share and more. It also does not require you to have any specific configuration on your machine so that you focus on testing!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Go to \href{https://jsfiddle.net/}{JSFiddle}
\item
  Insert the following HTML code chunk in the HTML sub-window.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
  \CommentTok{<!-- head content here -->}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<ul>}
      \KeywordTok{<li>}\NormalTok{Item 1}\KeywordTok{</li>}
      \KeywordTok{<li>}\NormalTok{Item 2}\KeywordTok{</li>}
      \KeywordTok{<li>}\NormalTok{Item 3}\KeywordTok{</li>}
      \KeywordTok{<li>}\NormalTok{Item 4}\KeywordTok{</li>}
      \KeywordTok{<li>}\NormalTok{Item 5}\KeywordTok{</li>}
    \KeywordTok{</ul>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

This is a very basic HTML skeleton

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  In the JavaScript windows, select jQuery 3.4.1 in the dropdown menu (why 3.4.1? The latest Shiny release relies on that version. It is therefore best practice to ensure dependencies are similar, at least the major version).
\item
  Since it is best practice to run jQuery code only when the document is ready (avoiding to target non existing elements), we wrap our JS code in the following:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// your code}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// or a more explicit syntax}
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{ready}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// code}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Create an event listener to change the third item color as soon as one click on it.
  Hint 1: To select the a specific item you may use \texttt{\$(selector:eq(i))} where i is the index of the element. Keep in mind that JavaScript starts from 0 and not 1 like R!
  Hint 2: as a reminder, to create an event listener in jQuery, we use the following pattern.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\StringTok{"selector"}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{"event_name"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
  \CommentTok{// your logic}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercise-4-a-pure-js-action-button}{%
\subsection{Exercise 4: a pure JS action button}\label{exercise-4-a-pure-js-action-button}}

Below is another example of a button element with an attached event listener. Clicking on the button will increment its value by 1. Fill in the blanks!

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
  \CommentTok{<!-- head content here -->}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<button>}\NormalTok{click}\KeywordTok{</button>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    
  \CommentTok{// recover the button inner html}
  \KeywordTok{const}\NormalTok{ btnText }\OperatorTok{=}\NormalTok{ ...}\OperatorTok{;}

    \CommentTok{// event listener for button element}
    \AttributeTok{$}\NormalTok{(...).}\AttributeTok{click}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ val }\OperatorTok{=}\NormalTok{ ...}\OperatorTok{;}
    \CommentTok{// (1) increment button }
    \CommentTok{// (2) add the button value to the inner text}
\NormalTok{    ...}
    
    \CommentTok{// show alert given condition}
    \ControlFlowTok{if}\NormalTok{ (val }\OperatorTok{>} \DecValTok{3}\NormalTok{) }\OperatorTok{\{}
      \CommentTok{// do whatever you want}
\NormalTok{        ...}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{shiny-intro}{%
\chapter{Shiny's internals}\label{shiny-intro}}

This rather technical chapter aims at untangling what are the main mechanisms behind a Shiny app.\\
We particularly highlight some internal processes necessary to the R/JavaScript communication,
which is quite frankly mind blowing.

\hypertarget{the-client-server-model}{%
\section{The client-server model}\label{the-client-server-model}}

A Shiny app is a \textbf{web application} and like all web applications,
it follows the \textbf{server-client} model which consists in:

\begin{itemize}
\tightlist
\item
  A client which sends requests to the server through the network.
\item
  A server composed of hardware and software elements that treats the client request.
\item
  A network inside which flow requests between the server and the client. It is done
  with the HyperText Transfer protocol (HTTP).
\end{itemize}

Each time a client sends a request, it is processed by the server, which provides an answer and closes the connection,
before treating any other request. In practice, to get a webpage, the client emits many requests, one to get the page and then one request per JS/CSS/image assets. As an example, try to run the following in the R console and open the developer tools:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{()}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Under the network tab, we notice many files (if nothing is shown, reload the web browser tab), which actually correspond to all requests made by the client to the server, Figure \ref{fig:shinyapp-requests}. we also get the current answer status, 200 being the OK HTTP \href{https://developer.mozilla.org/en-US/docs/Web/HTTP/Status}{status}, the size and the time needed to treat the request. Nowaday, there exists mechanisms like cache to speed up the request treatment. Don't believe that each time you visit a shiny app, all requests are answered by the server. Actually, most assests are recovered from the web browser cache, that takes significantly less time, although sometimes misleading. I am sure you already found this situation when, after updating your shiny app style, you still get the old design. Most of the time this is a caching issue and resetting Chrome's cache solves the problem.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shinyapp-requests} \caption{Request flow between client and server at shiny app start.}\label{fig:shinyapp-requests}
\end{figure}

\hypertarget{about-http-requests}{%
\section{About HTTP requests}\label{about-http-requests}}

If we inspect the first request from Figure \ref{fig:shinyapp-requests}, we obtain Figure \ref{fig:http-request-details}. An HTTP request is composed of:

\begin{itemize}
\tightlist
\item
  A \href{https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods}{method} that indicates the intentions.
  We mostly use \texttt{GET} to ask for something or \texttt{POST}, to submit something.
\item
  An url, corresponding to the path to the targeted element. Here, if nothing is specified in the path, the server will try to get the main HTML page, also called \texttt{index.html}.
\end{itemize}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/http-request-details} \caption{Details about an HTTP request}\label{fig:http-request-details}
\end{figure}

Wait! How does a Shiny app serves files? This is what we are going to see in the next section.

\hypertarget{shiny-app-lifecycle}{%
\section{Shiny app lifecycle}\label{shiny-app-lifecycle}}

Like all web apps, a shiny app must be hosted on a server to be accessible by end users, even though during development, we can run it locally. Shiny Apps are usually hosted on different environments:

\begin{itemize}
\tightlist
\item
  Shiny server \href{https://rstudio.com/products/shiny/download-server/}{open source}.
\item
  Shiny server \href{https://rstudio.com/products/shiny-server-pro/}{pro}.
\item
  \href{https://rstudio.com/products/connect/evaluation/}{RStudio Connect}.
\item
  \href{https://www.shinyapps.io/}{shinyapps.io}.
\end{itemize}

Whenever a user (client) accesses a shiny app with his web browser, a series of events occurs (Figure \ref{fig:shinyapp-lifecycle}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The client sends a HTTP \texttt{CONNECT} request to the server (Shiny server) containing the path
  to the targeted app.
\item
  The server starts the targeted app with \texttt{runApp()}.
\end{enumerate}

Under the hood, \texttt{runApp()}:

\begin{itemize}
\tightlist
\item
  Calls \texttt{shinyApp()} that returns a shiny app object composed of a server function and the UI.
  The UI has to be formatted to be a function returning an HTTP response, as requested by \texttt{\{httpuv\}}.
\item
  Calls \texttt{startApp} that creates HTTP and websocket (WS) handlers. WS handlers are responsible for controlling the WS behavior when the app starts, when a message is received from a client and when the app closes. It also creates static path containing all CSS, JS files that may be accessed by the browser.
\item
  Calls \texttt{startServer} from \texttt{\{httpuv\}}, that starts the HTTP server and opens the server websocket connection.
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  If the R code does not contain errors, the server returns the Shiny UI HTML code to the client, which is displayed in the web browser.
\item
  The returned HTML contains all the necessary JavaScript to subsequently open the client websocket connection.
\item
  From there, client and server are free to exchange information
\end{enumerate}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shinyapp-lifecycle} \caption{Shiny App lifecycle}\label{fig:shinyapp-lifecycle}
\end{figure}

The following parts detail the most important mechanisms.

\hypertarget{building-the-ui}{%
\subsection{Building the UI}\label{building-the-ui}}

What definitely makes Shiny wonderful is the ability to only write R code to produce HTML. Although convenient for R users, there is a moment where all this R code has to become HTML, since web browsers are just not able to process R files. Shiny must provide a string containing the HTML code that will be later given to the \texttt{\{httpuv\}} server and displayed to the end user. These steps heavily relies on \texttt{\{htmltools\}}, particularly the \texttt{renderDocument()} function. If it has not been documented until here, it's mainly because you don't have to do it on your own, unless you try to develop another web framework for R, built on top of \texttt{\{httpuv\}}, like \texttt{\{ambriorix\}} or \texttt{\{fiery\}}. Another use case is \texttt{\{argonR\}} which allows to design Bootstrap 4 HTML templates, on top of the \href{https://www.creative-tim.com/product/argon-design-system}{argon} design system.

Under the hood, \texttt{shinyApp()} does many things, particularly creating a valid HTTP response template for \texttt{\{httpuv\}}, through the internal \texttt{shiny:::uiHttpHandler} function. The conversion from R to HTML is achieved by \texttt{shiny:::renderPage}. First, the provided UI R code is wrapped in a \texttt{tags\$body()}, if not yet done. As a reminder \texttt{fluidPage} does not create a \texttt{body} tag, which is required to produce a valid HTML template. The result is given to \texttt{htmlTemplate()} to fill the following boilerplate, part of the Shiny package:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\ErrorTok{\{\{}\OtherTok{ if (isTRUE}\ErrorTok{(nzchar(lang)))}\OtherTok{ paste0}\ErrorTok{("}\OtherTok{ lang=}\StringTok{\textbackslash{}}\ErrorTok{"",}\OtherTok{ lang}\ErrorTok{,} \ErrorTok{"\textbackslash{}"")} \ErrorTok{\}\}}\KeywordTok{>}
  \KeywordTok{<head>}
\NormalTok{  \{\{ headContent() \}\}}
  \KeywordTok{</head>}
\NormalTok{  \{\{ body \}\}}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

If we assume that our UI is built as follows, applying \texttt{htmlTemplate()} on it yields:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{textInput}\NormalTok{(}\StringTok{"caption"}\NormalTok{, }\StringTok{"Caption"}\NormalTok{, }\StringTok{"Data Summary"}\NormalTok{),}
  \KeywordTok{verbatimTextOutput}\NormalTok{(}\StringTok{"value"}\NormalTok{)}
\NormalTok{)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{htmlTemplate}\NormalTok{(}
  \KeywordTok{system.file}\NormalTok{(}\StringTok{"template"}\NormalTok{, }\StringTok{"default.html"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"shiny"}\NormalTok{), }
  \DataTypeTok{lang =} \StringTok{"en"}\NormalTok{, }
  \DataTypeTok{body =}\NormalTok{ tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(ui), }
  \DataTypeTok{document_ =} \OtherTok{TRUE}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
    \CommentTok{<!-- HEAD_CONTENT -->}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<div}\OtherTok{ class=}\StringTok{"container-fluid"}\KeywordTok{>}
      \KeywordTok{<div}\OtherTok{ class=}\StringTok{"form-group shiny-input-container"}\KeywordTok{>}
        \KeywordTok{<label}\OtherTok{ class=}\StringTok{"control-label"}\OtherTok{ id=}\StringTok{"caption-label"}\OtherTok{ for=}\StringTok{"caption"}\KeywordTok{>}\NormalTok{Caption}\KeywordTok{</label>}
        \KeywordTok{<input}\OtherTok{ id=}\StringTok{"caption"}\OtherTok{ type=}\StringTok{"text"}\OtherTok{ class=}\StringTok{"form-control"}\OtherTok{ value=}\StringTok{"Data Summary"}\KeywordTok{/>}
      \KeywordTok{</div>}
      \KeywordTok{<pre}\OtherTok{ class=}\StringTok{"shiny-text-output noplaceholder"}\OtherTok{ id=}\StringTok{"value"}\KeywordTok{></pre>}
    \KeywordTok{</div>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

You may wonder what \texttt{headContent()} does. It inserts the string \texttt{\textless{}!-\/-\ HEAD\_CONTENT\ -\/-\textgreater{}} inside the head so that
shiny knows where to insert the dependencies. Then, all necessary dependencies like jQuery, Bootstrap and shiny css/javascript files (\texttt{shiny:::shinyDependencies}) are added in the UI head by \texttt{renderDocument()}. For instance:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(htmltools)}
\NormalTok{html <-}\StringTok{ }\KeywordTok{renderDocument}\NormalTok{(}
\NormalTok{  ui,}
  \DataTypeTok{deps =} \KeywordTok{c}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}\KeywordTok{htmlDependency}\NormalTok{(}\StringTok{"jquery"}\NormalTok{, }\StringTok{"3.5.1"}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"shared"}\NormalTok{), }\DataTypeTok{script =} \StringTok{"jquery.min.js"}\NormalTok{)), }
\NormalTok{    shiny}\OperatorTok{:::}\KeywordTok{shinyDependencies}\NormalTok{() }\CommentTok{# JS + CSS}
\NormalTok{  ),}
  \DataTypeTok{processDep =}\NormalTok{ createWebDependency}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The final result is shown below:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
    \KeywordTok{<meta}\OtherTok{ http-equiv=}\StringTok{"Content-Type"}\OtherTok{ content=}\StringTok{"text/html; charset=utf-8"}\KeywordTok{/>}
    \KeywordTok{<script}\OtherTok{ type=}\StringTok{"application/shiny-singletons"}\KeywordTok{></script>}
    \KeywordTok{<script}\OtherTok{ type=}\StringTok{"application/html-dependencies"}\KeywordTok{>}\NormalTok{jquery[}\DecValTok{3}\NormalTok{.}\FloatTok{5.1}\NormalTok{]}\OperatorTok{;}
\NormalTok{    shiny}\OperatorTok{-}\NormalTok{css[}\DecValTok{1}\NormalTok{.}\FloatTok{6.0}\NormalTok{]}\OperatorTok{;}\NormalTok{shiny}\OperatorTok{-}\NormalTok{javascript[}\DecValTok{1}\NormalTok{.}\FloatTok{6.0}\NormalTok{]}\OperatorTok{;}\NormalTok{bootstrap[}\DecValTok{3}\NormalTok{.}\FloatTok{4.1}\NormalTok{]}\KeywordTok{</script>}
    \KeywordTok{<script}\OtherTok{ src=}\StringTok{"shared/jquery.min.js"}\KeywordTok{></script>}
    \KeywordTok{<link}\OtherTok{ href=}\StringTok{"shared/shiny.min.css"}\OtherTok{ rel=}\StringTok{"stylesheet"} \KeywordTok{/>}
    \KeywordTok{<script}\OtherTok{ src=}\StringTok{"shared/shiny.min.js"}\KeywordTok{></script>}
    \KeywordTok{<meta}\OtherTok{ name=}\StringTok{"viewport"}\OtherTok{ content=}\StringTok{"width=device-width, initial-scale=1"} \KeywordTok{/>}
    \KeywordTok{<link}\OtherTok{ href=}\StringTok{"shared/bootstrap/css/bootstrap.min.css"}\OtherTok{ rel=}\StringTok{"stylesheet"} \KeywordTok{/>}
    \KeywordTok{<link}\OtherTok{ href=}\StringTok{"shared/bootstrap/accessibility/css/bootstrap-accessibility.min.css"}\OtherTok{ rel=}\StringTok{"stylesheet"} \KeywordTok{/>}
    \KeywordTok{<script}\OtherTok{ src=}\StringTok{"shared/bootstrap/js/bootstrap.min.js"}\KeywordTok{></script>}
    \KeywordTok{<script}\OtherTok{ src=}\StringTok{"shared/bootstrap/accessibility/js/bootstrap-accessibility.min.js"}\KeywordTok{></script>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<div}\OtherTok{ class=}\StringTok{"container-fluid"}\KeywordTok{>}
      \KeywordTok{<div}\OtherTok{ class=}\StringTok{"form-group shiny-input-container"}\KeywordTok{>}
        \KeywordTok{<label}\OtherTok{ class=}\StringTok{"control-label"}\OtherTok{ id=}\StringTok{"caption-label"}\OtherTok{ for=}\StringTok{"caption"}\KeywordTok{>}\NormalTok{Caption}\KeywordTok{</label>}
        \KeywordTok{<input}\OtherTok{ id=}\StringTok{"caption"}\OtherTok{ type=}\StringTok{"text"}\OtherTok{ class=}\StringTok{"form-control"}\OtherTok{ value=}\StringTok{"Data Summary"}\KeywordTok{/>}
      \KeywordTok{</div>}
      \KeywordTok{<pre}\OtherTok{ class=}\StringTok{"shiny-text-output noplaceholder"}\OtherTok{ id=}\StringTok{"value"}\KeywordTok{></pre>}
    \KeywordTok{</div>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

The final step is to return an HTTP response containing the HTML string. As of \texttt{\{shiny\}} \texttt{1.6.0}, the \texttt{httpResponse} function is exported by default:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{httpResponse}\NormalTok{(}
  \DataTypeTok{status =} \DecValTok{200}\NormalTok{,}
  \DataTypeTok{content =}\NormalTok{ html}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $status
## [1] 200
## 
## $content_type
## [1] "text/html; charset=UTF-8"
## 
## $content
## <!DOCTYPE html>
## <html lang="en">
## <head>
##   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
##   <script type="application/shiny-singletons"></script>
##   <script type="application/html-dependencies">jquery[3.5.1];shiny-css[1.6.0];shiny-javascript[1.6.0];bootstrap[3.4.1]</script>
## <script src="shared/jquery.min.js"></script>
## <link href="shared/shiny.min.css" rel="stylesheet" />
## <script src="shared/shiny.min.js"></script>
## <meta name="viewport" content="width=device-width, initial-scale=1" />
## <link href="shared/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
## <link href="shared/bootstrap/accessibility/css/bootstrap-accessibility.min.css" rel="stylesheet" />
## <script src="shared/bootstrap/js/bootstrap.min.js"></script>
## <script src="shared/bootstrap/accessibility/js/bootstrap-accessibility.min.js"></script>
## </head>
## <body>
##   <div class="container-fluid">
##     <div class="form-group shiny-input-container">
##       <label class="control-label" id="caption-label" for="caption">Caption</label>
##       <input id="caption" type="text" class="form-control" value="Data Summary"/>
##     </div>
##     <pre class="shiny-text-output noplaceholder" id="value"></pre>
##   </div>
## </body>
## </html>
## 
## 
## $headers
## $headers$`X-UA-Compatible`
## [1] "IE=edge,chrome=1"
## 
## 
## attr(,"class")
## [1] "httpResponse"
\end{verbatim}

\hypertarget{serving-html-with-httpuv}{%
\subsection{\texorpdfstring{Serving HTML with \texttt{\{httpuv\}}}{Serving HTML with \{httpuv\}}}\label{serving-html-with-httpuv}}

Once the UI is processed, Shiny make it available to end users by leveraging \texttt{\{httpuv\}}, which provides tools to set up an HTTP server. The main function is \texttt{startServer} that requires a \textbf{host}, \textbf{port} and an \textbf{app}. If you run a shiny app locally, the default host is \texttt{localhost} or \texttt{127.0.0.1} and the port is randomly chosen by \texttt{shinyApp} or \texttt{runApp}, even though you may fix it. The most important element is the app and \texttt{\{httpuv\}} expects a list of functions like:

\begin{itemize}
\tightlist
\item
  \texttt{call}, to handle the client HTTP request and return the server HTTP response. Depending on the context,
  Shiny may return different responses like 403 (unauthorized), 404 (not found) or 200 (OK).
\item
  \texttt{onHeaders} if the request contains headers. For instance, this may be required for authentication.
\item
  \texttt{staticPaths} to serve assets, especially CSS or JS files.
\end{itemize}

A valid \texttt{call} function template containing the previously processed HTML UI is defined below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{app}\OperatorTok{$}\NormalTok{call <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(req) \{}
  \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{status =}\NormalTok{ 200L,}
    \DataTypeTok{headers =} \KeywordTok{list}\NormalTok{(}
      \StringTok{'Content-Type'}\NormalTok{ =}\StringTok{ 'text/html'}
\NormalTok{    ),}
    \DataTypeTok{body =}\NormalTok{ html}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We then invoke \texttt{startServer}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(httpuv)}
\NormalTok{s <-}\StringTok{ }\KeywordTok{startServer}\NormalTok{(}
  \StringTok{"127.0.0.1"}\NormalTok{,}
  \DecValTok{8080}\NormalTok{,}
\NormalTok{  app}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now, if we browse to \texttt{127.0.0.1:8080}, we see the text input. However, opening the HTML inspector shows many errors, most of them due to the fact that we forgot to serve static assets, all located in the \texttt{inst/www/shared} folder of the \texttt{\{shiny\}} package. Let's do it below by adding a \texttt{staticPaths} component to our app:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s}\OperatorTok{$}\KeywordTok{stop}\NormalTok{() }\CommentTok{# stop the server before running it again!}
\NormalTok{app}\OperatorTok{$}\NormalTok{staticPaths <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{shared =} \KeywordTok{system.file}\NormalTok{(}\DataTypeTok{package =} \StringTok{"shiny"}\NormalTok{, }\StringTok{"www"}\NormalTok{, }\StringTok{"shared"}\NormalTok{))}
\NormalTok{s <-}\StringTok{ }\KeywordTok{startServer}\NormalTok{(}
  \StringTok{"127.0.0.1"}\NormalTok{,}
  \DecValTok{8080}\NormalTok{,}
\NormalTok{  app}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Keep in mind that Shiny does many more things to setup the server and we just highlighted the most important steps.
The above code crashes since the HTML page returned to the client tries to connect to a server websocket, that does not yet exist.

So far so good! You hopefully now better understand how shiny processes the app UI and how it is served. However, this still does not tell how the communication between R and JS is possible.

\hypertarget{handle-rjs-communication}{%
\subsection{Handle R/JS communication}\label{handle-rjs-communication}}

This is a built-in Shiny feature leveraging the \href{https://github.com/rstudio/httpuv}{httpuv} package.

\hypertarget{what-is-a-websocket}{%
\subsubsection{What is a websocket?}\label{what-is-a-websocket}}

Before going further let's define what is a \textbf{websocket}. It is an advanced technology allowing \textbf{bidirectional communication} between a (or multiple) client(s) and a server. For instance, a \href{https://dev.to/spukas/learn-websockets-by-building-simple-chat-app-dee}{chat} system may be built on top of a websocket \footnote{By default, each time a client connects to the server, a new connection is opened, thereby preventing this client from capturing others connections messages, also called single cast. For a chat, we use a \href{https://medium.com/the-quarter-espresso/multicast-websocket-nodejs-ff1f400ba2f7}{multi cast} strategy, that is forwarding one client's message to (all) other connected clients. \texttt{\{httpuv\}} does not provide such a feature since this would not make sense and would be harmful in the context of shiny!}. The server is generally created using Node.js libraries like \texttt{ws} and the client with JavaScript. In the R Shiny context, the server part is created from \texttt{\{httpuv\}} \citep{R-httpuv} and the client either with \texttt{\{websocket\}} \citep{R-websocket} (see below) or directly from JavaScript, as described later:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(httpuv)}
\CommentTok{# set the server}
\NormalTok{s <-}\StringTok{ }\KeywordTok{startServer}\NormalTok{(}\StringTok{"127.0.0.1"}\NormalTok{, }\DecValTok{8080}\NormalTok{,}
  \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{onWSOpen =} \ControlFlowTok{function}\NormalTok{(ws) \{}
      \CommentTok{# The ws object is a WebSocket object}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"Server connection opened.}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
      
\NormalTok{      ws}\OperatorTok{$}\KeywordTok{onMessage}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(binary, message) \{}
        \KeywordTok{cat}\NormalTok{(}\StringTok{"Server received message:"}\NormalTok{, message, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{        ws}\OperatorTok{$}\KeywordTok{send}\NormalTok{(}\StringTok{"Hello client!"}\NormalTok{)}
\NormalTok{      \})}
\NormalTok{      ws}\OperatorTok{$}\KeywordTok{onClose}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() \{}
        \KeywordTok{cat}\NormalTok{(}\StringTok{"Server connection closed.}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{      \})}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

On the server side, \texttt{startServer()} also handles websockets. To proceed, the app list must contain an extra element, that is the \texttt{onWSOpen} function, defining all actions to perform after the connection is established. Those actions are listed in the \texttt{\{httpuv\}} \texttt{WebSocket} R6 class:

\begin{itemize}
\tightlist
\item
  \textbf{onMessage} is invoked whenever a message is received on this connection.
\item
  \textbf{onClose} is invoked when the connection is closed.
\item
  \textbf{send} sends a message from the server (to the client).
\end{itemize}

On the client, we may use the \texttt{\{websocket\}} \texttt{WebSocket} class provided by the \href{https://github.com/rstudio/websocket}{websocket} package:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(websocket)}
\CommentTok{# set the client}
\NormalTok{ws <-}\StringTok{ }\NormalTok{websocket}\OperatorTok{::}\NormalTok{WebSocket}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}\StringTok{"ws://127.0.0.1:8080/"}\NormalTok{)}
\NormalTok{ws}\OperatorTok{$}\KeywordTok{onMessage}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(event) \{}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"Client received message:"}\NormalTok{, event}\OperatorTok{$}\NormalTok{data, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\})}

\CommentTok{# Wait for a moment before running next line}
\NormalTok{ws}\OperatorTok{$}\KeywordTok{send}\NormalTok{(}\StringTok{"Hello server!"}\NormalTok{)}

\CommentTok{# Close client}
\NormalTok{ws}\OperatorTok{$}\KeywordTok{close}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

We briefly describe the above code:

\begin{itemize}
\tightlist
\item
  We create a new client socket instance, which triggers the server \texttt{onWSOpen} function, displaying the welcome message.
\item
  We set the client \texttt{ws\$onMessage} event manager that will print the message sent by the server.
\item
  Then a message is sent from the client with \texttt{ws\$send}, received on the server and sent back to the client, and so on.
  Figure \ref{fig:websocket-basics} shows the main mechanisms.
\item
  The client connection is closed, which also closes the server connection.
\end{itemize}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/websocket-basics} \caption{Typical websocket flow between client and server.}\label{fig:websocket-basics}
\end{figure}

Interestingly, multiple clients can connect to the same server.
You may give it a try with the \texttt{\{OSUICode\}} side package:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(OSUICode)}
\NormalTok{server <-}\StringTok{ }\KeywordTok{websocket_server}\NormalTok{()}
\NormalTok{client_}\DecValTok{1}\NormalTok{ <-}\StringTok{ }\KeywordTok{websocket_client}\NormalTok{()}
\NormalTok{client_}\DecValTok{2}\NormalTok{ <-}\StringTok{ }\KeywordTok{websocket_client}\NormalTok{()}
\NormalTok{client_}\DecValTok{1}\OperatorTok{$}\KeywordTok{send}\NormalTok{(}\StringTok{"Hello from client 1"}\NormalTok{)}
\NormalTok{client_}\DecValTok{2}\OperatorTok{$}\KeywordTok{send}\NormalTok{(}\StringTok{"Hello from client 2"}\NormalTok{)}
\NormalTok{client_}\DecValTok{1}\OperatorTok{$}\KeywordTok{close}\NormalTok{()}
\NormalTok{client_}\DecValTok{2}\OperatorTok{$}\KeywordTok{send}\NormalTok{(}\StringTok{"Only client 2 is here"}\NormalTok{)}
\NormalTok{client_}\DecValTok{2}\OperatorTok{$}\KeywordTok{close}\NormalTok{()}
\KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{server}\OperatorTok{$}\KeywordTok{stop}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

whose output is shown below.

\begin{verbatim}
Server connection opened.
Server connection opened.
Server received message: Hello from client 1 
Client received message: Hello client! 
Server received message: Hello from client 2 
Client received message: Hello client! 
Server connection closed.
Server received message: Only client 2 is here 
Client received message: Hello client! 
Server connection closed.
\end{verbatim}

\hypertarget{from-R-to-JS}{%
\subsubsection{Example}\label{from-R-to-JS}}

In practice, Shiny does not use \texttt{\{websocket\}}. As mentioned earlier, the client is directly built from JS. To better
understand the whole process, we are going to design a simple web page containing an HTML range slider, pass its value from JS to R through the websocket, so that R can do a simple histogram. Moreover, R will also send a message to JS, thereby updating a gauge meter widget located in the page.

To proceed, we need few elements:
- The HTML page containing the slider, gauge and the JS logic to create the client websocket connection, process
the slider value and update the gauge value.
- An app composed of an \texttt{\{httpuv\}} powered HTTP server serving this HTML page as well as a websocket server to connect R and JS.

\hypertarget{create-the-app}{%
\paragraph{Create the app}\label{create-the-app}}

As shown above, we use the \texttt{startServer} function, giving it a default port and host such that the url is \texttt{127.0.0.1:8080}. The most important elements
is the app that consists in an HTTP response and a server websocket. The websocket call back may be defined
as below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ws_handler <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(ws) \{}
  \CommentTok{# The ws object is a WebSocket object}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"New connection opened.}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \CommentTok{# Capture client messages}
\NormalTok{  ws}\OperatorTok{$}\KeywordTok{onMessage}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(binary, message) \{}
    \CommentTok{# create plot}
\NormalTok{    input_message <-}\StringTok{ }\NormalTok{jsonlite}\OperatorTok{::}\KeywordTok{fromJSON}\NormalTok{(message)}
    \KeywordTok{print}\NormalTok{(input_message)}
    \KeywordTok{cat}\NormalTok{(}\StringTok{"Number of bins:"}\NormalTok{, input_message}\OperatorTok{$}\NormalTok{value, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input_message}\OperatorTok{$}\NormalTok{value))}
    
    \CommentTok{# update gauge widget}
\NormalTok{    output_message <-}\StringTok{ }\NormalTok{jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}
      \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{val =} \KeywordTok{sample}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\DecValTok{1}\NormalTok{),}
        \DataTypeTok{message =} \StringTok{"Thanks client! I updated the plot..."}
\NormalTok{      ),}
      \DataTypeTok{pretty =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{auto_unbox =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{    ws}\OperatorTok{$}\KeywordTok{send}\NormalTok{(output_message)}
    \KeywordTok{cat}\NormalTok{(output_message)}
\NormalTok{  \})}
\NormalTok{  ws}\OperatorTok{$}\KeywordTok{onClose}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() \{}
    \KeywordTok{cat}\NormalTok{(}\StringTok{"Server connection closed.}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  \})}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The critical part is the \texttt{onMessage} call back which has to process the client message. As we'll send a JSON (from the client), we leverage \texttt{jsonlite::fromJSON()} to properly treat the message. It is printed for debugging purposes and the value is injected inside a \texttt{hist(rnorm())} function. The second task is to send a message to JS in order to update the gauge value. See it like an \texttt{updateSlider()} function for instance. We utilize \texttt{jsonlite::toJSON()} to send a random value to JS as well as a polite message.

The HTTP response is returned by the \texttt{call} function and is typically defined as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{http_response <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(req) \{}
  \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{status =}\NormalTok{ 200L,}
    \DataTypeTok{headers =} \KeywordTok{list}\NormalTok{(}
      \StringTok{'Content-Type'}\NormalTok{ =}\StringTok{ 'text/html'}
\NormalTok{    ),}
    \DataTypeTok{body =} \StringTok{"Hello world!"}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It is a list composed of a status code, 200 being the OK HTTP \href{https://developer.mozilla.org/en-US/docs/Web/HTTP/Status}{status}, some headers here indicating
the content nature and the body which is what well be display when the client visits \texttt{127.0.0.1:8080}.
The app code is:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{startServer}\NormalTok{(}
  \StringTok{"127.0.0.1"}\NormalTok{,}
  \DecValTok{8080}\NormalTok{,}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{call =}\NormalTok{ http_reponse, }\DataTypeTok{onWSOpen =}\NormalTok{ ws_handler)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The next step is to replace the \texttt{http\_reponse\$body} by a real HTML page containing the client websocket handler,
as well as the slider and gauge widgets.

\hypertarget{design-the-page-content}{%
\paragraph{Design the page content}\label{design-the-page-content}}

The first task is to create the websocket client connection:

\begin{itemize}
\tightlist
\item
  We initialize the socket connection with the \texttt{WebSocket} \href{https://developer.mozilla.org/en-US/docs/Web/API/WebSocket}{API}. It is crucial
  that the \textbf{host} and \textbf{port} match the parameters provided during the websocket server initialization.
\item
  We create the event registry that is \texttt{socket.onopen}, \texttt{socket.onmessage}. Inside \texttt{socket.onmessage}, we have to process the message sent from R with \texttt{JSON.parse} that creates an object. Remember that we sent a list from R and are only interested in the \texttt{val} element.
\end{itemize}

\begin{importantblock}
Importantly, we must wait for all elements to be available in the DOM before starting any action. Therefore, we wrap the whole thing inside a \texttt{document.addEventListener("DOMContentLoaded",\ ...)}.

\end{importantblock}

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{document}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{"DOMContentLoaded"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \CommentTok{// Capture gauge widget}
  \KeywordTok{var}\NormalTok{ gauge }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{"mygauge"}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// Initialize client socket connection}
  \KeywordTok{var}\NormalTok{ mySocket }\OperatorTok{=} \KeywordTok{new} \AttributeTok{WebSocket}\NormalTok{(}\StringTok{"ws://<HOST>:<PORT>"}\NormalTok{)}\OperatorTok{;}
  \VariableTok{mySocket}\NormalTok{.}\AttributeTok{onopen} \OperatorTok{=} \KeywordTok{function}\NormalTok{ (event) }\OperatorTok{\{}
    \CommentTok{// do things}
  \OperatorTok{\};}
  \CommentTok{// Handle server message}
  \VariableTok{mySocket}\NormalTok{.}\AttributeTok{onmessage} \OperatorTok{=} \KeywordTok{function}\NormalTok{ (event) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ data }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{event}\NormalTok{.}\AttributeTok{data}\NormalTok{)}\OperatorTok{;}
    \VariableTok{gauge}\NormalTok{.}\AttributeTok{value} \OperatorTok{=} \VariableTok{data}\NormalTok{.}\AttributeTok{val}\OperatorTok{;}
  \OperatorTok{\};}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We eventually insert it inside the \texttt{script} tag of our basic HTML boilerplate, which also contains the gauge
skeleton. \texttt{min}, \texttt{max} and \texttt{value} set the range, while \texttt{low}, \texttt{high} and \texttt{optimum} are responsible for the color (red, yellow and green, respectively):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
    \KeywordTok{<script}\OtherTok{ language=}\StringTok{"javascript"}\KeywordTok{>}
      \VariableTok{document}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{"DOMContentLoaded"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
        \CommentTok{// Capture gauge widget}
        \KeywordTok{var}\NormalTok{ gauge }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{"mygauge"}\NormalTok{)}\OperatorTok{;}
        \CommentTok{// Initialize client socket connection}
        \KeywordTok{var}\NormalTok{ mySocket }\OperatorTok{=} \KeywordTok{new} \AttributeTok{WebSocket}\NormalTok{(}\StringTok{"ws://<HOST>:<PORT>"}\NormalTok{)}\OperatorTok{;}
        \VariableTok{mySocket}\NormalTok{.}\AttributeTok{onopen} \OperatorTok{=} \KeywordTok{function}\NormalTok{ (event) }\OperatorTok{\{}
          \CommentTok{// do things}
        \OperatorTok{\};}
        \CommentTok{// Handle server message}
        \VariableTok{mySocket}\NormalTok{.}\AttributeTok{onmessage} \OperatorTok{=} \KeywordTok{function}\NormalTok{ (event) }\OperatorTok{\{}
          \KeywordTok{var}\NormalTok{ data }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{event}\NormalTok{.}\AttributeTok{data}\NormalTok{)}\OperatorTok{;}
          \VariableTok{gauge}\NormalTok{.}\AttributeTok{value} \OperatorTok{=} \VariableTok{data}\NormalTok{.}\AttributeTok{val}\OperatorTok{;}
        \OperatorTok{\};}
      \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{</script>}
    \KeywordTok{<title>}\NormalTok{Websocket Example}\KeywordTok{</title>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<label}\OtherTok{ for=}\StringTok{"mygauge"}\KeywordTok{>}\NormalTok{Gauge:}\KeywordTok{</label>}
    \KeywordTok{<meter}\OtherTok{ id=}\StringTok{"mygauge"}\OtherTok{ min=}\StringTok{"0"}\OtherTok{ max=}\StringTok{"100"}\OtherTok{ low=}\StringTok{"33"}\OtherTok{ high=}\StringTok{"66"}\OtherTok{ optimum=}\StringTok{"80"}\OtherTok{ value=}\StringTok{"50"}\KeywordTok{></meter>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

Once done, we have to take care of the range slider whose code is taken from the MDN \href{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input/range}{resources}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div>}
  \KeywordTok{<input}\OtherTok{ type=}\StringTok{"range"}\OtherTok{ id=}\StringTok{"slider"}\OtherTok{ name=}\StringTok{"volume"}\OtherTok{ min=}\StringTok{"0"}\OtherTok{ max=}\StringTok{"100"}\KeywordTok{>}
  \KeywordTok{<label}\OtherTok{ for=}\StringTok{"slider"}\OtherTok{ id} \OtherTok{=}\StringTok{"sliderLabel"}\KeywordTok{>}\NormalTok{Value:}\KeywordTok{</label>}
\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

It is a simple div containing an input tag as well as a label. The input tag has some attributes, notably the
minimum and maximum value. The slider has to be inserted in the HTML boilerplate shown below:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
    \KeywordTok{<script}\OtherTok{ language=}\StringTok{"javascript"}\KeywordTok{>}
      \VariableTok{document}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{"DOMContentLoaded"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
        \CommentTok{// Capture gauge widget}
        \KeywordTok{var}\NormalTok{ gauge }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{"mygauge"}\NormalTok{)}\OperatorTok{;}
        \CommentTok{// Initialize client socket connection}
        \KeywordTok{var}\NormalTok{ mySocket }\OperatorTok{=} \KeywordTok{new} \AttributeTok{WebSocket}\NormalTok{(}\StringTok{"ws://<HOST>:<PORT>"}\NormalTok{)}\OperatorTok{;}
        \VariableTok{mySocket}\NormalTok{.}\AttributeTok{onopen} \OperatorTok{=} \KeywordTok{function}\NormalTok{ (event) }\OperatorTok{\{}
          \CommentTok{// do things}
        \OperatorTok{\};}
        \CommentTok{// Handle server message}
        \VariableTok{mySocket}\NormalTok{.}\AttributeTok{onmessage} \OperatorTok{=} \KeywordTok{function}\NormalTok{ (event) }\OperatorTok{\{}
          \KeywordTok{var}\NormalTok{ data }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{event}\NormalTok{.}\AttributeTok{data}\NormalTok{)}\OperatorTok{;}
          \VariableTok{gauge}\NormalTok{.}\AttributeTok{value} \OperatorTok{=} \VariableTok{data}\NormalTok{.}\AttributeTok{val}\OperatorTok{;}
        \OperatorTok{\};}
      \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{</script>}
    \KeywordTok{<title>}\NormalTok{Websocket Example}\KeywordTok{</title>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<div>}
      \KeywordTok{<input}\OtherTok{ type=}\StringTok{"range"}\OtherTok{ id=}\StringTok{"slider"}\OtherTok{ name=}\StringTok{"volume"}\OtherTok{ min=}\StringTok{"0"}\OtherTok{ max=}\StringTok{"100"}\KeywordTok{>}
      \KeywordTok{<label}\OtherTok{ for=}\StringTok{"slider"}\OtherTok{ id} \OtherTok{=}\StringTok{"sliderLabel"}\KeywordTok{></label>}
    \KeywordTok{</div>}
    \KeywordTok{<br/>}
    \KeywordTok{<label}\OtherTok{ for=}\StringTok{"mygauge"}\KeywordTok{>}\NormalTok{Gauge:}\KeywordTok{</label>}
    \KeywordTok{<meter}\OtherTok{ id=}\StringTok{"mygauge"}\OtherTok{ min=}\StringTok{"0"}\OtherTok{ max=}\StringTok{"100"}\OtherTok{ low=}\StringTok{"33"}\OtherTok{ high=}\StringTok{"66"}\OtherTok{ optimum=}\StringTok{"80"}\OtherTok{ value=}\StringTok{"50"}\KeywordTok{></meter>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

The slider behavior is entirely controlled with JS. We recover its value with \texttt{document.getElementById} and
add it to the label inner HTML so as to know the current value. We also add an event listener to update the slider value each time the range is updated, either by drag or by keyboard action with \texttt{oninput}. It is best practice to
convert the slider value to a number with \texttt{parseInt}, as the returned value defaults to a string. Finally, we send the value through the websocket, converting it to JSON so that we may process it from R with \texttt{\{jsonlite\}} (or any other relevant package):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ sliderWidget }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{"slider"}\NormalTok{)}\OperatorTok{;}
\KeywordTok{var}\NormalTok{ label }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{"sliderLabel"}\NormalTok{)}\OperatorTok{;}
\VariableTok{label}\NormalTok{.}\AttributeTok{innerHTML} \OperatorTok{=} \StringTok{"Value:"} \OperatorTok{+} \VariableTok{slider}\NormalTok{.}\AttributeTok{value}\OperatorTok{;} \CommentTok{// init}
\CommentTok{// on change}
\VariableTok{sliderWidget}\NormalTok{.}\AttributeTok{oninput} \OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ val }\OperatorTok{=} \AttributeTok{parseInt}\NormalTok{(}\KeywordTok{this}\NormalTok{.}\AttributeTok{value}\NormalTok{)}\OperatorTok{;}
  \VariableTok{mySocket}\NormalTok{.}\AttributeTok{send}\NormalTok{(}
    \VariableTok{JSON}\NormalTok{.}\AttributeTok{stringify}\NormalTok{(}\OperatorTok{\{}
      \DataTypeTok{value}\OperatorTok{:}\NormalTok{ val}\OperatorTok{,}
      \DataTypeTok{message}\OperatorTok{:} \StringTok{"New value for you server!"}
    \OperatorTok{\}}\NormalTok{)}
\NormalTok{  )}\OperatorTok{;}
  \VariableTok{label}\NormalTok{.}\AttributeTok{innerHTML} \OperatorTok{=} \StringTok{"Value:"} \OperatorTok{+}\NormalTok{ val}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{test-it}{%
\subsubsection{Test it!}\label{test-it}}

For convenience, the whole code is provided by \texttt{OSUICode::httpuv\_app()}. Run that function in the R console
and browse to \texttt{127.0.0.1:8080} with Chrome. You should see the range slider as well as its current value. We suggest
the reader to have R and Chrome side by side, to properly see the messages send between R and JS. In Chrome,
open the developer tools and navigate to the Network tab and select the \texttt{websocket} entry, as show Figure \ref{fig:httpuv-websocket-demo}. From now, you may change the slider value. Notice the green arrow message appearing
in the developer tools. This indicates a message sent by the client: here a JSON containing the slider value as well as a tiny message, to be polite with the server. In the R console, you may inspect the received message (it should be the same as the client!). R is instructed to create a new plot and, once done, sends a message back to the client (red arrow) to indicate that the plot is updated and a new value has been generated for the gauge.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/httpuv-websocket-demo} \caption{Server client communication through websocket}\label{fig:httpuv-websocket-demo}
\end{figure}

\hypertarget{clients-concurrency}{%
\subsubsection{Clients concurrency}\label{clients-concurrency}}

Not shown in the above sections, \texttt{httpuv\_app()} exposes a delay parameter that simulates a computationally intense task on the server:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ws}\OperatorTok{$}\KeywordTok{onMessage}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(binary, message) \{}
\NormalTok{  message <-}\StringTok{ }\NormalTok{jsonlite}\OperatorTok{::}\KeywordTok{fromJSON}\NormalTok{(message)}
  \KeywordTok{print}\NormalTok{(message)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"Number of bins:"}\NormalTok{, message}\OperatorTok{$}\NormalTok{value, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(message}\OperatorTok{$}\NormalTok{value))}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(delay)) }\KeywordTok{Sys.sleep}\NormalTok{(delay)}
\NormalTok{  ws}\OperatorTok{$}\KeywordTok{send}\NormalTok{(}\StringTok{"Thanks client! I updated the plot."}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

This is to simulate concurrency that could occur between multiple client. To test it, you may try to call \texttt{my\_app\ \textless{}-\ httpuv\_app(5)}, open two browser tabs pointing to \texttt{127.0.0.1:8080}, update the slider on the first client and update it on the second client. What happens? Why? This illustrates one fundamental limitation about Shiny: as R is single threaded, clients have to queue to get an answer from the server.

\begin{importantblock}
Once done, don't forget to close the server connection with \texttt{my\_app\$stop()}!

\end{importantblock}

In practice, Shiny's core is much more complex but hopefully, you should get a better understanding of the general idea!
The reader must understand that when Shiny inputs/outputs are modified on the client by an end user, there are a lot of exchanges between R and JS, through the websocket. In the following, we briefly describe how Shiny leverages this technology, on both server and client side.

\hypertarget{shiny-and-websockets}{%
\subsubsection{Shiny and websockets}\label{shiny-and-websockets}}

In the previous section, we showed how R and JS can communicate through a \texttt{\{httpuv\}} powered websocket. Now let's see what happens in the context of Shiny.

\hypertarget{shiny-session}{%
\paragraph{The Shiny session object}\label{shiny-session}}

We won't be able to go anywhere without giving some reminders about the Shiny \href{https://shiny.rstudio.com/reference/shiny/1.4.0/session.html}{session} object. Why do we say object? \texttt{session} is actually an instance of the \href{https://github.com/rstudio/shiny/blob/master/R/shiny.R}{\texttt{ShinySession}} R6 class.
Importantly, the session is unique to a given user. It means that 2 different clients cannot share the same session. This is important since it contains all information about input, output and client data.

Upon calling \texttt{ShinySession\$new()}, the initialization method takes one parameter, namely the websocket. As shown in the last section, the websocket allows bidirectional exchanges between R and JS. The session object exposes two methods to communicate with JavaScript:

\begin{itemize}
\tightlist
\item
  \texttt{sendCustomMessage} sends messages from R to JS. It calls the private \texttt{sendMessage} method which itself calls \texttt{write}. The message is sent only when the session is opened, through the websocket \texttt{private\$websocket\$send(json)}. If the \texttt{shiny.trace} \href{https://shiny.rstudio.com/reference/shiny/0.14/shiny-options.html}{option} is TRUE, a message showing the sent JSON is displayed, which is useful for debugging.
\item
  \texttt{sendInputMessage} is used to update inputs from the server. The message is stored in a message queue and ultimately sent through the websocket \texttt{private\$websocket\$send(json)}.
\end{itemize}

The below code is extracted from the \texttt{shiny.R} \href{https://github.com/rstudio/shiny/blob/master/R/shiny.R}{file}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sendCustomMessage =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(type, message) \{}
\NormalTok{  data <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{  data[[type]] <-}\StringTok{ }\NormalTok{message}
\NormalTok{  private}\OperatorTok{$}\KeywordTok{sendMessage}\NormalTok{(}\DataTypeTok{custom =}\NormalTok{ data)}
\NormalTok{\}}

\NormalTok{sendInputMessage =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, message) \{}
\NormalTok{  data <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{message =}\NormalTok{ message)}
  
  \CommentTok{# Add to input message queue}
\NormalTok{  private}\OperatorTok{$}\NormalTok{inputMessageQueue[[}\KeywordTok{length}\NormalTok{(private}\OperatorTok{$}\NormalTok{inputMessageQueue) }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\NormalTok{data}
  \CommentTok{# Needed so that Shiny knows to actually flush the input message queue}
\NormalTok{  self}\OperatorTok{$}\KeywordTok{requestFlush}\NormalTok{()}
\NormalTok{\}}


\NormalTok{sendMessage =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \CommentTok{# This function is a wrapper for $write}
\NormalTok{  msg <-}\StringTok{ }\KeywordTok{list}\NormalTok{(...)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{anyUnnamed}\NormalTok{(msg)) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"All arguments to sendMessage must be named."}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{  private}\OperatorTok{$}\KeywordTok{write}\NormalTok{(}\KeywordTok{toJSON}\NormalTok{(msg))}
\NormalTok{\}}


\NormalTok{write =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(json) \{}
  \ControlFlowTok{if}\NormalTok{ (self}\OperatorTok{$}\NormalTok{closed)\{}
    \KeywordTok{return}\NormalTok{()}
\NormalTok{  \}}
\NormalTok{  traceOption <-}\StringTok{ }\KeywordTok{getOption}\NormalTok{(}\StringTok{'shiny.trace'}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{isTRUE}\NormalTok{(traceOption) }\OperatorTok{||}\StringTok{ }\NormalTok{traceOption }\OperatorTok{==}\StringTok{ "send"}\NormalTok{)}
    \KeywordTok{message}\NormalTok{(}\StringTok{'SEND '}\NormalTok{,}
            \KeywordTok{gsub}\NormalTok{(}\StringTok{'(?m)base64,[a-zA-Z0-9+/=]+'}\NormalTok{,}\StringTok{'[base64 data]'}\NormalTok{,json,}\DataTypeTok{perl=}\OtherTok{TRUE}\NormalTok{))}
\NormalTok{  private}\OperatorTok{$}\NormalTok{websocket}\OperatorTok{$}\KeywordTok{send}\NormalTok{(json)}
\NormalTok{\}}
\CommentTok{# ...}
\end{Highlighting}
\end{Shaded}

No worry if it is not clear at the moment. We will discuss \texttt{sendInputMessage} and \texttt{sendCustomMessage} in the following chapters, respectivelly \ref{shiny-input-system} and \ref{shiny-custom-handler}.

\hypertarget{server-side}{%
\paragraph{Server side}\label{server-side}}

On the server, that is R, a websocket is initiated in the \href{https://github.com/rstudio/shiny/blob/master/R/server.R\#L440}{startApp} function, leveraging the \texttt{\{httpuv\}} package. Websocket handlers are \href{https://github.com/rstudio/shiny/blob/master/R/server.R\#L133}{defined} by \texttt{createAppHandlers}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ws =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(ws) \{}
  \CommentTok{# many things}
  
\NormalTok{  shinysession <-}\StringTok{ }\NormalTok{ShinySession}\OperatorTok{$}\KeywordTok{new}\NormalTok{(ws)}
  
\NormalTok{  ws}\OperatorTok{$}\KeywordTok{onMessage}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(binary, msg) \{}
    \CommentTok{# If unhandled errors occur, make sure they get properly logged}
    \KeywordTok{withLogErrors}\NormalTok{(}\KeywordTok{messageHandler}\NormalTok{(binary, msg))}
\NormalTok{  \})}
  
\NormalTok{  ws}\OperatorTok{$}\KeywordTok{onClose}\NormalTok{(}\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    shinysession}\OperatorTok{$}\KeywordTok{wsClosed}\NormalTok{()}
\NormalTok{    appsByToken}\OperatorTok{$}\KeywordTok{remove}\NormalTok{(shinysession}\OperatorTok{$}\NormalTok{token)}
\NormalTok{    appsNeedingFlush}\OperatorTok{$}\KeywordTok{remove}\NormalTok{(shinysession}\OperatorTok{$}\NormalTok{token)}
\NormalTok{  \})}
  \KeywordTok{return}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Overall, they drive the server websocket behavior. When the Shiny session is initialized, a message is sent through the WS, providing the sessionId, workerId and user to the client (see \texttt{Shiny.shinyapp.config} and section \ref{shiny-js-object}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{private}\OperatorTok{$}\KeywordTok{sendMessage}\NormalTok{(}
  \DataTypeTok{config =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{workerId =} \KeywordTok{workerId}\NormalTok{(),}
    \DataTypeTok{sessionId =}\NormalTok{ self}\OperatorTok{$}\NormalTok{token,}
    \DataTypeTok{user =}\NormalTok{ self}\OperatorTok{$}\NormalTok{user}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{ws\$onMessage} describes what should happen when the server receives an message from the client.
It applies the \texttt{messageHandler} function that, in short:

\begin{itemize}
\tightlist
\item
  Decodes the received message.
\item
  Processes the message. At initialization, the client send a message with an \texttt{init} method tag,
  which tells Shiny to manage input (\texttt{manageInputs(msg\$data,\ now\ =\ TRUE)}) before running any observer (since input don't have value yet). After initialization, client messages have the \texttt{update} tag, meaning that we wait for observers to run before.
\end{itemize}

Finally, when the server connection is closed, all client connections are also closed.

All those handlers are \href{https://github.com/rstudio/shiny/blob/master/R/server.R\#L367}{applied} by \texttt{handlerManager\$addWSHandler(appHandlers\$ws,\ "/",\ tail\ =\ TRUE)}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# see middleware.R}
\NormalTok{httpuvApp <-}\StringTok{ }\NormalTok{handlerManager}\OperatorTok{$}\KeywordTok{createHttpuvApp}\NormalTok{()}

\NormalTok{onWSOpen =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(ws) \{}
  \KeywordTok{return}\NormalTok{(wsHandlers}\OperatorTok{$}\KeywordTok{invoke}\NormalTok{(ws))}
\NormalTok{\}}

\NormalTok{addWSHandler =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(wsHandler, key, }\DataTypeTok{tail =} \OtherTok{FALSE}\NormalTok{) \{}
\NormalTok{  wsHandlers}\OperatorTok{$}\KeywordTok{add}\NormalTok{(wsHandler, key, tail)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that the R option \texttt{options(shiny.trace\ =\ TRUE)} allows the websocket messages to be displayed directly in the R console.

\hypertarget{client-side}{%
\paragraph{Client side}\label{client-side}}

On the JS side, the socket creation occurs in the \texttt{shinyapps.js} \href{https://github.com/rstudio/shiny/blob/60db1e02b03d8e6fb146c9bb1bbfbce269231add/srcjs/shinyapp.js\#L58}{file}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ ws }\OperatorTok{=} \KeywordTok{new} \AttributeTok{WebSocket}\NormalTok{(protocol }\OperatorTok{+} \StringTok{'//'} \OperatorTok{+} \VariableTok{window}\NormalTok{.}\VariableTok{location}\NormalTok{.}\AttributeTok{host} \OperatorTok{+}\NormalTok{ defaultPath)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

through the \texttt{WebSocket} object. \texttt{protocol} is the chosen protocol, either \texttt{ws} or \texttt{wss} (if using \texttt{https}). \texttt{window.location.host} contains the host name and its \href{https://developer.mozilla.org/fr/docs/Web/API/window/location}{port}.
Once the connection is opened, events are handled with the \texttt{onopen} event registry:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{socket}\NormalTok{.}\AttributeTok{onopen} \OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
\NormalTok{  hasOpened }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}

  \AttributeTok{$}\NormalTok{(document).}\AttributeTok{trigger}\NormalTok{(}\OperatorTok{\{}
    \DataTypeTok{type}\OperatorTok{:} \StringTok{'shiny:connected'}\OperatorTok{,}
    \DataTypeTok{socket}\OperatorTok{:}\NormalTok{ socket}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

  \VariableTok{self}\NormalTok{.}\AttributeTok{onConnected}\NormalTok{()}\OperatorTok{;} \CommentTok{// remove overlay}

  \VariableTok{socket}\NormalTok{.}\AttributeTok{send}\NormalTok{(}\VariableTok{JSON}\NormalTok{.}\AttributeTok{stringify}\NormalTok{(}\OperatorTok{\{}
    \DataTypeTok{method}\OperatorTok{:} \StringTok{'init'}\OperatorTok{,}
    \DataTypeTok{data}\OperatorTok{:} \VariableTok{self}\NormalTok{.}\AttributeTok{$initialInput}
  \OperatorTok{\}}\NormalTok{))}\OperatorTok{;}

  \ControlFlowTok{while}\NormalTok{ (}\VariableTok{self}\NormalTok{.}\VariableTok{$pendingMessages}\NormalTok{.}\AttributeTok{length}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ msg }\OperatorTok{=} \VariableTok{self}\NormalTok{.}\VariableTok{$pendingMessages}\NormalTok{.}\AttributeTok{shift}\NormalTok{()}\OperatorTok{;}
    \VariableTok{socket}\NormalTok{.}\AttributeTok{send}\NormalTok{(msg)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{shiny:connected} event is triggered, any disconnected overlay (the famous grayed out screen) is then removed from the DOM. Initial input values are sent to the server via the \texttt{send} method. The \texttt{onmessage} registry aims at handling messages received from the server:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{socket}\NormalTok{.}\AttributeTok{onmessage} \OperatorTok{=} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
  \VariableTok{self}\NormalTok{.}\AttributeTok{dispatchMessage}\NormalTok{(}\VariableTok{e}\NormalTok{.}\AttributeTok{data}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

It subsequently invokes the \texttt{dispatchMessage} method that sends message to all handlers (through \texttt{\_sendMessagesToHandlers}), triggering the \texttt{shiny:message} event. Shiny has internal and custom provided handlers (understand user-defined) stored in separate arrays. Each time, a message type matches a given handler, it is treated. For instance, there is a dedicated internal handler for input messages, that bridges the gap between a given input and the corresponding input binding. This handler eventually triggers the \texttt{inputBinding.receiveMessage} method so that the input value is updated on the client. We discuss this in detail in the following section \ref{update-input-lifecycle}.

Finally the \texttt{onclose} method is called when the websocket connection is closed.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{socket}\NormalTok{.}\AttributeTok{onclose} \OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// These things are needed only if we've successfully opened the}
  \CommentTok{// websocket.}
  \ControlFlowTok{if}\NormalTok{ (hasOpened) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(document).}\AttributeTok{trigger}\NormalTok{(}\OperatorTok{\{}
      \DataTypeTok{type}\OperatorTok{:} \StringTok{'shiny:disconnected'}\OperatorTok{,}
      \DataTypeTok{socket}\OperatorTok{:}\NormalTok{ socket}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

    \VariableTok{self}\NormalTok{.}\AttributeTok{$notifyDisconnected}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}

  \VariableTok{self}\NormalTok{.}\AttributeTok{onDisconnected}\NormalTok{()}\OperatorTok{;} \CommentTok{// Must be run before self.$removeSocket()}
  \VariableTok{self}\NormalTok{.}\AttributeTok{$removeSocket}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If the connection was opened, the \texttt{shiny:disconnected} event is triggered. Then, the disconnect overlay is added to the DOM (grayed out screen) and the socket is removed.

Should any error occurs in the R code, the server sends the error through the websocket, which is captured by the client and displayed.

\hypertarget{debug-websocket-with-shiny}{%
\paragraph{Debug websocket with Shiny}\label{debug-websocket-with-shiny}}

Let's run the following app (see \ref{fig:shiny-websocket}, left panel):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{fluidPage}\NormalTok{(}
    \KeywordTok{selectInput}\NormalTok{(}\StringTok{"variable"}\NormalTok{, }\StringTok{"Variable:"}\NormalTok{,}
                \KeywordTok{c}\NormalTok{(}\StringTok{"Cylinders"}\NormalTok{ =}\StringTok{ "cyl"}\NormalTok{,}
                  \StringTok{"Transmission"}\NormalTok{ =}\StringTok{ "am"}\NormalTok{,}
                  \StringTok{"Gears"}\NormalTok{ =}\StringTok{ "gear"}\NormalTok{)),}
    \KeywordTok{tableOutput}\NormalTok{(}\StringTok{"data"}\NormalTok{)}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{    output}\OperatorTok{$}\NormalTok{data <-}\StringTok{ }\KeywordTok{renderTable}\NormalTok{(\{}
\NormalTok{      mtcars[, }\KeywordTok{c}\NormalTok{(}\StringTok{"mpg"}\NormalTok{, input}\OperatorTok{$}\NormalTok{variable), drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{    \}, }\DataTypeTok{rownames =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

After opening the HTML inspector, we select the network tab and search for websocket in the list. By choosing the message tab, you may inspect what R and JavaScript say to each others. As stated above, the first message sent contains initial input values. Then Shiny recalculates the table, notify when the recalculation is done and becomes idle. The second message received from R is after updating the select input, which triggers the same event cycle.

Although complex, it is extremely useful to check whether the input / output communication is working properly. If not, we would see the error field identifying the issue.

\texttt{Shiny.shinyapp.\$socket.readyState} returns the state of the socket connection. It should be 1 if your app is running. In some instances when the socket is closed, an error would be raised.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-websocket} \caption{Shiny websocket}\label{fig:shiny-websocket}
\end{figure}

We see below that we can even bypass the UI element and update the input value directly via the websocket using \texttt{Shiny.shinyapp.\$sendMsg} with the \texttt{update} method. This is captured on the server side which triggers the output recalculation. We'll discuss more about this in the next section \ref{shiny-input-system}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{updateObsVal <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(value) \{}
  \KeywordTok{sprintf}\NormalTok{(}
    \StringTok{"Shiny.shinyapp.$sendMsg(JSON.stringify(\{}
\StringTok{      method: 'update',}
\StringTok{      data: \{obs: %s\}}
\StringTok{    \}));"}\NormalTok{,}
\NormalTok{    value}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# below we shunt the slider input by sending message}
\CommentTok{# directly through the websocket}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{(}
    \StringTok{"Update obs value"}\NormalTok{,}
    \DataTypeTok{onclick =} \KeywordTok{updateObsVal}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\NormalTok{  ),}
  \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
              \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{  ),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{summary}{%
\paragraph{Summary}\label{summary}}

Below is a summary of the server and client websocket parts. The Shiny app shown in Figure \ref{fig:websocket-intro} consists in an \texttt{actionButton} and a \texttt{sliderInput}. Clicking on the action button triggers an \texttt{observeEvent} that fires \texttt{updateSlideInput}. Under the hood, clicking on the action button sends a message from the client to the server. This message is processed and the corresponding input value is updated on the server, thereby invalidating any observer, reactive element. \texttt{updateSlideInput} sends a message back to the client containing the id of the input to update. This message is received and processed by the \texttt{onMessage} event manager, which redirects the message to the related message handler, thereby updating the corresponding input element on the client. The underlying mechanisms are going to be detailed in the next part \ref{shiny-input-system}. You may imagine that when the slider is updated, it also sends a message to the server, triggering a cascade of reactions.

It let you imagine how many messages are exchanged for more complex apps!

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/websocket-intro} \caption{Websocket allows communication between server and client.}\label{fig:websocket-intro}
\end{figure}

\hypertarget{shiny-input-system}{%
\chapter{Shiny's input system}\label{shiny-input-system}}

Shiny inputs are key elements of Shiny apps since they are a way for the end-user to interact with the app. You may know \texttt{sliderInput}, \texttt{numericInput}, \texttt{checkboxInput} but sometimes you may need fancier elements like \texttt{knobInput} from \href{https://github.com/dreamRs/shinyWidgets/blob/master/R/input-knob.R}{shinyWidgets}, as depicted on Figure \ref{fig:fancy-inputs} or even more sophisticated inputs like the \texttt{smartSelect} of \href{https://github.com/RinteRface/shinyMobile/blob/master/R/f7-inputs.R}{shinyMobile} (Figure \ref{fig:fancy-inputs}, right panel). Have you ever wondered what are the mechanisms behind inputs? Have you ever dreamt to develop your own?

The goal of this section is to understand how Shiny inputs work and how to create new ones.

\begin{figure}
\includegraphics[width=0.5\linewidth]{images/survival-kit/jquery-knobs} \includegraphics[width=0.5\linewidth]{images/survival-kit/smart-select} \caption{Custom shiny inputs. left: knobInput from shinyWidgets; right: smart select from shinyMobile}\label{fig:fancy-inputs}
\end{figure}

\hypertarget{input-bindings}{%
\section{Input bindings}\label{input-bindings}}

When we run our app, most of the time it works just fine! The question is, how are the inputs (and outputs) handled to allow this to happen? Upon initialization, Shiny runs several JavaScript functions. Some are accessible to the programmer (see a usecase \href{https://stackoverflow.com/questions/51633326/dateinput-not-working-on-dt-in-shiny}{here}). To illustrate what they do, let's run the app below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
              \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{  ),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

We then open the HTML inspector and run \texttt{Shiny.unbindAll(document)} (document is the scope, that is where to search). Try to change the slider input. You will notice that nothing happens. Now let's type \texttt{Shiny.bindAll(document)} and update the slider value. Moving the slider successfully update the plot. Magic isn't it? This simply shows that when inputs are not bound, nothing happens so binding inputs is necessary.

We consider another example with multiple inputs.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"unbind"}\NormalTok{, }\StringTok{"Unbind inputs"}\NormalTok{, }\DataTypeTok{onclick =} \StringTok{"Shiny.unbindAll();"}\NormalTok{),}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"bind"}\NormalTok{, }\StringTok{"Bind inputs"}\NormalTok{, }\DataTypeTok{onclick =} \StringTok{"Shiny.bindAll();"}\NormalTok{),}
  \KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) \{}
    \KeywordTok{textInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"text_"}\NormalTok{, i), }\KeywordTok{paste}\NormalTok{(}\StringTok{"Text"}\NormalTok{, i))}
\NormalTok{  \}),}
  \KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) \{}
    \KeywordTok{uiOutput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"val_"}\NormalTok{, i))}
\NormalTok{  \})}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) \{}
\NormalTok{    output[[}\KeywordTok{paste0}\NormalTok{(}\StringTok{"val_"}\NormalTok{, i)]] <-}\StringTok{ }\KeywordTok{renderPrint}\NormalTok{(input[[}\KeywordTok{paste0}\NormalTok{(}\StringTok{"text_"}\NormalTok{, i)]])}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Let's see below what is an input binding and how it works.

\hypertarget{input-structure}{%
\subsection{Input structure}\label{input-structure}}

An input element is given by the \texttt{\textless{}input\textgreater{}} tag as well as several attributes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<input}\OtherTok{ id} \OtherTok{=} \StringTok{inputId}\OtherTok{ type} \OtherTok{=} \StringTok{"text"}\OtherTok{ class} \OtherTok{=} \StringTok{"input-text"}\OtherTok{ value} \OtherTok{=} \StringTok{value}\KeywordTok{>}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{id} guarantees the input uniqueness and a way for shiny to recover it in the \texttt{input\$\textless{}id\textgreater{}} element.
\item
  \href{https://www.w3schools.com/tags/att_input_type.asp}{type} like \texttt{checkbox}, \texttt{button},
  \texttt{text} \ldots{}\textbf{type} may also be a good target for the input binding find method, as explained below.
\item
  \textbf{class} may be required to find the element in the DOM. It is more convenient for
  an input binding to target a class (and all associated elements) rather than an id which corresponds to one element by definition.
  It is also used by CSS to apply styles.
\item
  \textbf{value} holds the input value.
\end{itemize}

\hypertarget{binding-shiny-inputs}{%
\subsection{Binding Shiny inputs}\label{binding-shiny-inputs}}

An input binding allows Shiny to identify each instance of a given input and what you may do with this input. For instance, a slider input must update whenever the range is dragged or when the left and right arrows of the keyboard are pressed. It relies on a class defined in the \texttt{input\_binding.js} \href{https://github.com/rstudio/shiny/blob/master/srcjs/input_binding.js}{file}.

Let's describe each method chronologically. For better convenience, the book side package contains step by step demonstrations which may be found \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code/blob/master/R/inputs.R}{here}. Each example is called by the \texttt{customTextInputExample}, which takes the input binding step as only parameter. For instance \texttt{customTextInputExample(1)} will invoke the first step.

\hypertarget{find-the-input}{%
\subsubsection{Find the input}\label{find-the-input}}

The first step, is critical which is to locate the input in the DOM. On the R side, we define an input, with a specific attribute that will serve as a receptor for the binding. For most of inputs, this may be handled by the type attribute. In other cases, this may be the class, like for the \texttt{actionButton}. On the JS side, we need a method that will identify this receptor. Moreover, two different types of inputs (for instance \texttt{radioButton} and \texttt{selectInput}) cannot have the same receptor for conflict reasons, whereas two instances of the same input type can. If your app contains 10 sliders, they all share the same input binding, and this is where the thing is powerful since they are all bound in one step. The receptor identifier is provided by the \texttt{find} method of the \texttt{InputBinding} class. This method must be applied on a scope, that is the \texttt{document}. \texttt{find} accepts any valid jQuery selector. Note the \texttt{console.log} only here for debugging purpose.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{'.input-text'}\NormalTok{))}\OperatorTok{;}
  \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{'.input-text'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Figure \ref{fig:shiny-find-inputs} summarizes this important step.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-find-inputs} \caption{How to find inputs?}\label{fig:shiny-find-inputs}
\end{figure}

Below, we are going to create a new binding for the \texttt{textInput}, with only two methods mentioned in the previous section, that is \texttt{find} and \texttt{getValue}. For that, we need to create a customized text input, \texttt{customTextInput} to make it unique. We now add the \texttt{input-text} class and make our own input binding pointing to that specific class.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{customTextInput <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (inputId, label, }\DataTypeTok{value =} \StringTok{""}\NormalTok{, }\DataTypeTok{width =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{placeholder =} \OtherTok{NULL}\NormalTok{) \{}
  
  \CommentTok{# this external wrapper ensure to control the input width}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"form-group shiny-input-container"}\NormalTok{, }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) \{}
      \KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, }\KeywordTok{validateCssUnit}\NormalTok{(width), }\StringTok{";"}\NormalTok{)}
\NormalTok{    \},}
    \CommentTok{# input label}
    \KeywordTok{shinyInputLabel}\NormalTok{(inputId, label), }
    
    \CommentTok{# input element + JS dependencies}
    \KeywordTok{tagList}\NormalTok{(}
      \KeywordTok{customTextInputDeps}\NormalTok{(),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{input}\NormalTok{(}
        \DataTypeTok{id =}\NormalTok{ inputId,}
        \DataTypeTok{type =} \StringTok{"text"}\NormalTok{,}
        \DataTypeTok{class =} \StringTok{"form-control input-text"}\NormalTok{,}
        \DataTypeTok{value =}\NormalTok{ value,}
        \DataTypeTok{placeholder =}\NormalTok{ placeholder}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The last part of the code contains a \texttt{tagList} with two elements:

\begin{itemize}
\tightlist
\item
  The element input binding
\item
  The input tag
\end{itemize}

Below is an example of how we managed the dependency creation in our side package.
Considering multiple inputs, we will add more script to the dependency by passing a vector to the script parameter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{customTextInputDeps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{htmlDependency}\NormalTok{(}
    \DataTypeTok{name =} \StringTok{"customTextBindings"}\NormalTok{,}
    \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{,}
    \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{file =} \KeywordTok{system.file}\NormalTok{(}\StringTok{"chapter5/input-bindings"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{)),}
    \DataTypeTok{script =} \StringTok{"customTextInputBinding.js"}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In the \href{https://github.com/RinteRface/shinyMobile/tree/master/inst/framework7-5.5.0}{shinyMobile} package, we chose a more robust approach. All bindings are contained in a folder and compressed so that we generate only one minified file containing all collapsed bindings.

Figure \ref{fig:text-input} shows the main elements of the \texttt{textInput} widget. In the above code, \texttt{shinyInputLabel} is a Shiny internal function that creates the numeric input label, or in other word the text displayed next to it. The core input element is wrapped by \texttt{tags\$input}. No worry if the structure seems unclear, we will give more details about shiny tags in the Chapter \ref{htmltools-overview}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/text-input} \caption{Shiny's textInput elements}\label{fig:text-input}
\end{figure}

We invite the reader to run the full working demonstration with \texttt{customTextInputExample(1)}.
In short this example consists in a simple text input and an output showing the current text input value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{customTextInputExample <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(binding_step) \{}
\NormalTok{  ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
    \KeywordTok{customTextInput}\NormalTok{(}
      \DataTypeTok{inputId =} \StringTok{"caption"}\NormalTok{,}
      \DataTypeTok{label =} \StringTok{"Caption"}\NormalTok{,}
      \DataTypeTok{value =} \StringTok{"Data Summary"}\NormalTok{,}
      \DataTypeTok{binding_step =}\NormalTok{ binding_step}
\NormalTok{    ),}
    \KeywordTok{textOutput}\NormalTok{(}\StringTok{"custom_text"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{  server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{    output}\OperatorTok{$}\NormalTok{custom_text <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(input}\OperatorTok{$}\NormalTok{caption)}
\NormalTok{  \}}
  \KeywordTok{shinyApp}\NormalTok{(ui, server)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We open the developer tools to inspect the \texttt{customTextInputBinding.js} script, put a breakpoints in the \texttt{find} method and reload the page. Upon reload, the JavaScript debugger opens, as shown Figure \ref{fig:binding-find}. Type \texttt{\$(scope).find(\textquotesingle{}.input-text\textquotesingle{})} in the console and see what is displayed. This is the DOM element which you may highlight when you hover over the JavaScript output.

Building input bindings like this significantly ease the debugging process and you'll get more chances to be successful!

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-find} \caption{Find is the first method triggered}\label{fig:binding-find}
\end{figure}

Now, let's see why it is better to target elements by type or class. We run the \texttt{customTextInputExampleBis()} example. This is a demonstration app containing two text inputs. Moreover, the binding has been modified so that it looks for element having a specific id:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
  \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{'#mytextInput'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you repeat the above debugging steps, \texttt{\$(scope).find(\textquotesingle{}.input-text\textquotesingle{})} only targets the
first text input, meaning that the second input will not be found and bound, as demonstrated in Figure \ref{fig:binding-find-by-id}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-find-by-id} \caption{Find by id is a rather bad idea}\label{fig:binding-find-by-id}
\end{figure}

As a side note, you'll also get an error in the binding (\texttt{Uncaught\ Not\ implemented}), indicating that the \texttt{getValue} method is not implemented yet. Fear not! We are going to
add it very soon.

\hypertarget{initialize-inputs}{%
\subsubsection{Initialize inputs}\label{initialize-inputs}}

Upon initialization, Shiny calls the \texttt{initializeInputs} function that takes all input bindings and call their \texttt{initialize} method before binding all inputs. Note that once an input has been initialized, it has a \texttt{\_shiny\_initialized} tag to avoid initializing it twice. The initialize method is not always defined but some elements require to be explicitly initialized or activated. For instance the \href{https://framework7.io}{Framework7} API, on top of which \href{https://github.com/RinteRface/shinyMobile}{shinyMobile} is built, require to instantiate all elements. Below is an example for the \href{https://framework7.io/docs/toggle.html}{toggle} input:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// what is expected}
\KeywordTok{let}\NormalTok{ toggle }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{toggle}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}
  \DataTypeTok{el}\OperatorTok{:} \StringTok{'.toggle'}\OperatorTok{,}
  \DataTypeTok{on}\OperatorTok{:} \OperatorTok{\{}
    \DataTypeTok{change}\OperatorTok{:} \KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
      \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{'Toggle changed'}\NormalTok{)}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{el:\ \textquotesingle{}.toggle\textquotesingle{}} means that we are looking at the element(s) having the \texttt{toggle} class. \texttt{app.toggle.create} is internal to the Framework7 API. The corresponding shinyMobile input binding starts as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ f7ToggleBinding }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{InputBinding}\NormalTok{()}\OperatorTok{;}
  \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(f7ToggleBinding}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{initialize}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
      \VariableTok{app}\NormalTok{.}\VariableTok{toggle}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}\DataTypeTok{el}\OperatorTok{:}\NormalTok{ el}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \CommentTok{// other methods}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Once initialized, we may use all specific methods provided by the API. \href{https://framework7.io}{Framework7} is clearly a gold mine, as its API provides many possible options for many inputs / widgets. We provide more examples in Chapters \ref{mobile-shinyMobile} and \ref{mobile-widgets}.

\hypertarget{get-the-value}{%
\subsubsection{Get the value}\label{get-the-value}}

\texttt{getValue(el)} returns the input value. The way to obtain the value is different for almost all inputs. For instance, the \texttt{textInput} is pretty simple since the value is located in the \texttt{value} attribute. \texttt{el} refers to the element holding the id attribute and recognized by the \texttt{find} method. Figure \ref{fig:shiny-el} shows the result of a \texttt{console.log(\$(el));}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-el} \caption{About el}\label{fig:shiny-el}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\AttributeTok{$}\NormalTok{(el))}\OperatorTok{;}
  \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{val}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

To get the value, we apply the jQuery method \texttt{val} on the \texttt{\$(el)} element and return the result.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{customTextInputExample}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This time, the input value is returned. Notice that when you try to change the text content, the output value does not update as we would normally expect. We are actually missing a couple of methods so that the binding is fully working. We will introduce them in the following sections!

Similarly as in the find section, we run \texttt{customTextInputExample(2)} and open the developer tools to inspect the \texttt{customTextInputBinding.js} script. We put a breakpoints in the \texttt{getValue} method and reload the page. Upon reload, the JavaScript debugger opens starts in \texttt{find}. You may click on the next blue arrow to jump to the next breakpoints that is \texttt{getValue}, as shown Figure \ref{fig:binding-getValue}. Typing \texttt{\$(el).val()} in the console shows the current
text value.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-getValue} \caption{getValue returns the current input value}\label{fig:binding-getValue}
\end{figure}

Clicking on next again exit the debugger. Interestingly, you'll notice that a text appears below the input, meaning that the \texttt{input\$caption} element exists and
is internally tracked by shiny.

\hypertarget{set-and-update}{%
\subsubsection{Set and update}\label{set-and-update}}

\texttt{setValue(el,\ value)} is used to set the value of the current input. This method is necessary so that the input value may be updated. It has to be used in combination with \texttt{receiveMessage(el,\ data)}, which is the JavaScript part of all the R \texttt{updateInput} functions. We usually call the \texttt{setValue} method inside.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ value) }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{val}\NormalTok{(value)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Let's create a function to update our custom text input. Call it \texttt{updateCustomTextInput}. It requires at least 3 parameters:

\begin{itemize}
\tightlist
\item
  inputId tells which input to update.
\item
  value is the new value. This will be taken by the \texttt{setValue} JS method in the input binding
\item
  session is the Shiny session object mentioned earlier. We will use the \texttt{sendInputMessage} to send values from R to JavaScript. The \texttt{receiveMessage} method will apply \texttt{setValue} with the data received from R.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{updateCustomTextInput <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, }\DataTypeTok{value =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, }\DataTypeTok{message =}\NormalTok{ value)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We add \texttt{setValue} and \texttt{receiveMessage} to custom input binding.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{updateCustomTextInputExample}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Figure \ref{fig:shiny-update-inputs} illustrates the main mechanisms.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-update-inputs} \caption{Events following a click on the update button. This figure demonstrates how R and JS communicate, through the websocket.}\label{fig:shiny-update-inputs}
\end{figure}

If we have to pass multiple elements to update, we would have to change the \texttt{updateCustomTextInput} function such as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{updateCustomTextInput <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, }\DataTypeTok{value =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{placeholder =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{dropNulls}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{value =}\NormalTok{ value,}
      \DataTypeTok{placeholder =}\NormalTok{ placeholder}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{dropNulls} is an internal function ensuring that the list does not contain NULL elements. We send a list from R, which is then serialized to a JSON object. In the \texttt{receiveMessage} method, properties like \texttt{value} may be accessed using the . notation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(data)}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{data}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{'value'}\NormalTok{)) }\OperatorTok{\{}
    \KeywordTok{this}\NormalTok{.}\AttributeTok{setValue}\NormalTok{(el}\OperatorTok{,} \VariableTok{data}\NormalTok{.}\AttributeTok{value}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
  \CommentTok{// other parameters to update...}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Similarly as in the previous sections, we run \texttt{updateCustomTextInputExample(3)} and open the developer tools to inspect the \texttt{customTextInputBinding.js} script. We put a breakpoints in the \texttt{receiveMessage} and \texttt{setValue} methods and reload the page. Upon reload, the JavaScript debugger opens starts in \texttt{find}. You may click on the next blue arrow until you reach \texttt{receiveMessage}, as shown Figure \ref{fig:binding-receive}. Inspecting the \texttt{data} object, it contains only one property namely the value. In practice, there may be more complex structure. As an exercise, you may change the \texttt{data.value} to whatever value you want.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-receive} \caption{Receive a message from R}\label{fig:binding-receive}
\end{figure}

Click on the next arrow makes us jump in the next call that is \texttt{setValue}, where we can print the value to check whether it is correct. Running \texttt{\$(el).val(value);} in the debugger console instantaneously update the DOM element with the new text, as shown on Figure \ref{fig:binding-setValue}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-setValue} \caption{Set the new value}\label{fig:binding-setValue}
\end{figure}

So far so good! We managed to update the text input value on the client. Yet, after clicking the button, the output value does not change. We are going to fix this missing step in the next section.

\hypertarget{subscribe}{%
\subsubsection{Subscribe}\label{subscribe}}

\texttt{subscribe(el,\ callback)} listens to events defining Shiny to update the input value and make it available in the app. Some API like Bootstrap explicitly mention those events (like \texttt{hide.bs.tab}, \texttt{shown.bs.tab}, \ldots).
Going back to our custom text input, what event would make it change?

\begin{itemize}
\tightlist
\item
  After a key is release on the keyboard. We may listen to \texttt{keyup}
\item
  After copying and pasting any text in the input field or dictating text. The \texttt{input} event may be helpful
\end{itemize}

We may add those \href{https://javascript.info/events-change-input}{events} to our binding using an event listener seen at the end of Chapter \ref{survival-kit-javascript}.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'keyup.customTextBinding input.customTextBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \AttributeTok{callback}\NormalTok{(}\KeywordTok{true}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{callback} ensures that the new value is captured by Shiny. We will come back later on the callback parameter, which is rather complex.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{updateCustomTextInputExample}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We run the above example, open the HTML inspector, select the \texttt{customTextInputBinding\_4.js} script and put a break point in the \texttt{getValue} as well as \texttt{subscribe} method. We enter a new text inside the input field, which triggers the debugger inside the \texttt{subscribe} call.
Inspecting the event object, the type indicate the action, which is an input action and the target is the text input element itself, depicted on Figure \ref{fig:binding-subscribe-1}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-subscribe-1} \caption{Subscribe method after a manual update of the text input}\label{fig:binding-subscribe-1}
\end{figure}

We click on next and notice that we go back in the \texttt{getValue} method to get the new value.
You may check typing \texttt{\$(el).val()} in the debugger console, like on Figure \ref{fig:binding-subscribe-2}. Clicking next again shows the updated output value.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-subscribe-2} \caption{Subscribe is followed by a new getValue}\label{fig:binding-subscribe-2}
\end{figure}

Hooray! The output result is successfully changed when the input value is manually updated. However, it is not modified when we click on the update button. What did we miss? Looking back at the \texttt{receiveMessage} method, we changed the input value but how does Shiny knows that this step was successful? To check that no event is raised, we put a \texttt{console.log(event);} in the \texttt{subscribe} method. Any action like removing the text content or adding new text triggers event but clicking on the action button does not. Therefore, we must trigger an event and add it to the \texttt{subscribe} method. We may choose the \texttt{change} event, that triggers when an element is updated. Notice the parameter passed to callback. We discuss it in the next part!

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'change.customTextBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \AttributeTok{callback}\NormalTok{(}\KeywordTok{false}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Besides, in the \texttt{receiveMessage} we must trigger a \texttt{change} event to trigger the subscribe method:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{data}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{'value'}\NormalTok{)) }\OperatorTok{\{}
    \KeywordTok{this}\NormalTok{.}\AttributeTok{setValue}\NormalTok{(el}\OperatorTok{,} \VariableTok{data}\NormalTok{.}\AttributeTok{value}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{trigger}\NormalTok{(}\StringTok{'change'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Let's try again.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{updateCustomTextInputExample}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We put a new break point in the second event listener, that is the one for the change event. Clicking on the button only triggers the change event, as shown Figure \ref{fig:binding-subscribe-3}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-subscribe-3} \caption{We may add multiple event listeners inside the subscribe method}\label{fig:binding-subscribe-3}
\end{figure}

\textbf{Note}: in some situations, we have to be careful with the \texttt{this} element. Indeed, called in an event listener, \texttt{this} refers to the element that triggered the event and not to the input binding object. For instance below is an example where we need to trigger the \texttt{getValue} method inside an event listener located in the \texttt{subscribe} method. If you call \texttt{this.getValue(el)}, you'll get an error. The trick consists in creating a variable namely \texttt{self} that take \texttt{this} as value, outside the event listener. In that case \texttt{self} refers to the binding itself and it make sens to call \texttt{self.getValue(el)}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
\NormalTok{  self }\OperatorTok{=} \KeywordTok{this}\OperatorTok{;}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'click.button'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ currentVal }\OperatorTok{=} \VariableTok{self}\NormalTok{.}\AttributeTok{getValue}\NormalTok{(el)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{val}\NormalTok{(currentVal }\OperatorTok{+} \DecValTok{1}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Perfect? Not exactly.

\hypertarget{setting-rate-policies}{%
\subsubsection{Setting rate policies}\label{setting-rate-policies}}

It would be better to only change the input value once the keyboard is completely released for some time (and not each time a key is released). This is what we call debouncing, which allows a delay before telling Shiny to read the new value, and is achieved using the \texttt{getRatePolicy} method. Additionally, we must also pass \texttt{true} to the \texttt{callback} in the subscribe method, in order to apply our specific rate policy (\href{https://davidwalsh.name/javascript-debounce-function}{debounce}, throttle). This is useful for instance when we don't want to flood the server with useless update requests. For example when using a slider, we only want to send the value as soon as the range stops moving and not all intermediate values. Those elements are defined \href{https://github.com/rstudio/shiny/blob/master/srcjs/input_rate.js}{here}.

Run the app below and try to manually change the text input value by adding a couple of letters as fast as you can. What do you notice? We see the output value only updates when we release the keyboard.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{customTextInputExample}\NormalTok{(}\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You may adjust the delay according to your needs, but we caution to not set the delay too long as this becomes problematic too.

If you want to get an overview of all binding steps, you may try the following \href{https://rinterface.com/shiny/talks/RPharma2020/?panelset1=r-code2\#45}{slide} from the 2020 R in Pharma workshop.

\hypertarget{register-an-input-binding}{%
\subsubsection{Register an input binding}\label{register-an-input-binding}}

At the end of the input binding definition, we register it for Shiny.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ myBinding }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{inputBinding}\NormalTok{()}\OperatorTok{;}
  \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(myBinding}\OperatorTok{,} \OperatorTok{\{}
  \CommentTok{// methods go here}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\VariableTok{Shiny}\NormalTok{.}\VariableTok{inputBindings}\NormalTok{.}\AttributeTok{register}\NormalTok{(myBinding}\OperatorTok{,} \StringTok{'reference'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Although the Shiny \href{https://shiny.rstudio.com/articles/building-inputs.html}{documentation} mentions a \texttt{Shiny.inputBindings.setPriority} method to handle conflicting bindings, this case almost never happens.

\hypertarget{other-binding-methods}{%
\subsubsection{Other binding methods}\label{other-binding-methods}}

There are a couple of methods not described above that are contained in the \texttt{InputBinding} class prototype. They were not described before since most of the time, we don't need to change them and can rely on the defaults:

\begin{itemize}
\tightlist
\item
  \texttt{getId} returns the object id (Figure \ref{fig:binding-getId}). If you don't provide your own method, the binding falls back to the default one provided in the \texttt{InputBinding} class. This method is called after \texttt{find}. The next Chapter \ref{shiny-input-lifecycle} provides more details.
\item
  \texttt{getType} required to handle custom data format. It is called after \texttt{getId}. See section \ref{custom-data-format}.
\item
  \texttt{getState} ?
\end{itemize}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-getId} \caption{The binding getId method}\label{fig:binding-getId}
\end{figure}

\hypertarget{edit-input-binding}{%
\subsection{Edit an input binding}\label{edit-input-binding}}

In some cases, we would like to access the input binding and change it's default behavior, even though not always recommended, since it will affect \textbf{all} related inputs. As bindings are contained in a registry, namely \texttt{Shiny.inputBindings}, one may seamlessly access and modify them. This is a 5 steps process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Wait for the \texttt{shiny:connected} \href{https://shiny.rstudio.com/articles/js-events.html}{event}
\item
  Unbind all inputs with \texttt{Shiny.unbindAll()}
\item
  Access the binding registry, \texttt{Shiny.inputBindings}
\item
  Extend the binding and edit its content with \texttt{\$.extend(...\ \{...\})}
\item
  Apply the new changes with \texttt{Shiny.bindAll()}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(document).}\AttributeTok{on}\NormalTok{(}\StringTok{'shiny:connected'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{unbindAll}\NormalTok{()}\OperatorTok{;}
    \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(Shiny}
\NormalTok{      .}\AttributeTok{inputBindings}
\NormalTok{      .}\AttributeTok{bindingNames}\NormalTok{[}\StringTok{'shiny.actionButtonInput'}\NormalTok{]}
\NormalTok{      .}\AttributeTok{binding}\OperatorTok{,} \OperatorTok{\{}
        \CommentTok{// do whathever you want to edit existing methods}
      \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{bindAll}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{update-a-binding-from-the-client}{%
\subsection{Update a binding from the client}\label{update-a-binding-from-the-client}}

The interest of \texttt{receiveMessage} and \texttt{setValue} is to be able to update the input
from the server side, that is R, through the \texttt{session\$sendInputMessage}. Yet,
this task might be done directly on the client, thereby lowering the load on the server.
We consider the following example: a shiny app contains 2 actions buttons, clicking on the first one
increases the value of the second by 10. This won't be possible with the classic approach since a button click
only increases by 1. How do we proceed?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We first set an event listener on the first button.
\item
  We target the second button and get the input binding with \texttt{\$obj.data(\textquotesingle{}shiny-input-binding\textquotesingle{})}
\item
  We recover the current value
\item
  We call the \texttt{setValue} method of the input binding adding 10 to the current value
\item
  Importantly, to let Shiny update the value on the R side, we must trigger an event that will be detected in the \texttt{subscribe} method of the action button input binding. The action button only has 1 event listener but other may be added. Don't forget that triggering a \texttt{click} event would also increment the button value by 1! In the following we have to customize the \texttt{subscribe} method to work around:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// each time we click on #test (a button)}
  \AttributeTok{$}\NormalTok{(}\StringTok{'#button1'}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ $obj }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#button2'}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ inputBinding }\OperatorTok{=} \VariableTok{$obj}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'shiny-input-binding'}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ val }\OperatorTok{=} \VariableTok{$obj}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\NormalTok{) }\OperatorTok{||} \DecValTok{0}\OperatorTok{;}
    \VariableTok{inputBinding}\NormalTok{.}\AttributeTok{setValue}\NormalTok{($obj}\OperatorTok{,}\NormalTok{ val }\OperatorTok{+} \DecValTok{10}\NormalTok{)}\OperatorTok{;}
    \VariableTok{$obj}\NormalTok{.}\AttributeTok{trigger}\NormalTok{(}\StringTok{'event'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If you click on the second button, the value increments only by 1 and the plot will be only visible after 10 clicks, while only 1 click is necessary on the first button. The reset button resets the second action button value to 0. It implements the feature discussed in the previous part, where we extend the button binding to add a \texttt{reset} method and edit the \texttt{subscribe} method to add a \texttt{change} event listener, simply telling shiny to get the new value. Contrary to \texttt{click}, \texttt{change} does not increment the button value.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(}\VariableTok{Shiny}\NormalTok{.}\VariableTok{inputBindings}\NormalTok{.}\AttributeTok{bindingNames}\NormalTok{[}\StringTok{'shiny.actionButtonInput'}\NormalTok{].}\AttributeTok{binding}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{reset}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
   \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'click.actionButtonInputBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
      \KeywordTok{var}\NormalTok{ $el }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\KeywordTok{this}\NormalTok{)}\OperatorTok{;}
      \KeywordTok{var}\NormalTok{ val }\OperatorTok{=} \VariableTok{$el}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\NormalTok{) }\OperatorTok{||} \DecValTok{0}\OperatorTok{;}
      \VariableTok{$el}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\OperatorTok{,}\NormalTok{ val }\OperatorTok{+} \DecValTok{1}\NormalTok{)}\OperatorTok{;}

      \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
            
    \CommentTok{// this does not trigger any click and won't change the button value            }
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'change.actionButtonInputBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
      \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The whole JS code is found below:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(document).}\AttributeTok{on}\NormalTok{(}\StringTok{'shiny:connected'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{unbindAll}\NormalTok{()}\OperatorTok{;}
    \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(Shiny}
\NormalTok{      .}\AttributeTok{inputBindings}
\NormalTok{      .}\AttributeTok{bindingNames}\NormalTok{[}\StringTok{'shiny.actionButtonInput'}\NormalTok{]}
\NormalTok{      .}\AttributeTok{binding}\OperatorTok{,} \OperatorTok{\{}
        \DataTypeTok{reset}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
         \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
        \OperatorTok{\},}
        \DataTypeTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
          \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'click.actionButtonInputBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
            \KeywordTok{var}\NormalTok{ $el }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\KeywordTok{this}\NormalTok{)}\OperatorTok{;}
            \KeywordTok{var}\NormalTok{ val }\OperatorTok{=} \VariableTok{$el}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\NormalTok{) }\OperatorTok{||} \DecValTok{0}\OperatorTok{;}
            \VariableTok{$el}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\OperatorTok{,}\NormalTok{ val }\OperatorTok{+} \DecValTok{1}\NormalTok{)}\OperatorTok{;}

            \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
          \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
                
          \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'change.actionButtonInputBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
            \ControlFlowTok{debugger}\OperatorTok{;}
            \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
          \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
              
        \OperatorTok{\}}
      \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{bindAll}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
      
  \AttributeTok{$}\NormalTok{(}\StringTok{'#button1'}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ $obj }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#button2'}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ inputBinding }\OperatorTok{=} \VariableTok{$obj}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'shiny-input-binding'}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ val }\OperatorTok{=} \VariableTok{$obj}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\NormalTok{) }\OperatorTok{||} \DecValTok{0}\OperatorTok{;}
    \VariableTok{inputBinding}\NormalTok{.}\AttributeTok{setValue}\NormalTok{($obj}\OperatorTok{,}\NormalTok{ val }\OperatorTok{+} \DecValTok{10}\NormalTok{)}\OperatorTok{;}
    \VariableTok{$obj}\NormalTok{.}\AttributeTok{trigger}\NormalTok{(}\StringTok{'change'}\NormalTok{)}\OperatorTok{;} 
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  
  \AttributeTok{$}\NormalTok{(}\StringTok{'#reset'}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ $obj }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#button2'}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ inputBinding }\OperatorTok{=} \VariableTok{$obj}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'shiny-input-binding'}\NormalTok{)}\OperatorTok{;}
    \VariableTok{inputBinding}\NormalTok{.}\AttributeTok{reset}\NormalTok{($obj)}\OperatorTok{;}
    \VariableTok{$obj}\NormalTok{.}\AttributeTok{trigger}\NormalTok{(}\StringTok{'change'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Below is the working app:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{editBindingExample}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

whose output is shown Figure \ref{fig:edit-binding-demo}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/edit-binding-demo} \caption{Edit and trigger an input binding from the client}\label{fig:edit-binding-demo}
\end{figure}

This trick has been extensively used in the \href{https://community.rstudio.com/t/shiny-contest-submission-a-virtual-lab-for-teaching-physiology/25348}{virtual physiology simulator} to trigger \href{https://dgranjon.shinyapps.io/entry_level/}{animations}.

\hypertarget{secondary-inputs}{%
\section{Secondary inputs}\label{secondary-inputs}}

The Shiny input binding system is too convenient to be only used for primary input elements like \texttt{textInput}, \texttt{numericInput}. It is a super powerful tool to unleash apps's interactivity.
In the following, we show how to add an input to an element that was not primarily designed to be a user input.

\hypertarget{shinydashboard-boxes-on-steroids}{%
\subsection{\{shinydashboard\} boxes on steroids}\label{shinydashboard-boxes-on-steroids}}

In \{shinydashboard\}, you may know the \texttt{box} function. Boxes are containers with a title, body, footer, as well as optional elements. It would be nice to capture the state of the box in an input, so as to trigger other actions as soon as this input changes. Since an input value is unique, we must add an \texttt{inputId} parameter to the box function. You may inspect the code \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code/blob/master/R/box2.R}{here}.

Since we may collapse and uncollapse the box, we create the \texttt{updateBox2} function, which will toggle it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{updateBox2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, }\DataTypeTok{message =} \OtherTok{NULL}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When collapsed, a box gets the \texttt{collapsed-box} class, which is useful to keep in mind for the input binding design. As mentioned above, it is also necessary to know when to tell Shiny to update the value with the \texttt{subscribe} method. Most of the time, the change event might be sufficient, but as \texttt{\{shinydashboard\}} is built on top of \href{https://adminlte.io/docs/2.4/js-box-widget}{AdminLTE2}, it has an API to control the box behavior. We identify 2 events corresponding to the collapsible action:

\begin{itemize}
\tightlist
\item
  expanded.boxwidget (Triggered after the box is expanded)
\item
  collapsed.boxwidget (Triggered after the box is collapsed)
\end{itemize}

Unfortunately, after further investigations, those events are not possible to use since the AdminLTE library does not trigger them in the main JS \href{https://github.com/rstudio/shinydashboard/blob/master/srcjs/AdminLTE/app.js}{code} (see the collapse method line 577-612). There are other solutions, as shown below with the \texttt{click} event. To toggle the box, we use the \texttt{toggleBox} method.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ boxBinding }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{InputBinding}\NormalTok{()}\OperatorTok{;}
\VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(boxBinding}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
    \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{'.box'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
    \KeywordTok{let}\NormalTok{ isCollapsed }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{hasClass}\NormalTok{(}\StringTok{'collapsed-box'}\NormalTok{)}
    \ControlFlowTok{return} \OperatorTok{\{}\DataTypeTok{collapsed}\OperatorTok{:}\NormalTok{ isCollapsed}\OperatorTok{\};} \CommentTok{// this will be a list in R}
  \OperatorTok{\},}
  \DataTypeTok{setValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ value) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{toggleBox}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\},} 
  \DataTypeTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
    \KeywordTok{this}\NormalTok{.}\AttributeTok{setValue}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{trigger}\NormalTok{(}\StringTok{'change'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \StringTok{'[data-widget="collapse"]'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
      \AttributeTok{setTimeout}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
        \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\},} \DecValTok{550}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;} 
    
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'change'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
      \AttributeTok{setTimeout}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
        \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\},} \DecValTok{550}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{unsubscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{off}\NormalTok{(}\StringTok{'.boxBinding'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\VariableTok{Shiny}\NormalTok{.}\VariableTok{inputBindings}\NormalTok{.}\AttributeTok{register}\NormalTok{(boxBinding}\OperatorTok{,} \StringTok{'box-input'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Some comments about the binding:

\begin{itemize}
\tightlist
\item
  \texttt{getValue} returns an object which will give a list in R. This is in case we add other elements like the remove action available in AdminLTE
\item
  \texttt{setValue} calls the plug and play \texttt{toggleBox} method
\item
  \texttt{receiveMessage} must trigger a change event so that Shiny knows when the value needs to be updated
\item
  \texttt{subscribe} listens to the \texttt{click} event on the \texttt{{[}data-widget="collapse"{]}} element and delays the \texttt{callback} call by a value which is slightly higher than the default AdminLTE2 animation to collapse the box (500ms). If you omit this part, the input will not have time to properly update!
\item
  We don't need an extra listener for the \texttt{updateBox2} function since it also triggers a click on the collapse button, thereby forwarding to the corresponding listener
\end{itemize}

Let's try our new toy in a simple app. The output is depicted on Figure \ref{fig:toggle-shinydashboard-box}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/toggle-shinydashboard-box} \caption{{shinydashboard} box with custom input binding listening to the box collapse state}\label{fig:toggle-shinydashboard-box}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \CommentTok{# import shinydashboard deps without the need of the dashboard template}
  \KeywordTok{useShinydashboard}\NormalTok{(),}

\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}\StringTok{"body \{ background-color: ghostwhite\};"}\NormalTok{),}

  \KeywordTok{br}\NormalTok{(),}
  \KeywordTok{box2}\NormalTok{(}
   \DataTypeTok{title =} \KeywordTok{textOutput}\NormalTok{(}\StringTok{"box_state"}\NormalTok{),}
   \StringTok{"Box body"}\NormalTok{,}
   \DataTypeTok{inputId =} \StringTok{"mybox"}\NormalTok{,}
   \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
   \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"plot"}\NormalTok{)}
\NormalTok{  ),}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"toggle_box"}\NormalTok{, }\StringTok{"Toggle Box"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"bg-success"}\NormalTok{)}
\NormalTok{ )}

\NormalTok{ server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{plot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{req}\NormalTok{(}\OperatorTok{!}\NormalTok{input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed)}
    \KeywordTok{plot}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{200}\NormalTok{))}
\NormalTok{  \})}

\NormalTok{  output}\OperatorTok{$}\NormalTok{box_state <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(\{}
\NormalTok{    state <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed) }\StringTok{"collapsed"} \ControlFlowTok{else} \StringTok{"uncollapsed"}
    \KeywordTok{paste}\NormalTok{(}\StringTok{"My box is"}\NormalTok{, state)}
\NormalTok{  \})}

  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{toggle_box, \{}
    \KeywordTok{updateBox2}\NormalTok{(}\StringTok{"mybox"}\NormalTok{)}
\NormalTok{  \})}

\NormalTok{ \}}

 \KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Even though animations are nice, it appears rather sub-optimal to wait 500 ms for a box to collapse. AdminLTE \href{https://adminlte.io/themes/AdminLTE/documentation/index.html\#adminlte-options}{options} allow to change this through the \texttt{\$.AdminLTE.boxWidget} object. We specify the \texttt{animationSpeed} property to 10 milliseconds and update the input binding script to reduce the delay in the \texttt{subscribe} method (50 ms seems reasonable). To get a comparison try to run the example below.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# You'll need the devel version of shinydashboardPlus}
\CommentTok{#remotes::install_github("RinteRface/shinydashboardPlus")}

\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{library}\NormalTok{(shinydashboard)}
\KeywordTok{library}\NormalTok{(shinydashboardPlus)}
 
\NormalTok{ ui <-}\StringTok{ }\KeywordTok{dashboardPage}\NormalTok{(}
   \KeywordTok{dashboardHeader}\NormalTok{(),}
   \KeywordTok{dashboardSidebar}\NormalTok{(),}
   \KeywordTok{dashboardBody}\NormalTok{(}
\NormalTok{     tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}\StringTok{"body \{ background-color: ghostwhite\}"}\NormalTok{),}
     \KeywordTok{actionButton}\NormalTok{(}\StringTok{"toggle_box"}\NormalTok{, }\StringTok{"Toggle Box"}\NormalTok{),}
     \KeywordTok{br}\NormalTok{(),}
     \KeywordTok{box}\NormalTok{(}
       \DataTypeTok{title =} \KeywordTok{textOutput}\NormalTok{(}\StringTok{"box_state"}\NormalTok{),}
       \StringTok{"Box body"}\NormalTok{,}
       \DataTypeTok{inputId =} \StringTok{"mybox"}\NormalTok{,}
       \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
       \DataTypeTok{closable =} \OtherTok{TRUE}\NormalTok{,}
       \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"plot"}\NormalTok{)}
\NormalTok{     )}
\NormalTok{   )}
\NormalTok{ )}
 
\NormalTok{ server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{   output}\OperatorTok{$}\NormalTok{plot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
     \KeywordTok{req}\NormalTok{(}\OperatorTok{!}\NormalTok{input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed)}
     \KeywordTok{plot}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{200}\NormalTok{))}
\NormalTok{   \})}
   
\NormalTok{   output}\OperatorTok{$}\NormalTok{box_state <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(\{}
\NormalTok{     state <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed) }\StringTok{"collapsed"} \ControlFlowTok{else} \StringTok{"uncollapsed"}
     \KeywordTok{paste}\NormalTok{(}\StringTok{"My box is"}\NormalTok{, state)}
\NormalTok{   \})}
   
   \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{toggle_box, \{}
     \KeywordTok{updateBox}\NormalTok{(}\StringTok{"mybox"}\NormalTok{, }\DataTypeTok{action =} \StringTok{"toggle"}\NormalTok{)}
\NormalTok{   \})}
   
   
   \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed, \{}
\NormalTok{     collapsed <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed) }\StringTok{"collapsed"} \ControlFlowTok{else} \StringTok{"uncollapsed"}
\NormalTok{     message <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\StringTok{"My box is"}\NormalTok{, collapsed)}
     \KeywordTok{showNotification}\NormalTok{(message, }\DataTypeTok{type =} \StringTok{"warning"}\NormalTok{, }\DataTypeTok{duration =} \DecValTok{1}\NormalTok{)}
\NormalTok{   \})}
   
\NormalTok{ \}}
 
 \KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{going-further}{%
\subsection{Going further}\label{going-further}}

We may imagine leveraging the input binding system to update any box property and get rid of the classic \texttt{renderUI} approach. Indeed, until now, there would be only one way to update a box from the server (Figure \ref{fig:update-shinydashboard-box-1}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \CommentTok{# import shinydashboard deps without the need of the dashboard template}
  \KeywordTok{useShinydashboard}\NormalTok{(),}

\NormalTok{  tags}\OperatorTok{$}\KeywordTok{style}\NormalTok{(}\StringTok{"body \{ background-color: ghostwhite\};"}\NormalTok{),}

  \KeywordTok{br}\NormalTok{(),}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"custom_box"}\NormalTok{),}
  \KeywordTok{selectInput}\NormalTok{(}\StringTok{"background"}\NormalTok{, }\StringTok{"Background"}\NormalTok{, }\DataTypeTok{choices =}\NormalTok{ shinydashboard}\OperatorTok{:::}\NormalTok{validColors)}
\NormalTok{ )}

\NormalTok{ server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{custom_box <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
    \KeywordTok{box2}\NormalTok{(}
      \DataTypeTok{title =} \StringTok{"Box"}\NormalTok{,}
      \StringTok{"Box body"}\NormalTok{,}
      \DataTypeTok{background =}\NormalTok{ input}\OperatorTok{$}\NormalTok{background}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{ \}}

 \KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/update-shinydashboard-box-1} \caption{{shinydashboard} box updated with shiny::renderUI}\label{fig:update-shinydashboard-box-1}
\end{figure}

The whole piece of UI is re-rendered each time, while only the box class should be modified. This does not have much impact here but for a very complex app festooned with inputs/outputs, the overall user experience may be altered.

Let's provide some optimization and get rid of the \texttt{renderUI}. We proceed in 2 steps. The first part consists in customizing the \texttt{box} function to gather as many parameter as possible in an option list. For instance, we choose to extract background, width and title. width and background are expected to be numeric and character, respectively, while title might be any HTML tag, justifying the use of \texttt{as.character}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{box2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{footer =} \OtherTok{NULL}\NormalTok{,}
                 \DataTypeTok{background =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{height =} \OtherTok{NULL}\NormalTok{,}
                 \DataTypeTok{collapsible =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{collapsed =} \OtherTok{FALSE}\NormalTok{) \{}
  
\NormalTok{  props <-}\StringTok{ }\KeywordTok{dropNulls}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{title =} \KeywordTok{as.character}\NormalTok{(title),}
      \DataTypeTok{background =}\NormalTok{ background,}
      \DataTypeTok{width =}\NormalTok{ width}
\NormalTok{    )}
\NormalTok{  )}
  
  \CommentTok{# I removed some of the code to highlight that part}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This properties list has to be treated on the JS side. Before, we must make it accessible within the \texttt{box2}
HTML tag. We choose the following approach, where we convert our properties to a JSON with \texttt{jsonlite::toJSON} and embed them in a script tag. Note the \texttt{data-for} attribute with the unique id parameter. This will guarantee the uniqueness of our configuration script.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{box2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{footer =} \OtherTok{NULL}\NormalTok{,}
                 \DataTypeTok{background =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{height =} \OtherTok{NULL}\NormalTok{,}
                 \DataTypeTok{collapsible =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{collapsed =} \OtherTok{FALSE}\NormalTok{) \{}
  
  \CommentTok{# code not shown}
  
\NormalTok{  boxTag <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{"col-sm-"}\NormalTok{, width), }
\NormalTok{    shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
      \DataTypeTok{id =}\NormalTok{ id,}
      \DataTypeTok{class =}\NormalTok{ boxClass, }
\NormalTok{      headerTag, }
\NormalTok{      shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"box-body"}\NormalTok{, }
        \DataTypeTok{style =}\NormalTok{ style,}
\NormalTok{        ...,}
\NormalTok{        sidebar[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)],}
\NormalTok{      ), }
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(footer)) shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{isTRUE}\NormalTok{(footerPadding)) }\StringTok{"box-footer"} \ControlFlowTok{else} \StringTok{"box-footer no-padding"}\NormalTok{, footer)}
\NormalTok{    ),}
    
    \CommentTok{# this will make our props accessible from JS}
\NormalTok{    shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \DataTypeTok{type =} \StringTok{"application/json"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{data-for}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{id,}
\NormalTok{      jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}
        \DataTypeTok{x =}\NormalTok{ props,}
        \DataTypeTok{auto_unbox =} \OtherTok{TRUE}\NormalTok{,}
        \DataTypeTok{json_verbatim =} \OtherTok{TRUE}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{  boxTag}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Then, we have to update the \texttt{updateBox2} such that it handles both toggle and update possibilities. \texttt{options} contains all updatable properties like background, title and width.
We don't describe the toggle case since it is quite similar to the previous implementations. When the action is \texttt{update}, we enter the if statement and options must be processed. If the option element is a shiny tag or a list of shiny tag (\texttt{tagList}), we convert it to character. The returned message is a vector containing the action as well as the option list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{updateBox2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, }\DataTypeTok{action =} \KeywordTok{c}\NormalTok{(}\StringTok{"toggle"}\NormalTok{, }\StringTok{"update"}\NormalTok{), }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{,}
                      \DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
  \CommentTok{# for update, we take a list of options}
  \ControlFlowTok{if}\NormalTok{ (action }\OperatorTok{==}\StringTok{ "update"}\NormalTok{) \{}
    \CommentTok{# handle case where options are shiny tag or a list of tags ...}
\NormalTok{    options <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(options, }\ControlFlowTok{function}\NormalTok{(o) \{}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(o, }\StringTok{"shiny.tag"}\NormalTok{) }\OperatorTok{||}\StringTok{ }\KeywordTok{inherits}\NormalTok{(o, }\StringTok{"shiny.tag.list"}\NormalTok{)) \{}
\NormalTok{        o <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(o)}
\NormalTok{      \}}
\NormalTok{      o}
\NormalTok{    \})}
\NormalTok{    message <-}\StringTok{ }\KeywordTok{dropNulls}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{action =}\NormalTok{ action, }\DataTypeTok{options =}\NormalTok{ options))}
\NormalTok{    session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(id, message)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(id, }\DataTypeTok{message =}\NormalTok{ action)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

On the JS side, we modify the \texttt{setValue} method to import our newly defined properties. The \texttt{boxTag} has two children, the box and the configuration script. \texttt{\$(el)} refers to the box, therefore we have to look one level up to be able to use the \texttt{find} method (find always goes deeper in the DOM), namely \texttt{\$(el).parent()}. From there, we only have to target the script tag \texttt{\$(el).parent().find("script{[}data-for=\textquotesingle{}"\ +\ el.id\ +\ "\textquotesingle{}{]}")}. Once captured in a variable, we parse the corresponding element to convert it to an objects that we can manipulate: for instance \texttt{config.width} returns the initial width. \texttt{value.options.width} will contain the new width value provided in the \texttt{updateBox2} message output. Good practice is to check whether \texttt{value.options.width} exists with \texttt{value.options.hasOwnProperty("width")}. If yes we ensure whether its value and \texttt{config.width} are different. We always choose \texttt{===} which compares the type and the value (\texttt{==} only compares the value such that \texttt{"1"\ ==\ 1} is \texttt{true}). We then call the internal method \texttt{\_updateWidth} which is defined in the input binding. It has 3 parameters, el, o and n (o and n being the old and new values, respectively):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{_updateWidth}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ o}\OperatorTok{,}\NormalTok{ n) }\OperatorTok{\{}
  \CommentTok{// removes old class}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{parent}\NormalTok{().}\AttributeTok{toggleClass}\NormalTok{(}\StringTok{"col-sm-"} \OperatorTok{+}\NormalTok{ o)}\OperatorTok{;}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{parent}\NormalTok{().}\AttributeTok{addClass}\NormalTok{(}\StringTok{"col-sm-"} \OperatorTok{+}\NormalTok{ n)}\OperatorTok{;} 
  \CommentTok{// trigger resize so that output resize}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{trigger}\NormalTok{(}\StringTok{'resize'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

We must trigger a \texttt{resize} event so that output correctly scale. The internal method is identified by an underscore since it is not an inherited \texttt{Shiny.InputBinding} method.

We finally update the config value by the newly set value and repeat the process for any other property.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ value) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ config }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{parent}\NormalTok{().}\AttributeTok{find}\NormalTok{(}\StringTok{"script[data-for='"} \OperatorTok{+} \VariableTok{el}\NormalTok{.}\AttributeTok{id} \OperatorTok{+} \StringTok{"']"}\NormalTok{)}\OperatorTok{;}
\NormalTok{  config }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{config}\NormalTok{.}\AttributeTok{html}\NormalTok{())}\OperatorTok{;}
  
  \CommentTok{// JS logic}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{value}\NormalTok{.}\AttributeTok{action} \OperatorTok{===} \StringTok{"update"}\NormalTok{) }\OperatorTok{\{}
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{value}\NormalTok{.}\VariableTok{options}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{"width"}\NormalTok{)) }\OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ (}\VariableTok{value}\NormalTok{.}\VariableTok{options}\NormalTok{.}\AttributeTok{width} \OperatorTok{!==} \VariableTok{config}\NormalTok{.}\AttributeTok{width}\NormalTok{) }\OperatorTok{\{}
        \KeywordTok{this}\NormalTok{.}\AttributeTok{_updateWidth}\NormalTok{(el}\OperatorTok{,} \VariableTok{config}\NormalTok{.}\AttributeTok{width}\OperatorTok{,} \VariableTok{value}\NormalTok{.}\VariableTok{options}\NormalTok{.}\AttributeTok{width}\NormalTok{)}
        \VariableTok{config}\NormalTok{.}\AttributeTok{width} \OperatorTok{=} \VariableTok{value}\NormalTok{.}\VariableTok{options}\NormalTok{.}\AttributeTok{width}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
    \CommentTok{// other items to update}
    
    \CommentTok{// replace the old JSON config by the new one to update the input value }
    \AttributeTok{$}\NormalTok{(el)}
\NormalTok{      .}\AttributeTok{parent}\NormalTok{()}
\NormalTok{      .}\AttributeTok{find}\NormalTok{(}\StringTok{"script[data-for='"} \OperatorTok{+} \VariableTok{el}\NormalTok{.}\AttributeTok{id} \OperatorTok{+} \StringTok{"']"}\NormalTok{)}
\NormalTok{      .}\AttributeTok{replaceWith}\NormalTok{(}
        \StringTok{'<script type="application/json" data-for="'} \OperatorTok{+} 
        \VariableTok{el}\NormalTok{.}\AttributeTok{id} \OperatorTok{+} 
        \StringTok{'">'} \OperatorTok{+} 
        \VariableTok{JSON}\NormalTok{.}\AttributeTok{stringify}\NormalTok{(config) }\OperatorTok{+} 
        \StringTok{'</script>'}
\NormalTok{      )}\OperatorTok{;}
    
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \CommentTok{// other tasks}
  \OperatorTok{\}}
  
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Don't forget to update the config script attached to the card tag at the end of the update
condition, otherwise the input value won't be updated:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(el)}
\NormalTok{  .}\AttributeTok{parent}\NormalTok{()}
\NormalTok{  .}\AttributeTok{find}\NormalTok{(}\StringTok{"script[data-for='"} \OperatorTok{+} \VariableTok{el}\NormalTok{.}\AttributeTok{id} \OperatorTok{+} \StringTok{"']"}\NormalTok{)}
\NormalTok{  .}\AttributeTok{replaceWith}\NormalTok{(}
    \StringTok{'<script type="application/json" data-for="'} \OperatorTok{+} 
    \VariableTok{el}\NormalTok{.}\AttributeTok{id} \OperatorTok{+} 
    \StringTok{'">'} \OperatorTok{+} 
    \VariableTok{JSON}\NormalTok{.}\AttributeTok{stringify}\NormalTok{(config) }\OperatorTok{+} 
    \StringTok{'</script>'}
\NormalTok{  )}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If it represents a significant amount of work, it is also the guarantee to lower the load on the server side, thereby offering a faster end user experience. A working prototype has been implemented in \texttt{\{shinydashboardPlus\}} and \texttt{\{bs4Dash\}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyAppDir}\NormalTok{(}\KeywordTok{system.file}\NormalTok{(}\StringTok{"vignettes-demos/box-api"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"shinydashboardPlus"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{quick-inputs}{%
\section{Utilities to quickly define new inputs}\label{quick-inputs}}

\hypertarget{introduction-2}{%
\subsection{Introduction}\label{introduction-2}}

If you ever wondered where the \texttt{Shiny.onInputChange} or \texttt{Shiny.setInputValue} comes from (see \href{https://shiny.rstudio.com/articles/communicating-with-js.html}{article}), it is actually defined in the \texttt{initShiny} function.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{exports}\NormalTok{.}\AttributeTok{setInputValue} \OperatorTok{=} \VariableTok{exports}\NormalTok{.}\AttributeTok{onInputChange} \OperatorTok{=} \KeywordTok{function}\NormalTok{(name}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ opts) }\OperatorTok{\{}
\NormalTok{  opts }\OperatorTok{=} \AttributeTok{addDefaultInputOpts}\NormalTok{(opts)}\OperatorTok{;}
  \VariableTok{inputs}\NormalTok{.}\AttributeTok{setInput}\NormalTok{(name}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ opts)}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Briefly, this function avoids creating an input binding. It is faster to code but there is a price to pay: losing the ability to easily update the new input. Indeed, all input functions like \texttt{sliderInput} have their own update function like \texttt{updateSliderInput}, because of the custom input binding system (We will see it very soon)!

\hypertarget{examples-1}{%
\subsection{Examples}\label{examples-1}}

\texttt{Shiny.setInputValues} becomes powerful when combined to the numerous Shiny JavaScript events listed \href{https://shiny.rstudio.com/articles/js-events.html}{here}. This is what
we use in the \href{https://rinterface.github.io/shinyMobile/articles/shinyMobile_tools.html}{shinyMobile} package to store the current device information in a shiny input.
Briefly, Framework7 (on top of which is built shinyMobile) has a method \texttt{Framework7.device}, which gives many \href{https://framework7.io/docs/device.html}{details} related to the user device.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{on}\NormalTok{(}\StringTok{'shiny:connected'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\StringTok{'deviceInfo'}\OperatorTok{,} \VariableTok{Framework7}\NormalTok{.}\AttributeTok{device}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This allows to conditionally display elements and deeply customize the interface.
In the example below, the card will not show on mobile devices.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shinyMobile)}
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{f7Page}\NormalTok{(}
    \DataTypeTok{title =} \StringTok{"My app"}\NormalTok{,}
    \KeywordTok{f7SingleLayout}\NormalTok{(}
      \DataTypeTok{navbar =} \KeywordTok{f7Navbar}\NormalTok{(}
        \DataTypeTok{title =} \StringTok{"shinyMobile info"}\NormalTok{,}
        \DataTypeTok{hairline =} \OtherTok{FALSE}\NormalTok{,}
        \DataTypeTok{shadow =} \OtherTok{TRUE}
\NormalTok{      ),}
      \CommentTok{# main content}
      \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"card"}\NormalTok{),}
      \KeywordTok{verbatimTextOutput}\NormalTok{(}\StringTok{"info"}\NormalTok{),}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output, session) \{}
    
\NormalTok{    output}\OperatorTok{$}\NormalTok{info <-}\StringTok{ }\KeywordTok{renderPrint}\NormalTok{(input}\OperatorTok{$}\NormalTok{shinyInfo)}

    \CommentTok{# generate a card only for desktop}
\NormalTok{    output}\OperatorTok{$}\NormalTok{card <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{input}\OperatorTok{$}\NormalTok{deviceInfo}\OperatorTok{$}\NormalTok{desktop) \{}
        \KeywordTok{f7Card}\NormalTok{(}
          \StringTok{"This is a simple card with plain text,}
\StringTok{          but cards can also contain their own header,}
\StringTok{          footer, list view, image, or any other element."}
\NormalTok{        )}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{f7Toast}\NormalTok{(}
\NormalTok{          session, }
          \StringTok{"You are on desktop! The card will not display"}\NormalTok{, }
          \DataTypeTok{position =} \StringTok{"center"}
\NormalTok{        )}
\NormalTok{      \}}
\NormalTok{    \})}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{custom-data-format}{%
\section{Custom data format}\label{custom-data-format}}

In some cases, the automatic Shiny R to JS data management may not meet our needs.

\hypertarget{the-dirty-way}{%
\subsection{The dirty way}\label{the-dirty-way}}

For instance, assume we create a date in JS with \texttt{new\ Date()} and store it in a shiny input with \texttt{Shiny.setInputValue}. On the R side, we will not obtain a date but a character, which is not convenient. This is where input handlers are useful since they allow to manipulate data generated on the JS side before injecting them in R. Such handlers are created with \texttt{shiny::registerInputHandler} that takes 2 parameters:

\begin{itemize}
\tightlist
\item
  type allows to connect the handler to \texttt{Shiny.setInputValue}. Note that the id is followed by the handler type, for instance \texttt{Shiny.setInputValue(\textquotesingle{}test:handler\textquotesingle{},\ ...)} is connected to \texttt{shiny::registerInputHandler(\textquotesingle{}handler\textquotesingle{},\ ...)}. As recommended by the Shiny documentation, if the input handler is part of a package, it is best practice to name it like \texttt{packageName.widgetName}.
\item
  a function to transform data, having data as main parameter
\end{itemize}

Below we exceptionally include JS code directly in the shiny app snippet, which is not best practice but convenient for the demonstration. Only the second input will give the correct result.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{registerInputHandler}\NormalTok{(}\StringTok{"OSUICode.textDate"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(data, ...) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(data)) \{}
    \OtherTok{NULL}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    res <-}\StringTok{ }\KeywordTok{try}\NormalTok{(}\KeywordTok{as.Date}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(data)), }\DataTypeTok{silent =} \OtherTok{TRUE}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ (}\StringTok{"try-error"} \OperatorTok{%in%}\StringTok{ }\KeywordTok{class}\NormalTok{(res)) \{}
      \KeywordTok{warning}\NormalTok{(}\StringTok{"Failed to parse dates!"}\NormalTok{)}
      \CommentTok{# as.Date(NA)}
\NormalTok{      data}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      res}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}, }\DataTypeTok{force =} \OtherTok{TRUE}\NormalTok{)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function()\{}
\StringTok{      $(document).on('shiny:connected', function() \{}
\StringTok{        var currentTime = new Date();}
\StringTok{        Shiny.setInputValue('time1', currentTime);}
\StringTok{        Shiny.setInputValue('time2:OSUICode.textDate', currentTime);}
\StringTok{      \});}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  ),}
  \KeywordTok{verbatimTextOutput}\NormalTok{(}\StringTok{"res1"}\NormalTok{),}
  \KeywordTok{verbatimTextOutput}\NormalTok{(}\StringTok{"res2"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{res1 <-}\StringTok{ }\KeywordTok{renderPrint}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{class}\NormalTok{(input}\OperatorTok{$}\NormalTok{time1), input}\OperatorTok{$}\NormalTok{time1))}
\NormalTok{  output}\OperatorTok{$}\NormalTok{res2 <-}\StringTok{ }\KeywordTok{renderPrint}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{class}\NormalTok{(input}\OperatorTok{$}\NormalTok{time2), input}\OperatorTok{$}\NormalTok{time2))}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-clean-way-leverage-gettype}{%
\subsection{\texorpdfstring{The clean way: leverage \texttt{getType}}{The clean way: leverage getType}}\label{the-clean-way-leverage-gettype}}

The cleanest way is to leverage the \texttt{getType} method from the \texttt{InputBinding} class.
Let's take our text input so that it handles dates. On the R side, in the \texttt{customTextInput()} function, we check the current value's type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{type <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(value, }\StringTok{"Date"}\NormalTok{)) \{}
  \StringTok{"date"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \OtherTok{NULL}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We add a custom data attribute to the input tag, which won't be displayed if the value is not a date:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tags}\OperatorTok{$}\KeywordTok{input}\NormalTok{(}
  \DataTypeTok{id =}\NormalTok{ inputId,}
  \DataTypeTok{type =} \StringTok{"text"}\NormalTok{,}
  \DataTypeTok{class =} \StringTok{"form-control input-text"}\NormalTok{,}
  \DataTypeTok{value =}\NormalTok{ value,}
  \DataTypeTok{placeholder =}\NormalTok{ placeholder,}
  \StringTok{`}\DataTypeTok{data-data-type}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{type}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We then define our custom handler. This code is run when the package is loaded and usually located in a \texttt{zzz.R} script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{.onLoad <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{registerInputHandler}\NormalTok{(}\StringTok{"OSUICode.textDate"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(data, ...) \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(data)) \{}
      \OtherTok{NULL}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      res <-}\StringTok{ }\KeywordTok{try}\NormalTok{(}\KeywordTok{as.Date}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(data)), }\DataTypeTok{silent =} \OtherTok{TRUE}\NormalTok{)}
      \ControlFlowTok{if}\NormalTok{ (}\StringTok{"try-error"} \OperatorTok{%in%}\StringTok{ }\KeywordTok{class}\NormalTok{(res)) \{}
        \KeywordTok{warning}\NormalTok{(}\StringTok{"Failed to parse dates!"}\NormalTok{)}
        \CommentTok{# as.Date(NA)}
\NormalTok{        data}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        res}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}, }\DataTypeTok{force =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Note}: shiny already handles dates and we could use the built-in input handler. The current handler was only designed for teaching purposes.

On the JavaScript side, we refer to the \texttt{OSUICode.textDate} defined input handler. We recover the \texttt{data-type} value passed from R and call the handler if the type is a date. We return \texttt{false} otherwise, which is the default behavior:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{getType}\OperatorTok{:} \KeywordTok{function} \AttributeTok{getType}\NormalTok{(el) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ dataType }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{"data-type"}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (dataType }\OperatorTok{===} \StringTok{"date"}\NormalTok{) }\ControlFlowTok{return} \StringTok{"OSUICode.textDate"}\OperatorTok{;}
  \CommentTok{// if (dataType === "date") return "shiny.date"}
  \ControlFlowTok{else} \ControlFlowTok{return} \KeywordTok{false}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

To use the shiny built-in handler we could return \texttt{"shiny.date"} instead. We then run:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{customTextInputHandlerExample}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

which sets the value as text by default. After opening the HTML inspector and setting a break point in the \texttt{getType} method (Figure \ref{fig:binding-getType-1}), we check that the data type is not defined. Therefore the input handler will not apply.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-getType-1} \caption{Example where getType does not call the input handler}\label{fig:binding-getType-1}
\end{figure}

For the second example, we give a date value to the function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{customTextInputHandlerExample}\NormalTok{(}\DecValTok{7}\NormalTok{, }\KeywordTok{Sys.Date}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

As illustrated Figure \ref{fig:binding-getType-2}, the date is properly processed. Moreover, if you type any other valid date in the text field like \texttt{2020-11-12}, it will be recognized as a date, while entering a text will return a character element. This is a way to obtain a slightly more clever text input widget.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-getType-2} \caption{Passing a date to a text input correctly processes it}\label{fig:binding-getType-2}
\end{figure}

Importantly, since the \texttt{data-type} is set at app startup by checking the class of the value, it will never change later. For instance, if you start the app with the text input value to be a simple text, setting it to a date through the app does not convert it into a date since \texttt{\$(el).data("data-type")} always return \texttt{undefined}! Therefore, if you want to be able to use both text and dates, be sure to wisely set the initial value.

To finish, we could seamlessly make out text input even more clever, by handling numbers. Even though shiny has a \texttt{shiny.number} input \href{https://github.com/rstudio/shiny/blob/master/R/server-input-handlers.R\#L144}{handler}, it simply makes sure that whenever the input is missing a value, NA is returned instead of "".
(Figure \ref{fig:shiny-getType-number}).

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-getType-number} \caption{shiny.number input handler ensures that an empty numericInput returns NA instead of ""}\label{fig:shiny-getType-number}
\end{figure}

What we want is an handler that recognizes the string \texttt{"1"} and convert it to a number. In R, converting a string to a number gives \texttt{NA}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\StringTok{"test"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: NAs introduced by coercion
\end{verbatim}

\begin{verbatim}
## [1] NA
\end{verbatim}

Therefore, if we obtain NA, we return original data so that the input returns the correct type. Right after our previous handler, we can write:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{registerInputHandler}\NormalTok{(}\StringTok{"OSUICode.textNumber"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(data, ...) \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(data)) \{}
      \OtherTok{NULL}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      res <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(data))}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.na}\NormalTok{(res)) \{}
\NormalTok{        data}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        res}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}, }\DataTypeTok{force =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also update the JavaScript \texttt{getType} method as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{getType}\OperatorTok{:} \KeywordTok{function} \AttributeTok{getType}\NormalTok{(el) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ dataType }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{"data-type"}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (dataType }\OperatorTok{===} \StringTok{"date"}\NormalTok{) }\ControlFlowTok{return} \StringTok{"OSUICode.textDate"}\OperatorTok{;}
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (dataType }\OperatorTok{===} \StringTok{"number"}\NormalTok{) }\ControlFlowTok{return} \StringTok{"OSUICode.textNumber"}\OperatorTok{;}
  \ControlFlowTok{else} \ControlFlowTok{return} \KeywordTok{false}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

On the R side, don't forget to add an extra \texttt{else\ if} statement to the \texttt{customTextInput()} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{type <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(value, }\StringTok{"Date"}\NormalTok{)) \{}
  \StringTok{"date"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(value, }\StringTok{"numeric"}\NormalTok{)) \{}
  \StringTok{"number"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \OtherTok{NULL}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If we run:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{customTextInputHandlerExample}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

we obtain the desired behavior shown Figure \ref{fig:binding-getType-3}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/binding-getType-3} \caption{Passing a number to a text input correctly processes it}\label{fig:binding-getType-3}
\end{figure}

\hypertarget{shiny-input-lifecycle}{%
\chapter{Shiny inputs lifecycles}\label{shiny-input-lifecycle}}

In the following, we recap everything we see from chapter \ref{shiny-intro}.

\hypertarget{app-initialization}{%
\section{App initialization}\label{app-initialization}}

When a shiny apps starts, Shiny runs \texttt{initShiny} on the client. This \href{https://github.com/rstudio/shiny/blob/master/srcjs/init_shiny.js}{function} has 3 main tasks:

\begin{itemize}
\tightlist
\item
  Bind all inputs and outputs with \texttt{\_bindAll()}.
\item
  Initialize all inputs (if necessary) with \texttt{initializeInputs}.
\item
  Initialize the client websocket connection mentioned in the previous chapter \ref{shiny-intro} and send initial values to the server.
\end{itemize}

Most input bindings are in principle bundled in the \texttt{\{shiny\}} package. Some may be user-defined like in \texttt{\{shinyMobile\}} or even in a simple shiny app. In any case,
they are all contained in a binding registry, namely \texttt{inputBindings} built on top the following class (the same apply for output bindings):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ BindingRegistry }\OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{bindings} \OperatorTok{=}\NormalTok{ []}\OperatorTok{;}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{bindingNames} \OperatorTok{=} \OperatorTok{\{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This class has method to \texttt{register} binding. This is the one we call when doing \texttt{Shiny.inputBindings.register(myBinding,\ \textquotesingle{}reference\textquotesingle{});}, which appends the newly created binding to the bindings array.

When shiny starts, it has to find all defined bindings with the \texttt{getBindings} method.
Once done, for each binding, \texttt{find} is triggered. If no corresponding element is found in the DOM, nothing is done. For each found input, the following methods are triggered:

\begin{itemize}
\tightlist
\item
  \texttt{getId} (no described before) returns the input id. This ensures the uniqueness and is critical!
\item
  \texttt{getType} optionally handles any \texttt{registerInputHandler} defined by the user on the R side.
\item
  \texttt{getValue} gets the initial input value.
\item
  \texttt{subscribe} registers event listeners driving the input behavior.
\end{itemize}

The data attribute \texttt{shiny-input-binding} is then added. This allows shiny or any end-users to access the input binding methods from the client (in practice, very few end-users will do that). The \texttt{shiny-bound-input} class is added, the corresponding input is appended to the \texttt{boundInputs} object (listing all bound inputs) and \texttt{shiny:bound} triggered on the client.

Once done, shiny stores all initial values in a variable \texttt{initialInput}, also containing all \href{https://shiny.rstudio.com/articles/client-data.html}{client data} and pass them to the \texttt{Shinyapp.connect} method. As shown in \ref{shiny-intro}, the latter opens the client websocket connection, raises the \texttt{shiny:connected} event and send all values to the server (R). Few time after, \texttt{shiny:sessioninitialized} is triggered.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/init-shiny-recap} \caption{What Shiny does client side on initialization}\label{fig:init-shiny-recap}
\end{figure}

In chapter \ref{shiny-intro}, we briefly described the \texttt{shiny} JavaScript object. As an exercise, let's explore what the \texttt{Shiny.shinyApp} object contains. The definition is located in the shinyapps.js \href{https://github.com/rstudio/shiny/blob/master/srcjs/shinyapp.js}{script}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ ShinyApp }\OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$socket} \OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
  
  \CommentTok{// Cached input values}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$inputValues} \OperatorTok{=} \OperatorTok{\{\};}
  
  \CommentTok{// Input values at initialization (and reconnect)}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$initialInput} \OperatorTok{=} \OperatorTok{\{\};}
  
  \CommentTok{// Output bindings}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$bindings} \OperatorTok{=} \OperatorTok{\{\};}
  
  \CommentTok{// Cached values/errors}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$values} \OperatorTok{=} \OperatorTok{\{\};}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$errors} \OperatorTok{=} \OperatorTok{\{\};}
  
  \CommentTok{// Conditional bindings (show/hide element based on expression)}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$conditionals} \OperatorTok{=} \OperatorTok{\{\};}
  
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$pendingMessages} \OperatorTok{=}\NormalTok{ []}\OperatorTok{;}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$activeRequests} \OperatorTok{=} \OperatorTok{\{\};}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$nextRequestId} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}
  
  \KeywordTok{this}\NormalTok{.}\AttributeTok{$allowReconnect} \OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

It creates several properties, some of them are easy to guess like \texttt{inputValues} or \texttt{initialInput}. Let's run the example below and open the HTML inspector. Notice that the \texttt{sliderInput} is set to 500 at \texttt{t0} (initialization).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
              \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{  ),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Figure \ref{fig:shiny-initial-inputs} shows how to access Shiny's initial input value with \texttt{Shiny.shinyapp.\$initialInput.obs}. After changing the slider position, its value is given by \texttt{Shiny.shinyapp.\$inputValues.obs}. \texttt{\$initialInput} and \texttt{\$inputValues} contains many more elements, however we are only interested in the slider function in this example.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-init-input} \caption{Explore initial input values}\label{fig:shiny-initial-inputs}
\end{figure}

\hypertarget{update-input-lifecycle}{%
\section{Update input}\label{update-input-lifecycle}}

Below we try to explain what are the mechanisms to update an input from the server on the client. As stated above, it all starts with an \texttt{update\textless{}name\textgreater{}Input} function call, which actually sends a message through the current \texttt{session}. This message is received by the client websocket message manager:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{socket}\NormalTok{.}\AttributeTok{onmessage} \OperatorTok{=} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
  \VariableTok{self}\NormalTok{.}\AttributeTok{dispatchMessage}\NormalTok{(}\VariableTok{e}\NormalTok{.}\AttributeTok{data}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

which sends the message to the appropriate \href{https://github.com/rstudio/shiny/blob/master/srcjs/shinyapp.js\#L552}{handler}, that is \texttt{inputMessages}:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{addMessageHandler}\NormalTok{(}\StringTok{'inputMessages'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \CommentTok{// inputMessages should be an array}
  \ControlFlowTok{for}\NormalTok{ (}\KeywordTok{var}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{<} \VariableTok{message}\NormalTok{.}\AttributeTok{length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ $obj }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'.shiny-bound-input#'} \OperatorTok{+} \AttributeTok{$escape}\NormalTok{(message[i].}\AttributeTok{id}\NormalTok{))}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ inputBinding }\OperatorTok{=} \VariableTok{$obj}\NormalTok{.}\AttributeTok{data}\NormalTok{(}\StringTok{'shiny-input-binding'}\NormalTok{)}\OperatorTok{;}

    \CommentTok{// Dispatch the message to the appropriate input object}
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{$obj}\NormalTok{.}\AttributeTok{length} \OperatorTok{>} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
      \KeywordTok{var}\NormalTok{ el }\OperatorTok{=}\NormalTok{ $obj[}\DecValTok{0}\NormalTok{]}\OperatorTok{;}
      \KeywordTok{var}\NormalTok{ evt }\OperatorTok{=} \VariableTok{jQuery}\NormalTok{.}\AttributeTok{Event}\NormalTok{(}\StringTok{'shiny:updateinput'}\NormalTok{)}\OperatorTok{;}
      \VariableTok{evt}\NormalTok{.}\AttributeTok{message} \OperatorTok{=}\NormalTok{ message[i].}\AttributeTok{message}\OperatorTok{;}
      \VariableTok{evt}\NormalTok{.}\AttributeTok{binding} \OperatorTok{=}\NormalTok{ inputBinding}\OperatorTok{;}
      \AttributeTok{$}\NormalTok{(el).}\AttributeTok{trigger}\NormalTok{(evt)}\OperatorTok{;}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\VariableTok{evt}\NormalTok{.}\AttributeTok{isDefaultPrevented}\NormalTok{())}
        \VariableTok{inputBinding}\NormalTok{.}\AttributeTok{receiveMessage}\NormalTok{(el}\OperatorTok{,} \VariableTok{evt}\NormalTok{.}\AttributeTok{message}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In short, this does get the inputId and access the corresponding input binding. Then it triggers the \texttt{shiny:updateinput} \href{https://shiny.rstudio.com/articles/js-events.html}{event} and call the input binding \texttt{receiveMessage} method. This fires \texttt{setValue} and \texttt{subscribe}.
The way \texttt{subscribe} works is not really well covered in the official \href{https://shiny.rstudio.com/articles/building-inputs.html}{documentation}.
The \texttt{callback} function is actually defined during the initialization \href{https://github.com/rstudio/shiny/blob/master/srcjs/init_shiny.js\#L174}{process}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{valueChangeCallback}\NormalTok{(binding}\OperatorTok{,}\NormalTok{ el}\OperatorTok{,}\NormalTok{ allowDeferred) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ id }\OperatorTok{=} \VariableTok{binding}\NormalTok{.}\AttributeTok{getId}\NormalTok{(el)}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (id) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ value }\OperatorTok{=} \VariableTok{binding}\NormalTok{.}\AttributeTok{getValue}\NormalTok{(el)}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ type }\OperatorTok{=} \VariableTok{binding}\NormalTok{.}\AttributeTok{getType}\NormalTok{(el)}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (type)}
\NormalTok{      id }\OperatorTok{=}\NormalTok{ id }\OperatorTok{+} \StringTok{":"} \OperatorTok{+}\NormalTok{ type}\OperatorTok{;}

    \KeywordTok{let}\NormalTok{ opts }\OperatorTok{=} \OperatorTok{\{}
      \DataTypeTok{priority}\OperatorTok{:}\NormalTok{ allowDeferred }\OperatorTok{?} \StringTok{"deferred"}\NormalTok{ : }\StringTok{"immediate"}\OperatorTok{,}
      \DataTypeTok{binding}\OperatorTok{:}\NormalTok{ binding}\OperatorTok{,}
      \DataTypeTok{el}\OperatorTok{:}\NormalTok{ el}
    \OperatorTok{\};}
    \VariableTok{inputs}\NormalTok{.}\AttributeTok{setInput}\NormalTok{(id}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ opts)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{valueChangeCallback} ultimately calls \texttt{inputs.setInput(id,\ value,\ opts)}. The latters involves a rather complex chain of \href{https://github.com/rstudio/shiny/blob/master/srcjs/input_rate.js}{reactions} (which is not described here). Overall, the result is stored in a queue, namely \texttt{pendingData} and sent to the server with \texttt{shinyapp.sendInput}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{this}\NormalTok{.}\AttributeTok{sendInput} \OperatorTok{=} \KeywordTok{function}\NormalTok{(values) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ msg }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{stringify}\NormalTok{(}\OperatorTok{\{}
    \DataTypeTok{method}\OperatorTok{:} \StringTok{'update'}\OperatorTok{,}
    \DataTypeTok{data}\OperatorTok{:}\NormalTok{ values}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

  \KeywordTok{this}\NormalTok{.}\AttributeTok{$sendMsg}\NormalTok{(msg)}\OperatorTok{;}
    
  \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(}\KeywordTok{this}\NormalTok{.}\AttributeTok{$inputValues}\OperatorTok{,}\NormalTok{ values)}\OperatorTok{;}
  \CommentTok{// other things ...}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The message has an \texttt{update} tag and is sent through the client websocket, only if the connection is opened. If not, it is added to the list of pending messages.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{this}\NormalTok{.}\AttributeTok{$sendMsg} \OperatorTok{=} \KeywordTok{function}\NormalTok{(msg) }\OperatorTok{\{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{this}\NormalTok{.}\VariableTok{$socket}\NormalTok{.}\AttributeTok{readyState}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{this}\NormalTok{.}\VariableTok{$pendingMessages}\NormalTok{.}\AttributeTok{push}\NormalTok{(msg)}\OperatorTok{;}
  \OperatorTok{\}}
  \ControlFlowTok{else} \OperatorTok{\{}
    \KeywordTok{this}\NormalTok{.}\VariableTok{$socket}\NormalTok{.}\AttributeTok{send}\NormalTok{(msg)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Finally, current \texttt{inputValues} are updated. On the server side, the new value is received
by the server websocket message handler, that is \texttt{ws\$onMessage(message)}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/update-input-recap} \caption{What Shiny does client side on initialization}\label{fig:update-input-recap}
\end{figure}

\hypertarget{shiny-input-gems}{%
\chapter{Hidden gems about inputs}\label{shiny-input-gems}}

We present some tools that may be useful\ldots TO FINISH

\hypertarget{get-the-last-changed-input}{%
\section{Get the last changed input}\label{get-the-last-changed-input}}

\hypertarget{motivations}{%
\subsection{Motivations}\label{motivations}}

We probably all had this question one day: How can I get the last changed input in Shiny? There are already some methods like this \href{https://stackoverflow.com/questions/31250587/creating-shiny-reactive-variable-that-indicates-which-widget-was-last-modified}{one} provided by Dean Attali.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{runApp}\NormalTok{(}
  \KeywordTok{shinyApp}\NormalTok{(}
    \DataTypeTok{ui =} \KeywordTok{shinyUI}\NormalTok{(}
      \KeywordTok{fluidPage}\NormalTok{(}
        \KeywordTok{textInput}\NormalTok{(}\StringTok{'txt_a'}\NormalTok{, }\StringTok{'Input Text A'}\NormalTok{),}
        \KeywordTok{textInput}\NormalTok{(}\StringTok{'txt_b'}\NormalTok{, }\StringTok{'Input Text B'}\NormalTok{),}
        \KeywordTok{uiOutput}\NormalTok{(}\StringTok{'txt_c_out'}\NormalTok{),}
        \KeywordTok{verbatimTextOutput}\NormalTok{(}\StringTok{"show_last"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{      output}\OperatorTok{$}\NormalTok{txt_c_out <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
        \KeywordTok{textInput}\NormalTok{(}\StringTok{'txt_c'}\NormalTok{, }\StringTok{'Input Text C'}\NormalTok{)}
\NormalTok{      \})}
      
\NormalTok{      values <-}\StringTok{ }\KeywordTok{reactiveValues}\NormalTok{(}
        \DataTypeTok{lastUpdated =} \OtherTok{NULL}
\NormalTok{      )}
      
      \KeywordTok{observe}\NormalTok{(\{}
        \KeywordTok{lapply}\NormalTok{(}\KeywordTok{names}\NormalTok{(input), }\ControlFlowTok{function}\NormalTok{(x) \{}
          \KeywordTok{observe}\NormalTok{(\{}
\NormalTok{            input[[x]]}
\NormalTok{            values}\OperatorTok{$}\NormalTok{lastUpdated <-}\StringTok{ }\NormalTok{x}
\NormalTok{          \})}
\NormalTok{        \})}
\NormalTok{      \})}
      
\NormalTok{      output}\OperatorTok{$}\NormalTok{show_last <-}\StringTok{ }\KeywordTok{renderPrint}\NormalTok{(\{}
\NormalTok{        values}\OperatorTok{$}\NormalTok{lastUpdated}
\NormalTok{      \})}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Shouldn't this be easier? Could we do that from the client instead, thereby reducing the server load?

\hypertarget{javascript-my-friend}{%
\subsection{JavaScript, my friend}\label{javascript-my-friend}}

Here comes our friend, JavaScript. If you insert this snippet in the head of your app, you will be able to get the last changed input (name, value and type).

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{on}\NormalTok{(}\StringTok{'shiny:inputchanged'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\StringTok{'pleaseStayHome'}\OperatorTok{,} \OperatorTok{\{}\DataTypeTok{name}\OperatorTok{:} \VariableTok{event}\NormalTok{.}\AttributeTok{name}\OperatorTok{,} \DataTypeTok{value}\OperatorTok{:} \VariableTok{event}\NormalTok{.}\AttributeTok{value}\OperatorTok{,} \DataTypeTok{type}\OperatorTok{:} \VariableTok{event}\NormalTok{.}\VariableTok{binding}\NormalTok{.}\VariableTok{name}\NormalTok{.}\AttributeTok{split}\NormalTok{(}\StringTok{'.'}\NormalTok{)[}\DecValTok{1}\NormalTok{]}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If you use this code in a custom shiny template, it is possible that input bindings don't have name, which would thereby make \texttt{event.binding.name.split(\textquotesingle{}.\textquotesingle{}){[}1{]}} crash because \texttt{event.binding} is undefined. If so, you may remove this part:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{on}\NormalTok{(}\StringTok{'shiny:inputchanged'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\StringTok{'pleaseStayHome'}\OperatorTok{,} \OperatorTok{\{}\DataTypeTok{name}\OperatorTok{:} \VariableTok{event}\NormalTok{.}\AttributeTok{name}\OperatorTok{,} \DataTypeTok{value}\OperatorTok{:} \VariableTok{event}\NormalTok{.}\AttributeTok{value}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{example}{%
\subsection{Example}\label{example}}

\texttt{\{shinyMobile\}} natively implements this feature that may be accessed with \texttt{input\$lastInputChanged}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shinyMobile)}
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{f7Page}\NormalTok{(}
    \DataTypeTok{title =} \StringTok{"My app"}\NormalTok{,}
    \KeywordTok{f7SingleLayout}\NormalTok{(}
      \DataTypeTok{navbar =} \KeywordTok{f7Navbar}\NormalTok{(}
        \DataTypeTok{title =} \StringTok{"Single Layout"}\NormalTok{,}
        \DataTypeTok{hairline =} \OtherTok{FALSE}\NormalTok{,}
        \DataTypeTok{shadow =} \OtherTok{TRUE}
\NormalTok{      ),}
      \DataTypeTok{toolbar =} \KeywordTok{f7Toolbar}\NormalTok{(}
        \DataTypeTok{position =} \StringTok{"bottom"}\NormalTok{,}
        \KeywordTok{f7Link}\NormalTok{(}\DataTypeTok{label =} \StringTok{"Link 1"}\NormalTok{, }\DataTypeTok{src =} \StringTok{"https://www.google.com"}\NormalTok{),}
        \KeywordTok{f7Link}\NormalTok{(}\DataTypeTok{label =} \StringTok{"Link 2"}\NormalTok{, }\DataTypeTok{src =} \StringTok{"https://www.google.com"}\NormalTok{, }\DataTypeTok{external =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{      ),}
      \CommentTok{# main content,}
      \KeywordTok{f7Card}\NormalTok{(}
        \KeywordTok{f7Text}\NormalTok{(}\DataTypeTok{inputId =} \StringTok{"text"}\NormalTok{, }\DataTypeTok{label =} \StringTok{"Text"}\NormalTok{),}
        \KeywordTok{f7Slider}\NormalTok{(}\DataTypeTok{inputId =} \StringTok{"range1"}\NormalTok{, }\DataTypeTok{label =} \StringTok{"Range"}\NormalTok{, }\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{2}\NormalTok{, }\DataTypeTok{value =} \DecValTok{1}\NormalTok{, }\DataTypeTok{step =} \FloatTok{0.1}\NormalTok{),}
        \KeywordTok{f7Stepper}\NormalTok{(}\DataTypeTok{inputId =} \StringTok{"stepper1"}\NormalTok{, }\DataTypeTok{label =} \StringTok{"Stepper"}\NormalTok{, }\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{10}\NormalTok{, }\DataTypeTok{value =} \DecValTok{5}\NormalTok{),}
        \KeywordTok{verbatimTextOutput}\NormalTok{(}\StringTok{"lastChanged"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{    output}\OperatorTok{$}\NormalTok{lastChanged <-}\StringTok{ }\KeywordTok{renderPrint}\NormalTok{(input}\OperatorTok{$}\NormalTok{lastInputChanged)}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This approach has the advantage not to overload the server part with complex logic.

\hypertarget{about-shinylogs}{%
\subsection{About \{shinylogs\}}\label{about-shinylogs}}

The \texttt{\{shinylogs\}} package developed by \href{https://github.com/dreamRs/shinylogs}{dreamRs} contains this feature with much more advanced options.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shinylogs)}

\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{fluidPage}\NormalTok{(}
    \KeywordTok{numericInput}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\StringTok{"n"}\NormalTok{, }\DecValTok{1}\NormalTok{),}
    \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"s"}\NormalTok{, }\StringTok{"s"}\NormalTok{, }\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{10}\NormalTok{, }\DataTypeTok{value =} \DecValTok{5}\NormalTok{),}
    \KeywordTok{verbatimTextOutput}\NormalTok{(}\StringTok{"lastChanged"}\NormalTok{)}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output, session) \{}
    \CommentTok{# specific to shinylogs}
    \KeywordTok{track_usage}\NormalTok{(}\DataTypeTok{storage_mode =} \KeywordTok{store_null}\NormalTok{())}
\NormalTok{    output}\OperatorTok{$}\NormalTok{lastChanged <-}\StringTok{ }\KeywordTok{renderPrint}\NormalTok{(input}\OperatorTok{$}\StringTok{`}\DataTypeTok{.shinylogs_lastInput}\StringTok{`}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{shiny-custom-handler}{%
\chapter{Dynamically manage content with handlers}\label{shiny-custom-handler}}

The three previous chapters are largely dedicated to Shiny input elements. Yet, not everything is input in Shiny. This chapter shows how one may leverage the internal Shiny JavaScript tools to build highly interactive and optimized interfaces.

\hypertarget{introduction-3}{%
\section{Introduction}\label{introduction-3}}

As shown in the Mastering Shiny \href{https://mastering-shiny.org/action-dynamic.html}{book}, there exists tools to update UI components from the server. You can use all \texttt{update\textless{}INPUT\_NAME\textgreater{}} functions like \texttt{updateTextInput} or \texttt{updateTabsetPanel}.
Other tools to manage your UI consist in \texttt{toggle} functions like \texttt{hideTab}, \texttt{showTab}, the limit being the very few number of them, which often obliges us to use packages like \texttt{shinyjs} \citep{R-shinyjs} or write custom JavaScript code. Finally, \texttt{insertUI/removeUI} allows to dynamically insert or remove any element, anywhere in the DOM, which is quite powerful. Let's start this chapter with the less optimized approach, that is \texttt{renderUI}, to highlight its caveats and introduce better tools to optimize your apps.

\hypertarget{the-renderui-case}{%
\section{The renderUI case}\label{the-renderui-case}}

One may know the \texttt{renderUI/uiOutput} that allows to render any HTML block from the server. While the \texttt{update\textless{}INPUT\_NAME\textgreater{}} and \texttt{toggle} tools are component specific, meaning they only target the element to modify, \texttt{renderUI/uiOutput} re-renders the whole block each time an associated reactive dependency is invalidated, even though only a little part should be re-rendered. This approach is usually to avoid since it implies poor performances. Let's see below, where I simulate a computationally intensive task for three seconds, corresponding to the time to obtain the slider value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"moreControls"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
  
\NormalTok{  sliderValue <-}\StringTok{ }\KeywordTok{reactive}\NormalTok{(\{}
    \CommentTok{# computationally intensive task}
    \KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{3}\NormalTok{)}
    \DecValTok{1}
\NormalTok{  \})}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{moreControls <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
    \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\StringTok{"N"}\NormalTok{, }\KeywordTok{sliderValue}\NormalTok{(), }\DecValTok{1000}\NormalTok{, }\DecValTok{500}\NormalTok{)}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The same example with the \texttt{updateSliderInput} functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\StringTok{"N"}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{500}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  
\NormalTok{  sliderValue <-}\StringTok{ }\KeywordTok{reactive}\NormalTok{(\{}
    \CommentTok{# computationally intensive task}
    \KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{3}\NormalTok{)}
    \DecValTok{50}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(}\KeywordTok{sliderValue}\NormalTok{(), \{}
    \KeywordTok{updateSliderInput}\NormalTok{(}
\NormalTok{      session,}
      \StringTok{"n"}\NormalTok{,}
      \DataTypeTok{value =} \KeywordTok{sliderValue}\NormalTok{()}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The first approach's biggest problem is the absence of anything for 3 seconds, which may discourage the end user. Although not ideal, the second approach is already much better.

Below is an very naive and dirty example where \texttt{renderUI} makes the entire dropdown menu re-render each time something changes in the \texttt{renderUI} expression, which may not be optimal. For instance in React, we only re-render what needs to be \href{https://en.reactjs.org/docs/rendering-elements.html\#react-only-updates-whats-necessary}{updated}! Run the app below, open the HTML inspector and click to add 1 message. Notice that the entire block is updated, whereas only the corresponding HTML element should (Figure \ref{fig:render-ui-1}). No doubt that any advanced user see a place for \texttt{insertUI}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(bs4Dash)}
\KeywordTok{library}\NormalTok{(tibble)}

\NormalTok{new_message <-}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{message =} \StringTok{"New message"}\NormalTok{,}
  \DataTypeTok{from =} \StringTok{"Paul"}\NormalTok{,}
  \DataTypeTok{src =} \StringTok{"https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg"}\NormalTok{,}
  \DataTypeTok{time =} \StringTok{"yesterday"}\NormalTok{,}
  \DataTypeTok{status =} \StringTok{"success"}\NormalTok{,}
  \DataTypeTok{type =} \StringTok{"message"}
\NormalTok{)}

\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{bs4DashPage}\NormalTok{(}
    \DataTypeTok{navbar =} \KeywordTok{bs4DashNavbar}\NormalTok{(}
      \DataTypeTok{rightUi =} \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"messages"}\NormalTok{, }\DataTypeTok{container =}\NormalTok{ tags}\OperatorTok{$}\NormalTok{li)}
\NormalTok{    ),}
    \DataTypeTok{sidebar =} \KeywordTok{bs4DashSidebar}\NormalTok{(),}
    \DataTypeTok{controlbar =} \KeywordTok{bs4DashControlbar}\NormalTok{(),}
    \DataTypeTok{footer =} \KeywordTok{bs4DashFooter}\NormalTok{(),}
    \DataTypeTok{title =} \StringTok{"test"}\NormalTok{,}
    \DataTypeTok{body =} \KeywordTok{bs4DashBody}\NormalTok{(}\KeywordTok{actionButton}\NormalTok{(}\StringTok{"add"}\NormalTok{, }\StringTok{"Add message"}\NormalTok{))}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output) \{}
    
\NormalTok{    messages <-}\StringTok{ }\KeywordTok{reactiveValues}\NormalTok{(}
      \DataTypeTok{items =} \KeywordTok{tibble}\NormalTok{(}
        \DataTypeTok{message =} \KeywordTok{rep}\NormalTok{(}\StringTok{"A message"}\NormalTok{, }\DecValTok{10}\NormalTok{),}
        \DataTypeTok{from =}\NormalTok{ LETTERS[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{],}
        \DataTypeTok{src =} \KeywordTok{rep}\NormalTok{(}\StringTok{"https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg"}\NormalTok{, }\DecValTok{10}\NormalTok{),}
        \DataTypeTok{time =} \KeywordTok{rep}\NormalTok{(}\StringTok{"yesterday"}\NormalTok{, }\DecValTok{10}\NormalTok{),}
        \DataTypeTok{status =} \KeywordTok{rep}\NormalTok{(}\StringTok{"success"}\NormalTok{, }\DecValTok{10}\NormalTok{),}
        \DataTypeTok{type =} \KeywordTok{rep}\NormalTok{(}\StringTok{"message"}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    )}
    
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{add, \{}
\NormalTok{      messages}\OperatorTok{$}\NormalTok{items <-}\StringTok{ }\KeywordTok{add_row}\NormalTok{(messages}\OperatorTok{$}\NormalTok{items, new_message)}
\NormalTok{    \})}
    
\NormalTok{    output}\OperatorTok{$}\NormalTok{messages <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
      \KeywordTok{dropdownMenu}\NormalTok{(}
        \DataTypeTok{show =} \OtherTok{FALSE}\NormalTok{,}
        \DataTypeTok{status =} \StringTok{"danger"}\NormalTok{,}
        \DataTypeTok{src =} \StringTok{"https://www.google.fr"}\NormalTok{,}
        \KeywordTok{lapply}\NormalTok{(}\KeywordTok{seq_len}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(messages}\OperatorTok{$}\NormalTok{items)), }\ControlFlowTok{function}\NormalTok{(r) \{}
\NormalTok{          temp <-}\StringTok{ }\NormalTok{messages}\OperatorTok{$}\NormalTok{items[r, ]}
          \KeywordTok{dropdownMenuItem}\NormalTok{(}
            \DataTypeTok{message =}\NormalTok{ temp}\OperatorTok{$}\NormalTok{message,}
            \DataTypeTok{from =}\NormalTok{ temp}\OperatorTok{$}\NormalTok{from, }
            \DataTypeTok{time =}\NormalTok{ temp}\OperatorTok{$}\NormalTok{time,}
            \DataTypeTok{status =}\NormalTok{ temp}\OperatorTok{$}\NormalTok{status,}
            \DataTypeTok{type =}\NormalTok{ temp}\OperatorTok{$}\NormalTok{type,}
            \DataTypeTok{src =}\NormalTok{ temp}\OperatorTok{$}\NormalTok{src}
\NormalTok{          )}
\NormalTok{        \})}
\NormalTok{      )}
\NormalTok{    \})}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/render-ui-1} \caption{renderUI is not specific}\label{fig:render-ui-1}
\end{figure}

This non specificity property justifies why you should avoid this method as much as possible, as it overloads the server. Later in this chapter, we leverage custom handlers to solve this problem. Overall, it's more work, maybe more complex but ensures to be specific and more optimized.

\hypertarget{insert-ui}{%
\section{Other Shiny handlers}\label{insert-ui}}

As mentioned in Chapter \ref{update-input-lifecycle}, all \texttt{update\textless{}INPUT\_NAME\textgreater{}} functions are Shiny defined messages handlers.

\hypertarget{the-insertui-case}{%
\subsection{The insertUI case}\label{the-insertui-case}}

Under the hood, \texttt{insertUI} sends a R \href{https://github.com/rstudio/shiny/blob/master/R/shiny.R\#L1696}{message} through \texttt{session\$sendInsertUI}, via the websocket:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{session}\OperatorTok{$}\KeywordTok{sendInsertUI}\NormalTok{(}
  \DataTypeTok{selector =}\NormalTok{ selector, }
  \DataTypeTok{multiple =}\NormalTok{ multiple, }
  \DataTypeTok{where =}\NormalTok{ where, }
  \DataTypeTok{content =} \KeywordTok{processDeps}\NormalTok{(ui, session)}
\NormalTok{)}

\NormalTok{sendInsertUI =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(selector, multiple, where, content) \{}
\NormalTok{  private}\OperatorTok{$}\KeywordTok{sendMessage}\NormalTok{(}
    \StringTok{`}\DataTypeTok{shiny-insert-ui}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{list}\NormalTok{(}
      \DataTypeTok{selector =}\NormalTok{ selector,}
      \DataTypeTok{multiple =}\NormalTok{ multiple,}
      \DataTypeTok{where =}\NormalTok{ where,}
      \DataTypeTok{content =}\NormalTok{ content}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The content has been treated with \texttt{shiny:::processDeps} that:

\begin{itemize}
\tightlist
\item
  Finds and resolve any HTML dependency, as shown in Chapter \ref{htmltools-dependencies}.
\item
  For each dependency, makes sure the corresponding files can be accessed on the server with \texttt{createWebDependency} and \texttt{addResourcePath}.
\item
  Returns a list of the HTML element and dependencies. The HTML will be accessed by \texttt{message.content.html} and dependencies by \texttt{message.content.deps}.
\end{itemize}

On the UI side, Shiny has a predefined message \href{https://github.com/rstudio/shiny/blob/master/srcjs/shinyapp.js\#L670}{handler}:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{addMessageHandler}\NormalTok{(}\StringTok{'shiny-insert-ui'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ targets }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{selector}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{targets}\NormalTok{.}\AttributeTok{length} \OperatorTok{===} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
    \CommentTok{// render the HTML and deps to a null target, so}
    \CommentTok{// the side-effect of rendering the deps, singletons,}
    \CommentTok{// and <head> still occur}
    \VariableTok{console}\NormalTok{.}\AttributeTok{warn}\NormalTok{(}\StringTok{'The selector you chose ("'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{selector} \OperatorTok{+}
                 \StringTok{'") could not be found in the DOM.'}\NormalTok{)}\OperatorTok{;}
    \VariableTok{exports}\NormalTok{.}\AttributeTok{renderHtml}\NormalTok{(}\VariableTok{message}\NormalTok{.}\VariableTok{content}\NormalTok{.}\AttributeTok{html}\OperatorTok{,} \AttributeTok{$}\NormalTok{([])}\OperatorTok{,} \VariableTok{message}\NormalTok{.}\VariableTok{content}\NormalTok{.}\AttributeTok{deps}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \VariableTok{targets}\NormalTok{.}\AttributeTok{each}\NormalTok{(}\KeywordTok{function}\NormalTok{ (i}\OperatorTok{,}\NormalTok{ target) }\OperatorTok{\{}
      \VariableTok{exports}\NormalTok{.}\AttributeTok{renderContent}\NormalTok{(target}\OperatorTok{,} \VariableTok{message}\NormalTok{.}\AttributeTok{content}\OperatorTok{,} \VariableTok{message}\NormalTok{.}\AttributeTok{where}\NormalTok{)}\OperatorTok{;}
      \ControlFlowTok{return} \VariableTok{message}\NormalTok{.}\AttributeTok{multiple}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

It checks whether the provided selector corresponds to multiple DOM elements. If at least 1 item is found, it calls \texttt{renderContent(html,\ el,\ dependencies)} that triggers \texttt{renderHtml(html,\ el,\ dependencies)}:

\begin{itemize}
\tightlist
\item
  Processes the provided HTML (treat the head, body and singletons).
\item
  Renders all given dependencies into the page's \href{https://github.com/rstudio/shiny/blob/master/srcjs/output_binding_html.js\#L241}{head}.
\item
  Insert the HTML into the page at the position provided in the \texttt{insertUI} \textbf{where} parameter. Internally this calls the \texttt{insertAdjacentHTML} method.
\item
  Initialize any input and bind them to the scope and send the value to the server so that output/observers are invalidated. Outputs are also bound. If this step is missed the newly inserted input won't react, so is the related output and any observer.
\end{itemize}

Keep \texttt{renderContent} and \texttt{renderHtml} in mind, we'll use them in section \ref{custom-ui-functions}.

\hypertarget{example-1}{%
\subsection{Example}\label{example-1}}

Going back to the previous example, why don't we just go for \texttt{insertUI}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{bs4DashPage}\NormalTok{(}
    \DataTypeTok{navbar =} \KeywordTok{bs4DashNavbar}\NormalTok{(}
      \DataTypeTok{rightUi =} \KeywordTok{dropdownMenu}\NormalTok{(}
        \DataTypeTok{show =} \OtherTok{FALSE}\NormalTok{,}
        \DataTypeTok{status =} \StringTok{"danger"}\NormalTok{,}
        \DataTypeTok{src =} \StringTok{"https://www.google.fr"}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{sidebar =} \KeywordTok{bs4DashSidebar}\NormalTok{(),}
    \DataTypeTok{controlbar =} \KeywordTok{bs4DashControlbar}\NormalTok{(),}
    \DataTypeTok{footer =} \KeywordTok{bs4DashFooter}\NormalTok{(),}
    \DataTypeTok{title =} \StringTok{"test"}\NormalTok{,}
    \DataTypeTok{body =} \KeywordTok{bs4DashBody}\NormalTok{(}\KeywordTok{actionButton}\NormalTok{(}\StringTok{"add"}\NormalTok{, }\StringTok{"Add dropdown item"}\NormalTok{))}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output, session) \{}
    
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{add, \{}
      \KeywordTok{insertUI}\NormalTok{(}
        \DataTypeTok{selector =} \StringTok{".dropdown-menu > .dropdown-item.dropdown-footer"}\NormalTok{,}
        \DataTypeTok{where =} \StringTok{"beforeBegin"}\NormalTok{,}
        \DataTypeTok{ui =} \KeywordTok{dropdownMenuItem}\NormalTok{(}
          \DataTypeTok{inputId =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"triggerAction_"}\NormalTok{, input}\OperatorTok{$}\NormalTok{add),}
          \DataTypeTok{message =} \KeywordTok{paste}\NormalTok{(}\StringTok{"message"}\NormalTok{, input}\OperatorTok{$}\NormalTok{add),}
          \DataTypeTok{from =} \StringTok{"Divad Nojnarg"}\NormalTok{,}
          \DataTypeTok{src =} \StringTok{"https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg"}\NormalTok{,}
          \DataTypeTok{time =} \StringTok{"today"}\NormalTok{,}
          \DataTypeTok{status =} \StringTok{"danger"}\NormalTok{,}
          \DataTypeTok{type =} \StringTok{"message"}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    \})}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Well, if the item is inserted, the item counter as well as the dropdown text are not, as depicted Figure \ref{fig:insertUI-1}! We can't blame \texttt{insertUI} for this, since this is the fault of the \texttt{\{bs4Dash\}} component that actually has interconnected HTML pieces. Indeed, the \texttt{dropdownMenu} function generates HTML, detecting the number of \texttt{dropdownMenuItem}. This works well when the app fires but the component is not able to maintain an up to date state.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/insertUI-1} \caption{insertUI is not enough specific}\label{fig:insertUI-1}
\end{figure}

We may fix that by adding extra \texttt{insertUI()} and \texttt{removeUI()} to replace those parts (\texttt{insertUI()} does not update the targeted item). Moreover, you we must set correct priority for each \texttt{observeEvent} (try to remove them, it will fail) to ensure that \emph{remove} happens before \emph{insert}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{bs4DashPage}\NormalTok{(}
    \DataTypeTok{navbar =} \KeywordTok{bs4DashNavbar}\NormalTok{(}
      \DataTypeTok{rightUi =} \KeywordTok{dropdownMenu}\NormalTok{(}
        \DataTypeTok{show =} \OtherTok{FALSE}\NormalTok{,}
        \DataTypeTok{status =} \StringTok{"danger"}\NormalTok{,}
        \DataTypeTok{src =} \StringTok{"https://www.google.fr"}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{sidebar =} \KeywordTok{bs4DashSidebar}\NormalTok{(),}
    \DataTypeTok{controlbar =} \KeywordTok{bs4DashControlbar}\NormalTok{(),}
    \DataTypeTok{footer =} \KeywordTok{bs4DashFooter}\NormalTok{(),}
    \DataTypeTok{title =} \StringTok{"test"}\NormalTok{,}
    \DataTypeTok{body =} \KeywordTok{bs4DashBody}\NormalTok{(}\KeywordTok{actionButton}\NormalTok{(}\StringTok{"add"}\NormalTok{, }\StringTok{"Add dropdown item"}\NormalTok{))}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output, session) \{}
    
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{add, \{}
      \KeywordTok{insertUI}\NormalTok{(}
        \DataTypeTok{selector =} \StringTok{".dropdown-menu > .dropdown-item.dropdown-footer"}\NormalTok{,}
        \DataTypeTok{where =} \StringTok{"beforeBegin"}\NormalTok{,}
        \DataTypeTok{ui =} \KeywordTok{dropdownMenuItem}\NormalTok{(}
          \DataTypeTok{inputId =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"triggerAction_"}\NormalTok{, input}\OperatorTok{$}\NormalTok{add),}
          \DataTypeTok{message =} \KeywordTok{paste}\NormalTok{(}\StringTok{"message"}\NormalTok{, input}\OperatorTok{$}\NormalTok{add),}
          \DataTypeTok{from =} \StringTok{"Divad Nojnarg"}\NormalTok{,}
          \DataTypeTok{src =} \StringTok{"https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg"}\NormalTok{,}
          \DataTypeTok{time =} \StringTok{"today"}\NormalTok{,}
          \DataTypeTok{status =} \StringTok{"danger"}\NormalTok{,}
          \DataTypeTok{type =} \StringTok{"message"}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    \})}
    
    \CommentTok{# remove old badge}
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{add, \{}
      \KeywordTok{removeUI}\NormalTok{(}\DataTypeTok{selector =} \StringTok{".badge-danger.navbar-badge"}\NormalTok{)}
\NormalTok{    \}, }\DataTypeTok{priority =} \DecValTok{1}\NormalTok{)}
    
    \CommentTok{# insert new badge}
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{add, \{}
      \KeywordTok{insertUI}\NormalTok{(}
        \DataTypeTok{selector =} \StringTok{"[data-toggle=}\CharTok{\textbackslash{}"}\StringTok{dropdown}\CharTok{\textbackslash{}"}\StringTok{]"}\NormalTok{,}
        \DataTypeTok{where =} \StringTok{"beforeEnd"}\NormalTok{,}
        \DataTypeTok{ui =}\NormalTok{ tags}\OperatorTok{$}\KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"badge badge-danger navbar-badge"}\NormalTok{, input}\OperatorTok{$}\NormalTok{add)}
\NormalTok{      )}
\NormalTok{    \})}
    
    
    \CommentTok{# remove old text counter}
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{add, \{}
      \KeywordTok{removeUI}\NormalTok{(}\DataTypeTok{selector =} \StringTok{".dropdown-item.dropdown-header"}\NormalTok{)}
\NormalTok{    \}, }\DataTypeTok{priority =} \DecValTok{1}\NormalTok{)}
    
    \CommentTok{# insert new text counter}
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{add, \{}
      \KeywordTok{insertUI}\NormalTok{(}
        \DataTypeTok{selector =} \StringTok{".dropdown-menu"}\NormalTok{,}
        \DataTypeTok{where =} \StringTok{"afterBegin"}\NormalTok{,}
        \DataTypeTok{ui =}\NormalTok{ tags}\OperatorTok{$}\KeywordTok{span}\NormalTok{(}\DataTypeTok{class=}\StringTok{"dropdown-item dropdown-header"}\NormalTok{, }\KeywordTok{sprintf}\NormalTok{(}\StringTok{"%s Items"}\NormalTok{, input}\OperatorTok{$}\NormalTok{add))}
\NormalTok{      )}
\NormalTok{    \})}
    
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

So many \texttt{observeEvent} for a simple action! Imagine if we had 10 similar tasks\ldots{} Isn't there a way to do all of this at once, thereby reducing the server code? In general setting priorities in \texttt{observeEvent} is a rather bad smell of poorly designed shiny app.

It seems that we have to create our own message handler!

\hypertarget{custom-handlers}{%
\section{Custom handlers}\label{custom-handlers}}

Custom handlers are a specific category of message handlers, as they are user defined.

\hypertarget{theory}{%
\subsection{Theory}\label{theory}}

Shiny provides tools to ease the communication between R and JavaScript, as illustrated in section \ref{shiny-websocket}. We already discussed the usage of \texttt{sendInputMessage()} in the input binding section \ref{shiny-input-system}. The other important method is \texttt{sendCustomMessage(type,\ message)}. It works by pair with the JS method \texttt{Shiny.AddCustomMessageHandler}, linked with the type parameter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{say_hello_to_js <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(text, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{'say-hello'}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ text)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The JavaScript part is defined below:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{AddCustomMessageHandler}\NormalTok{(}\StringTok{'say-hello'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \AttributeTok{alert}\NormalTok{(}\VerbatimStringTok{`R says }\SpecialCharTok{$\{}\NormalTok{message}\SpecialCharTok{\}}\VerbatimStringTok{ to you!`}\NormalTok{)}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The shiny app below will simply print a welcome message every 5 seconds. We obviously set \texttt{options(shiny.trace\ =\ TRUE)} so as to capture all messages sent between R and JS. Figure \ref{fig:shiny-custom-message} summarizes the main mechanisms involved in the R to JS communication. The corresponding code may be found \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code/blob/master/R/say_hello.R}{here}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyAppDir}\NormalTok{(}\KeywordTok{system.file}\NormalTok{(}\StringTok{"chapter6/say_hello"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shiny-custom-message} \caption{From R to JavaScript}\label{fig:shiny-custom-message}
\end{figure}

Combining \texttt{Shiny.setInputValue} and \texttt{Shiny.addCustomMessageHandler}, here is a fun example
that sets the body background as a result of a simple button click.
We defined 3 JS pieces:

\begin{itemize}
\tightlist
\item
  \texttt{getPokemon} whose script is adapted from Colin Fay et al.~(see \href{https://engineering-shiny.org/optimjs.html}{here}). This function fetch the \href{https://pokeapi.co/}{pokeapi}.
  data and if successful set an input value, which will be available on the R side
\item
  An event listener is set to the only button of the page so that each time we click,
  we call \texttt{getPokemon} to select a random background image.
\item
  \texttt{input\$pokeData} is actually a quite complex list (deeply nested JSON) and some manipulation is done from R in the \texttt{observeEvent} block. Once done, we send the data
  back to JS through the websocket (the session object sends a message).
\item
  On the JS side, the last block is a custom message handler that will add some inline
  CSS properties to the body element.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// Taken from Colin}
  \KeywordTok{const}\NormalTok{ getPokemon }\OperatorTok{=}\NormalTok{ () }\KeywordTok{=>} \OperatorTok{\{}
    \CommentTok{// FETCHING THE API DATA}
    \KeywordTok{let}\NormalTok{ randId }\OperatorTok{=} \VariableTok{Math}\NormalTok{.}\AttributeTok{floor}\NormalTok{(}\VariableTok{Math}\NormalTok{.}\AttributeTok{random}\NormalTok{() }\OperatorTok{*}\NormalTok{ (}\OperatorTok{+}\DecValTok{151} \OperatorTok{+} \DecValTok{1} \OperatorTok{-} \OperatorTok{+}\DecValTok{1}\NormalTok{)) }\OperatorTok{+} \OperatorTok{+}\DecValTok{1}\OperatorTok{;}
    \AttributeTok{fetch}\NormalTok{(}\StringTok{'https://pokeapi.co/api/v2/pokemon/'} \OperatorTok{+}\NormalTok{ randId)}
    \CommentTok{// DEFINE WHAT HAPPENS WHEN JAVASCRIPT RECEIVES THE DATA}
\NormalTok{    .}\AttributeTok{then}\NormalTok{((data) }\KeywordTok{=>}\OperatorTok{\{}
      \CommentTok{// TURN THE DATA TO JSON}
      \VariableTok{data}\NormalTok{.}\AttributeTok{json}\NormalTok{().}\AttributeTok{then}\NormalTok{((res) }\KeywordTok{=>} \OperatorTok{\{}
        \CommentTok{// SEND THE JSON TO R}
        \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\StringTok{'pokeData'}\OperatorTok{,}\NormalTok{ res}\OperatorTok{,} \OperatorTok{\{}\DataTypeTok{priority}\OperatorTok{:} \StringTok{'event'}\OperatorTok{\}}\NormalTok{)}
      \OperatorTok{\}}\NormalTok{)}
    \OperatorTok{\}}\NormalTok{)}
    \CommentTok{// DEFINE WHAT HAPPENS WHEN THERE IS AN ERROR FETCHING THE API}
\NormalTok{    .}\AttributeTok{catch}\NormalTok{((error) }\KeywordTok{=>} \OperatorTok{\{}
      \AttributeTok{alert}\NormalTok{(}\StringTok{'Error catching result from API'}\NormalTok{)}
    \OperatorTok{\}}\NormalTok{)}
  \OperatorTok{\};}
        
  \CommentTok{// add event listener}
  \AttributeTok{$}\NormalTok{(}\StringTok{'#button'}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \AttributeTok{getPokemon}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
        
  \CommentTok{// update background based on R data}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update_background'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\StringTok{'body'}\NormalTok{).}\AttributeTok{css}\NormalTok{(}\OperatorTok{\{}
      \StringTok{'background-image'}\OperatorTok{:}\StringTok{'url('} \OperatorTok{+}\NormalTok{ message }\OperatorTok{+}\StringTok{')'}\OperatorTok{,} 
      \StringTok{'background-repeat'}\OperatorTok{:}\StringTok{'no-repeat'}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

A demonstration may be run from the \texttt{\{OSUICode\}} side package:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(OSUICode)}
\KeywordTok{runPokemonExample}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{custom-ui-functions}{%
\subsection{Toward custom UI management functions}\label{custom-ui-functions}}

\hypertarget{an-insertdropdownitem-function}{%
\subsubsection{An insertDropdownItem function}\label{an-insertdropdownitem-function}}

In this example, we go back to the \texttt{\{bs4Dash\}} \texttt{dropdownMenu} issue, discussed earlier
in the chapter. We propose a method involving only custom message handlers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{insertDropdownItem <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(item, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\StringTok{"add-dropdown-item"}\NormalTok{, }\DataTypeTok{message =} \KeywordTok{as.character}\NormalTok{(item))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We create the \texttt{insertDropdownItem} function with 2 parameters:

\begin{itemize}
\tightlist
\item
  item, the HTML element we want to insert in the DOM.
\item
  session, used to send a message to JavaScript with \texttt{session\$sendCustomMessage}.
\end{itemize}

We don't use \texttt{processDeps} as it is very unlikely that our \texttt{dropdownMenuItem} contains any extra dependency. item is converted to a character (important) and sent to JavaScript through the shiny session R6 object. We give it a type, that is `add-dropdown-item', to be able to identify it from JavaScript with \texttt{Shiny.addCustomMessageHandler}.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'add-dropdown-item'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \CommentTok{// convert string to HTML}
    \KeywordTok{var}\NormalTok{ itemTag }\OperatorTok{=} \VariableTok{$}\NormalTok{.}\AttributeTok{parseHTML}\NormalTok{(message)[}\DecValTok{0}\NormalTok{]}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(itemTag).}\AttributeTok{insertBefore}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'.dropdown-item.dropdown-footer'}\NormalTok{))}\OperatorTok{;}
    \CommentTok{// since we do not re-render the dropdown, we must update its item counter}
    \KeywordTok{var}\NormalTok{ $items }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'button.dropdown-item'}\NormalTok{).}\AttributeTok{length}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(}\StringTok{'.dropdown-item.dropdown-header'}\NormalTok{).}\AttributeTok{html}\NormalTok{($items }\OperatorTok{+} \StringTok{' Items'}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(}\StringTok{'.nav-item.dropdown'}\NormalTok{).}\AttributeTok{find}\NormalTok{(}\StringTok{'.navbar-badge'}\NormalTok{).}\AttributeTok{html}\NormalTok{($items)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We recover the sent message on the JS side with \texttt{Shiny.addCustomMessageHandler}, then parse the string to HTML with \texttt{\$.parseHTML} and insert it before the footer (that is the next UI element of the dropdown body). We also update dropdown menu item counter as well as the icon text since the dropdown menu is not re-rendered. These two extra JS steps save us to create extra \texttt{observeEvent} on the server, as shown before. The \texttt{dropdownMenu} is modified so that dependencies are attached:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dropdownDeps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  htmltools}\OperatorTok{::}\KeywordTok{htmlDependency}\NormalTok{(}
    \DataTypeTok{name =} \StringTok{"bs4-dropdown"}\NormalTok{,}
    \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{,}
    \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{file =} \StringTok{"chapter6/add-dropdown-item"}\NormalTok{),}
    \DataTypeTok{script =} \StringTok{"add-dropdown-item.js"}\NormalTok{,}
    \DataTypeTok{package =} \StringTok{"OSUICode"}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{dropdownMenu <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{show =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{labelText =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{src =} \OtherTok{NULL}\NormalTok{,}
                         \DataTypeTok{status =} \KeywordTok{c}\NormalTok{(}\StringTok{"primary"}\NormalTok{, }\StringTok{"warning"}\NormalTok{, }\StringTok{"danger"}\NormalTok{, }\StringTok{"info"}\NormalTok{, }\StringTok{"success"}\NormalTok{),}
                         \DataTypeTok{menuIcon =} \StringTok{"bell"}\NormalTok{, }\DataTypeTok{align =} \StringTok{"right"}\NormalTok{) \{}

\NormalTok{  status <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(status)}
\NormalTok{  items <-}\StringTok{ }\KeywordTok{list}\NormalTok{(...)}
\NormalTok{  n_items <-}\StringTok{ }\KeywordTok{length}\NormalTok{(items)}
  \CommentTok{# remove the divider from the last item}
  \CommentTok{#items[[n_items]][[2]] <- NULL}

\NormalTok{  labelText <-}\StringTok{ }\NormalTok{n_items}

  \KeywordTok{tagList}\NormalTok{(}
    \KeywordTok{dropdownDeps}\NormalTok{(),}
\NormalTok{    shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
      \DataTypeTok{class =} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{isTRUE}\NormalTok{(show)) }\StringTok{"nav-item dropdown show"} \ControlFlowTok{else} \StringTok{"nav-item dropdown"}\NormalTok{,}
\NormalTok{      shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{a}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"nav-link"}\NormalTok{,}
        \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "dropdown"}\NormalTok{,}
        \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
\NormalTok{        shiny}\OperatorTok{::}\KeywordTok{icon}\NormalTok{(menuIcon),}
\NormalTok{        shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{span}\NormalTok{(}
          \DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"badge badge-"}\NormalTok{, status, }\StringTok{" navbar-badge"}\NormalTok{),}
\NormalTok{          labelText}
\NormalTok{        )}
\NormalTok{      ),}
\NormalTok{      shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{isTRUE}\NormalTok{(show)) \{}
          \KeywordTok{sprintf}\NormalTok{(}\StringTok{"dropdown-menu dropdown-menu-lg dropdown-menu-%s show"}\NormalTok{, align)}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
          \KeywordTok{sprintf}\NormalTok{(}\StringTok{"dropdown-menu dropdown-menu-lg dropdown-menu-%s"}\NormalTok{, align)}
\NormalTok{        \},}
\NormalTok{        shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{span}\NormalTok{(}
          \DataTypeTok{class =} \StringTok{"dropdown-item dropdown-header"}\NormalTok{,}
          \KeywordTok{paste0}\NormalTok{(n_items, }\StringTok{" Items"}\NormalTok{)}
\NormalTok{        ),}
\NormalTok{        shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"dropdown-divider"}\NormalTok{),}
\NormalTok{        ...,}
\NormalTok{        shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{a}\NormalTok{(}
          \DataTypeTok{class =} \StringTok{"dropdown-item dropdown-footer"}\NormalTok{,}
          \DataTypeTok{href =}\NormalTok{ src,}
          \DataTypeTok{target =} \StringTok{"_blank"}\NormalTok{,}
          \StringTok{"See more"}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You may run the example yourself. Note we load \texttt{\{OSUICode\}} to overwrite the \texttt{\{bs4Dash\}} function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# shinyAppDir(system.file("chapter6/add-dropdown-item", package = "OSUICode"))}
\KeywordTok{library}\NormalTok{(OSUICode)}

\KeywordTok{shinyApp}\NormalTok{(}
  \DataTypeTok{ui =} \KeywordTok{bs4DashPage}\NormalTok{(}
    \DataTypeTok{navbar =} \KeywordTok{bs4DashNavbar}\NormalTok{(}
      \DataTypeTok{rightUi =} \KeywordTok{dropdownMenu}\NormalTok{(}
        \DataTypeTok{show =} \OtherTok{FALSE}\NormalTok{,}
        \DataTypeTok{status =} \StringTok{"danger"}\NormalTok{,}
        \DataTypeTok{src =} \StringTok{"https://www.google.fr"}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{sidebar =} \KeywordTok{bs4DashSidebar}\NormalTok{(),}
    \DataTypeTok{controlbar =} \KeywordTok{bs4DashControlbar}\NormalTok{(),}
    \DataTypeTok{footer =} \KeywordTok{bs4DashFooter}\NormalTok{(),}
    \DataTypeTok{title =} \StringTok{"test"}\NormalTok{,}
    \DataTypeTok{body =} \KeywordTok{bs4DashBody}\NormalTok{(}\KeywordTok{actionButton}\NormalTok{(}\StringTok{"add"}\NormalTok{, }\StringTok{"Add dropdown item"}\NormalTok{))}
\NormalTok{  ),}
  \DataTypeTok{server =} \ControlFlowTok{function}\NormalTok{(input, output, session) \{}

    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{add, \{}
      \KeywordTok{insertDropdownItem}\NormalTok{(}
        \KeywordTok{dropdownMenuItem}\NormalTok{(}
          \DataTypeTok{inputId =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"triggerAction_"}\NormalTok{, input}\OperatorTok{$}\NormalTok{add),}
          \DataTypeTok{message =} \KeywordTok{paste}\NormalTok{(}\StringTok{"message"}\NormalTok{, input}\OperatorTok{$}\NormalTok{add),}
          \DataTypeTok{from =} \StringTok{"Divad Nojnarg"}\NormalTok{,}
          \DataTypeTok{src =} \StringTok{"https://adminlte.io/themes/v3/dist/img/user3-128x128.jpg"}\NormalTok{,}
          \DataTypeTok{time =} \StringTok{"today"}\NormalTok{,}
          \DataTypeTok{status =} \StringTok{"danger"}\NormalTok{,}
          \DataTypeTok{type =} \StringTok{"message"}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    \})}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This solution significantly lightens the server code since everything may be done on the JS side in one step.

\hypertarget{a-chat-system-for-shinydashboardplus}{%
\subsubsection{A chat system for shinydashboardPlus}\label{a-chat-system-for-shinydashboardplus}}

User messages in \texttt{\{shinydashboardPlus\}} (latest development version) provide an easy way to create a chat system within a shiny app. \texttt{userMessages} hosts the main container while \texttt{userMessage} are the message elements. All of this is pure HTML:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"direct-chat-msg"}\KeywordTok{>}
  \KeywordTok{<div}\OtherTok{ class=}\StringTok{"direct-chat-info clearfix"}\KeywordTok{>}
    \KeywordTok{<span}\OtherTok{ class=}\StringTok{"direct-chat-name pull-left"}\KeywordTok{>}\NormalTok{Alexander Pierce}\KeywordTok{</span>}
    \KeywordTok{<span}\OtherTok{ class=}\StringTok{"direct-chat-timestamp pull-right"}\KeywordTok{>}\NormalTok{23 Jan 2:00 pm}\KeywordTok{</span>}
  \KeywordTok{</div>}
  \CommentTok{<!-- /.direct-chat-info -->}
  \KeywordTok{<img}\OtherTok{ class=}\StringTok{"direct-chat-img"}\OtherTok{ src=}\StringTok{"dist/img/user1-128x128.jpg"}\OtherTok{ alt=}\StringTok{"message user image"}\KeywordTok{>}
                      \CommentTok{<!-- /.direct-chat-img -->}
  \KeywordTok{<div}\OtherTok{ class=}\StringTok{"direct-chat-text"}\KeywordTok{>}\NormalTok{Is this template really for free? That's unbelievable!}
  \KeywordTok{</div>}
  \CommentTok{<!-- /.direct-chat-text -->}
\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

Figure \ref{fig:shinydashboardPlus-chat} shows the overall output.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shinydashboardPlus-chat} \caption{Chat user interface for AdminLTE2}\label{fig:shinydashboardPlus-chat}
\end{figure}

Given that no JavaScript API is available to handle messages, that is send/receive/edit/remove any message, we are going to design a custom R/JavaScript API step by step.

\hypertarget{html-elements}{%
\paragraph{HTML elements}\label{html-elements}}

The message container is a simple \texttt{div} element:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"direct-chat-messages"}\KeywordTok{>}\NormalTok{...}\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

where \texttt{...} receives all messages. From the AdminLTE demonstration \href{https://adminlte.io/themes/AdminLTE/index2.html}{page}, the class \texttt{direct-chat-warning} gives the yellow color to the sent messages, while received messages are always gray. In \texttt{\{shinydashboardPlus\}}, the container is defined as below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{userMessages <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, status, }\DataTypeTok{width =} \DecValTok{4}\NormalTok{, }\DataTypeTok{height =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  cl <-}\StringTok{ "direct-chat-messages direct-chat"}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(height)) shiny}\OperatorTok{::}\KeywordTok{validateCssUnit}\NormalTok{(height)}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
    \KeywordTok{validateStatus}\NormalTok{(status)}
\NormalTok{    cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(cl, }\StringTok{" direct-chat-"}\NormalTok{, status)}
\NormalTok{  \}}
\NormalTok{  msgtag <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =}\NormalTok{ cl, }
\NormalTok{    ..., }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(height)) \{}
      \KeywordTok{sprintf}\NormalTok{(}\StringTok{"height: %s; overflow-y: auto;"}\NormalTok{, height)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \StringTok{"height: 100%;"}
\NormalTok{    \}}
\NormalTok{  )}
  
\NormalTok{  shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{id =}\NormalTok{ id,}
    \DataTypeTok{class =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{"col-sm-"}\NormalTok{, width),}
\NormalTok{    msgtag}
\NormalTok{  )}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The most important element is the \textbf{id} parameter that makes the link with the custom message handler on the JavaScript side. The message element is defined as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{userMessage <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., author, }\DataTypeTok{date =} \OtherTok{NULL}\NormalTok{, }
                        \DataTypeTok{image =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{type =} \KeywordTok{c}\NormalTok{(}\StringTok{"sent"}\NormalTok{, }\StringTok{"received"}\NormalTok{)) \{}
  
\NormalTok{  type <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(type)}
\NormalTok{  messageCl <-}\StringTok{ "direct-chat-msg"}
  \ControlFlowTok{if}\NormalTok{ (type }\OperatorTok{==}\StringTok{ "sent"}\NormalTok{) messageCl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(messageCl, }\StringTok{" right"}\NormalTok{)}
  
  \CommentTok{# message info}
\NormalTok{  messageInfo <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"direct-chat-info clearfix"}\NormalTok{,}
\NormalTok{    shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{span}\NormalTok{(}
      \DataTypeTok{class =} \ControlFlowTok{if}\NormalTok{ (type }\OperatorTok{==}\StringTok{ "right"}\NormalTok{) \{}
        \StringTok{"direct-chat-name pull-right"}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \StringTok{"direct-chat-name"}
\NormalTok{      \}, }
\NormalTok{      author}
\NormalTok{    ),}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(date)) \{}
\NormalTok{      shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{span}\NormalTok{(}
        \DataTypeTok{class =} \ControlFlowTok{if}\NormalTok{ (type }\OperatorTok{==}\StringTok{ "right"}\NormalTok{) \{}
          \StringTok{"direct-chat-timestamp right"}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
          \StringTok{"direct-chat-timestamp"}
\NormalTok{        \}, }
\NormalTok{        date}
\NormalTok{      )}
\NormalTok{    \}}
\NormalTok{  )}
  
  \CommentTok{# message Text}
\NormalTok{  messageTxt <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"direct-chat-text"}\NormalTok{, ...)}
  
  \CommentTok{# message author image}
\NormalTok{  messageImg <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{img}\NormalTok{(}\DataTypeTok{class =} \StringTok{"direct-chat-img"}\NormalTok{, }\DataTypeTok{src =}\NormalTok{ image)}
  
\NormalTok{  shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =}\NormalTok{ messageCl,}
\NormalTok{    messageInfo,}
\NormalTok{    messageImg, }
\NormalTok{    messageTxt}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There are 3 parts:

\begin{itemize}
\tightlist
\item
  The author tag, defined in the \texttt{messageInfo} variable.
\item
  The message itself, defined in the \texttt{messageTxt} variable.
\item
  The author image, contained in the \texttt{messageImg} variable.
\end{itemize}

The class of the message varies depending whether it is received or sent, which actually changes its position (left or right).

Note the corresponding HTML classes like \texttt{direct-chat-text} since we will use them in JS.

\hypertarget{handle-interactions}{%
\paragraph{Handle interactions}\label{handle-interactions}}

\texttt{userMessages} and \texttt{userMessage} alone only provide a static API. Let's design an \texttt{updateMessages} function that offers way to update the message container. That function must allow to:

\begin{itemize}
\tightlist
\item
  Add any message to the list.
\item
  Remove any existing message.
\item
  Update a given message.
\end{itemize}

For now, we assume to add only one message at a time. \texttt{updateMessages} is linked to any \texttt{userMessages} container by the \textbf{id} parameter. In order to delete/update a message, we need to define an \textbf{index} parameter. Don't forget that R starts from 1 while JS starts from 0. Consequently, we have to decrease the R index by 1 so that JS receives the correct number. We must also provide a content slot so as to update any existing message content. The content has to be compatible we the \texttt{userMessage} structure. We expect the user to pass a list like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{author =} \StringTok{"David"}\NormalTok{,}
  \DataTypeTok{date =} \StringTok{"Now"}\NormalTok{,}
  \DataTypeTok{image =} \StringTok{"https://i.pinimg.com/originals/f1/15/df/f115dfc9cab063597b1221d015996b39.jpg"}\NormalTok{,}
  \DataTypeTok{type =} \StringTok{"received"}\NormalTok{,}
  \DataTypeTok{text =} \KeywordTok{tagList}\NormalTok{(}
    \KeywordTok{sliderInput}\NormalTok{(}
      \StringTok{"obs"}\NormalTok{, }
      \StringTok{"Number of observations:"}\NormalTok{,}
      \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }
      \DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }
      \DataTypeTok{value =} \DecValTok{500}
\NormalTok{    ),}
    \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

Interestingly, we may offer the ability to add input/output element in the message content (as shown above) with dependencies that are not yet made available to shiny. We therefore assume that if the content is a shiny tag or a list of shiny tags, it may contain elements with extra dependencies and leverage the \texttt{processDeps} function on the R side for all elements with \texttt{lapply} function. Finally, the message is going to be sent with \texttt{session\$sendCustomMessage}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{updateUserMessages <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, }\DataTypeTok{action =} \KeywordTok{c}\NormalTok{(}\StringTok{"add"}\NormalTok{, }\StringTok{"remove"}\NormalTok{, }\StringTok{"update"}\NormalTok{), }
                               \DataTypeTok{index =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{content =} \OtherTok{NULL}\NormalTok{, }
                               \DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  action <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(action)}
  
\NormalTok{  content <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(content, }\ControlFlowTok{function}\NormalTok{(c) \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(c, }\StringTok{"shiny.tag"}\NormalTok{) }\OperatorTok{||}\StringTok{ }\KeywordTok{inherits}\NormalTok{(c, }\StringTok{"shiny.tag.list"}\NormalTok{)) \{}
      \CommentTok{# necessary if the user pass input/output with deps}
      \CommentTok{# that are not yet available in the page before inserting the new tag}
\NormalTok{      c <-}\StringTok{ }\KeywordTok{processDeps}\NormalTok{(c, session)}
\NormalTok{    \}}
\NormalTok{    c}
\NormalTok{  \})}
  
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}
    \StringTok{"user-messages"}\NormalTok{, }
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{id =}\NormalTok{ session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(id), }
      \DataTypeTok{action =}\NormalTok{ action, }
      \DataTypeTok{index =}\NormalTok{ index,}
      \DataTypeTok{body =}\NormalTok{ content}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We have to send the container \textbf{id} so as to be able to select the good target on the JS side. Note the \texttt{session\$ns} that actually make sure this function can work within shiny modules.

As a reminder, the message handler name has to be the same on the JS side!

Now we are all done for the R side but still have to design the JS interface. The first step is to create a custom message handler skeleton:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{"user-messages"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \CommentTok{// JS logic}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

where the message parameter is actually the message sent through the R \texttt{updateUserMessages} function. We recall that is we send a list, it is converted into a JS object. Therefore, to access the container id element, we do:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{message}\NormalTok{.}\AttributeTok{id}
\end{Highlighting}
\end{Shaded}

and similarly for other elements. There may be nested list, for instance the message content is one, which is not very complex to handle: we simply use the \texttt{.} JS notation to access lower level elements, that is \texttt{message.content.text} for the message text.

The second step is to store all message elements in variables, which may be separated by commas. This step is not mandatory but improves the code readability:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{"user-messages"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ id }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,}\NormalTok{ action }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{action}\OperatorTok{,}\NormalTok{ content }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{body}\OperatorTok{,}\NormalTok{ index }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{index}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In the following we show how to process any message content. For sake of simplicity, we assume to be able to only edit the message text.
As mentioned earlier, there are 2 possible cases:

\begin{itemize}
\tightlist
\item
  The text is simple text or simple HTML without any extra dependency, we do nothing more than storing it into a meaningful variable.
\item
  The text is a list of shiny tags containing input/output with extra dependencies like \texttt{sliderInput}, we have to use the \texttt{renderHtml} method to correctly process the missing dependencies passed from R via \texttt{processDeps} in \texttt{updateUserMessages}.
\end{itemize}

This yields:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{"user-messages"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ id }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,}\NormalTok{ action }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{action}\OperatorTok{,}\NormalTok{ content }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{body}\OperatorTok{,}\NormalTok{ index }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{index}\OperatorTok{;}
  
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{content}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{"text"}\NormalTok{)) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ text}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{content}\NormalTok{.}\VariableTok{text}\NormalTok{.}\AttributeTok{html} \OperatorTok{===} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
\NormalTok{      text }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{text}\OperatorTok{;}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{      text }\OperatorTok{=} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{renderHtml}\NormalTok{(}\VariableTok{content}\NormalTok{.}\VariableTok{text}\NormalTok{.}\AttributeTok{html}\OperatorTok{,} \AttributeTok{$}\NormalTok{([])}\OperatorTok{,} \VariableTok{content}\NormalTok{.}\VariableTok{text}\NormalTok{.}\AttributeTok{deps}\NormalTok{).}\AttributeTok{html}\OperatorTok{;}
    \OperatorTok{\}} 
  \OperatorTok{\}}
  
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Note the \texttt{hasOwnProperty} that checks whether content has a text property.

Then, the next step is to consider the multiple options provided by the user (update, add, remove). We consider the simplest case, that is \texttt{remove} a message. We remind the reader that the \textbf{action} contains the user choice in \texttt{updateUserMessages}. What do we need to remove a given message:

\begin{itemize}
\tightlist
\item
  It's index contained in the \textbf{index} variable.
\item
  The container \textbf{id}.
\item
  Remember/notice that a message has the \texttt{direct-chat-msg} class.
\item
  Use the \texttt{remove} jQuery method.
\end{itemize}

We therefore target the main container with \texttt{\$("\#"\ +\ id)}, look for its messages with \texttt{find(".direct-chat-msg")}, specify the target using \texttt{eq(index\ -\ 1)} (index is the R value) and apply the remove method:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (action }\OperatorTok{===} \StringTok{"remove"}\NormalTok{) }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(}\StringTok{"#"} \OperatorTok{+}\NormalTok{ id).}\AttributeTok{find}\NormalTok{(}\StringTok{".direct-chat-msg"}\NormalTok{).}\AttributeTok{eq}\NormalTok{(index }\OperatorTok{-} \DecValTok{1}\NormalTok{).}\AttributeTok{remove}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

We could add more security with \texttt{console.warn} whenever the user wants to delete a message that does not exist. We leave it to the reader as an exercise.

The second case is to add a new message. In that case, we define new variables containing the
author, the date, the image and the message type. Below is a reminder of the message HTML structure:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"direct-chat-msg"}\KeywordTok{>}
  \KeywordTok{<div}\OtherTok{ class=}\StringTok{"direct-chat-info clearfix"}\KeywordTok{>}
    \KeywordTok{<span}\OtherTok{ class=}\StringTok{"direct-chat-name pull-left"}\KeywordTok{>}\NormalTok{AUTHOR (TO REPLACE)}\KeywordTok{</span>}
    \KeywordTok{<span}\OtherTok{ class=}\StringTok{"direct-chat-timestamp pull-right"}\KeywordTok{>}\NormalTok{DATE (TO REPLACE)}\KeywordTok{</span>}
  \KeywordTok{</div>}
  \CommentTok{<!-- /.direct-chat-info -->}
  \KeywordTok{<img}\OtherTok{ class=}\StringTok{"direct-chat-img"}\OtherTok{ src=}\StringTok{"IMAGE URL (TO REPLACE)"}\OtherTok{ alt=}\StringTok{"message user image"}\KeywordTok{>}
                      \CommentTok{<!-- /.direct-chat-img -->}
  \KeywordTok{<div}\OtherTok{ class=}\StringTok{"direct-chat-text"}\KeywordTok{>}\NormalTok{MAIN CONTENT (TO REPLACE)}
  \KeywordTok{</div>}
  \CommentTok{<!-- /.direct-chat-text -->}
\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

In our JS logic, we use the same template and replace any relevant element (see capital letters)
by the previously created variables. We might use the string interpolation but this is not compatible with all
web browsers. We wrap all of these elements in a \texttt{direct-chat-msg} div which class may vary depending
on the message type. If sent, the class is \texttt{direct-chat-msg\ right} and \texttt{direct-chat-msg} otherwise.
The final step is to target the main container with \texttt{\$("\#"\ +\ id)}, look for the messages slot \texttt{find(".direct-chat-messages")} (the message container is nested in the main wrapper) and \texttt{append} it
to the DOM. We used \texttt{append} which add the message at the end but could choose \texttt{prepend} to add on top
of all other messages. This behavior may be defined by the programmer with no option for the end-user.
Alternatively, the developer could expose an external parameter to control the add position.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// other condition before ...}
\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (action }\OperatorTok{===} \StringTok{"add"}\NormalTok{) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ author }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{author}\OperatorTok{,}\NormalTok{ date }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{date}\OperatorTok{,}\NormalTok{ image }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{image}\OperatorTok{,}\NormalTok{ type }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{type}\OperatorTok{;}
      
  \CommentTok{// build the new message }
  \KeywordTok{var}\NormalTok{ newMessage }\OperatorTok{=} \StringTok{'<div class="direct-chat-info clearfix">'} \OperatorTok{+}
    \StringTok{'<span class="direct-chat-name">'} \OperatorTok{+}\NormalTok{ author }\OperatorTok{+} \StringTok{'</span>'} \OperatorTok{+}
    \StringTok{'<span class="direct-chat-timestamp" style="margin-left: 4px">'} \OperatorTok{+}\NormalTok{ date }\OperatorTok{+} \StringTok{'</span>'} \OperatorTok{+} \StringTok{'</div>'} \OperatorTok{+}
    \StringTok{'<img class="direct-chat-img" src="'} \OperatorTok{+}\NormalTok{ image }\OperatorTok{+} \StringTok{'"/>'} \OperatorTok{+} 
    \StringTok{'<div class="direct-chat-text">'} \OperatorTok{+}\NormalTok{ text }\OperatorTok{+} \StringTok{'</div>'}
    
  \CommentTok{// build wrapper}
  \KeywordTok{var}\NormalTok{ newMessageWrapper}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (type }\OperatorTok{===} \StringTok{"sent"}\NormalTok{) }\OperatorTok{\{}
\NormalTok{    newMessageWrapper }\OperatorTok{=} \StringTok{'<div class="direct-chat-msg right">'} \OperatorTok{+}\NormalTok{ newMessage }\OperatorTok{+} \StringTok{'</div>'}
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    newMessageWrapper }\OperatorTok{=} \StringTok{'<div class="direct-chat-msg">'} \OperatorTok{+}\NormalTok{ newMessage }\OperatorTok{+} \StringTok{'</div>'}
  \OperatorTok{\}}
  
  \CommentTok{// append message}
  \AttributeTok{$}\NormalTok{(}\StringTok{"#"} \OperatorTok{+}\NormalTok{ id).}\AttributeTok{find}\NormalTok{(}\StringTok{".direct-chat-messages"}\NormalTok{).}\AttributeTok{append}\NormalTok{(newMessageWrapper)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Finally, the last case is to update a given message. As stated above, we assume to only edit the
message text and the date. To update the message, we target the messages container with \texttt{\$("\#"\ +\ id)},
look for all texts with \texttt{find(".direct-chat-text")}, refine our choice by targeting the good element with
\texttt{eq(index\ -\ 1)}, call \texttt{replaceWith} containing the new text element.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (action }\OperatorTok{===} \StringTok{"update"}\NormalTok{) }\OperatorTok{\{}
      
  \CommentTok{// today's date}
  \KeywordTok{var}\NormalTok{ d }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Date}\NormalTok{()}\OperatorTok{;}
  \KeywordTok{var}\NormalTok{ month }\OperatorTok{=} \VariableTok{d}\NormalTok{.}\AttributeTok{getMonth}\NormalTok{() }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
  \KeywordTok{var}\NormalTok{ day }\OperatorTok{=} \VariableTok{d}\NormalTok{.}\AttributeTok{getDate}\NormalTok{()}\OperatorTok{;}
  \KeywordTok{var}\NormalTok{ today }\OperatorTok{=} \VariableTok{d}\NormalTok{.}\AttributeTok{getFullYear}\NormalTok{() }\OperatorTok{+} \StringTok{'/'} \OperatorTok{+}
\NormalTok{    ((}\StringTok{''}\OperatorTok{+}\NormalTok{month).}\AttributeTok{length}\OperatorTok{<}\DecValTok{2} \OperatorTok{?} \StringTok{'0'}\NormalTok{ : }\StringTok{''}\NormalTok{) }\OperatorTok{+}\NormalTok{ month }\OperatorTok{+} \StringTok{'/'} \OperatorTok{+}
\NormalTok{    ((}\StringTok{''}\OperatorTok{+}\NormalTok{day).}\AttributeTok{length}\OperatorTok{<}\DecValTok{2} \OperatorTok{?} \StringTok{'0'}\NormalTok{ : }\StringTok{''}\NormalTok{) }\OperatorTok{+}\NormalTok{ day}\OperatorTok{;}
    
  \CommentTok{// we assume only text may be updated. Does not make sense to modify author}
  
  \AttributeTok{$}\NormalTok{(}\StringTok{"#"} \OperatorTok{+}\NormalTok{ id)}
\NormalTok{    .}\AttributeTok{find}\NormalTok{(}\StringTok{".direct-chat-text"}\NormalTok{)}
\NormalTok{    .}\AttributeTok{eq}\NormalTok{(index }\OperatorTok{-} \DecValTok{1}\NormalTok{)}
\NormalTok{    .}\AttributeTok{replaceWith}\NormalTok{(}\StringTok{'<div class="direct-chat-text"><small class="text-red">(modified: '} \OperatorTok{+}\NormalTok{ today }\OperatorTok{+}\StringTok{')</small><br>'} \OperatorTok{+}\NormalTok{  text }\OperatorTok{+} \StringTok{'</div>'}\NormalTok{)}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Don't forget to unbind, re-initialize and bind all inputs by calling \texttt{Shiny.unbindAll();}, \texttt{Shiny.initializeInputs();} and
\texttt{Shiny.bindAll();}. If you ommit this part, the newly inserted input/output elements won't work!

The whole JS code may be found below:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// userMessages}
  \CommentTok{// ------------------------------------------------------------------}
  \CommentTok{// This code creates acustom handler for userMessages}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{"user-messages"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ id }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,}\NormalTok{ action }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{action}\OperatorTok{,}\NormalTok{ content }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{body}\OperatorTok{,}\NormalTok{ index }\OperatorTok{=} \VariableTok{message}\NormalTok{.}\AttributeTok{index}\OperatorTok{;}
    
    \CommentTok{// message text}
    \CommentTok{// We use Shiny.renderHtml to handle the case where the user pass input/outputs in the updated content that require a new dependency not available in the }
    \CommentTok{// page at startup. }
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{content}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{"text"}\NormalTok{)) }\OperatorTok{\{}
      \KeywordTok{var}\NormalTok{ text}\OperatorTok{;}
      \ControlFlowTok{if}\NormalTok{ (}\VariableTok{content}\NormalTok{.}\VariableTok{text}\NormalTok{.}\AttributeTok{html} \OperatorTok{===} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
\NormalTok{        text }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{text}\OperatorTok{;}
      \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        text }\OperatorTok{=} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{renderHtml}\NormalTok{(}\VariableTok{content}\NormalTok{.}\VariableTok{text}\NormalTok{.}\AttributeTok{html}\OperatorTok{,} \AttributeTok{$}\NormalTok{([])}\OperatorTok{,} \VariableTok{content}\NormalTok{.}\VariableTok{text}\NormalTok{.}\AttributeTok{deps}\NormalTok{).}\AttributeTok{html}\OperatorTok{;}
      \OperatorTok{\}} 
    \OperatorTok{\}}
    
    \CommentTok{// unbind all}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{unbindAll}\NormalTok{()}\OperatorTok{;}
    
    \ControlFlowTok{if}\NormalTok{ (action }\OperatorTok{===} \StringTok{"remove"}\NormalTok{) }\OperatorTok{\{}
      \AttributeTok{$}\NormalTok{(}\StringTok{"#"} \OperatorTok{+}\NormalTok{ id).}\AttributeTok{find}\NormalTok{(}\StringTok{".direct-chat-msg"}\NormalTok{).}\AttributeTok{eq}\NormalTok{(index }\OperatorTok{-} \DecValTok{1}\NormalTok{).}\AttributeTok{remove}\NormalTok{()}\OperatorTok{;}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (action }\OperatorTok{===} \StringTok{"add"}\NormalTok{) }\OperatorTok{\{}
      \KeywordTok{var}\NormalTok{ author }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{author}\OperatorTok{,}\NormalTok{ date }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{date}\OperatorTok{,}\NormalTok{ image }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{image}\OperatorTok{,}\NormalTok{ type }\OperatorTok{=} \VariableTok{content}\NormalTok{.}\AttributeTok{type}\OperatorTok{;}
      
      \CommentTok{// build the new message }
      \KeywordTok{var}\NormalTok{ newMessage }\OperatorTok{=} \StringTok{'<div class="direct-chat-info clearfix">'} \OperatorTok{+}
        \StringTok{'<span class="direct-chat-name">'} \OperatorTok{+}\NormalTok{ author }\OperatorTok{+} \StringTok{'</span>'} \OperatorTok{+}
        \StringTok{'<span class="direct-chat-timestamp" style="margin-left: 4px">'} \OperatorTok{+}\NormalTok{ date }\OperatorTok{+} \StringTok{'</span>'} \OperatorTok{+} \StringTok{'</div>'} \OperatorTok{+}
        \StringTok{'<img class="direct-chat-img" src="'} \OperatorTok{+}\NormalTok{ image }\OperatorTok{+} \StringTok{'"/>'} \OperatorTok{+} 
        \StringTok{'<div class="direct-chat-text">'} \OperatorTok{+}\NormalTok{ text }\OperatorTok{+} \StringTok{'</div>'}
        
      \CommentTok{// build wrapper}
      \KeywordTok{var}\NormalTok{ newMessageWrapper}\OperatorTok{;}
      \ControlFlowTok{if}\NormalTok{ (type }\OperatorTok{===} \StringTok{"sent"}\NormalTok{) }\OperatorTok{\{}
\NormalTok{        newMessageWrapper }\OperatorTok{=} \StringTok{'<div class="direct-chat-msg right">'} \OperatorTok{+}\NormalTok{ newMessage }\OperatorTok{+} \StringTok{'</div>'}
      \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        newMessageWrapper }\OperatorTok{=} \StringTok{'<div class="direct-chat-msg">'} \OperatorTok{+}\NormalTok{ newMessage }\OperatorTok{+} \StringTok{'</div>'}
      \OperatorTok{\}}
      
      \CommentTok{// append message}
      \AttributeTok{$}\NormalTok{(}\StringTok{"#"} \OperatorTok{+}\NormalTok{ id).}\AttributeTok{find}\NormalTok{(}\StringTok{".direct-chat-messages"}\NormalTok{).}\AttributeTok{append}\NormalTok{(newMessageWrapper)}\OperatorTok{;}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (action }\OperatorTok{===} \StringTok{"update"}\NormalTok{) }\OperatorTok{\{}
      
      \CommentTok{// today's date}
      \KeywordTok{var}\NormalTok{ d }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Date}\NormalTok{()}\OperatorTok{;}
      \KeywordTok{var}\NormalTok{ month }\OperatorTok{=} \VariableTok{d}\NormalTok{.}\AttributeTok{getMonth}\NormalTok{() }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
      \KeywordTok{var}\NormalTok{ day }\OperatorTok{=} \VariableTok{d}\NormalTok{.}\AttributeTok{getDate}\NormalTok{()}\OperatorTok{;}
      \KeywordTok{var}\NormalTok{ today }\OperatorTok{=} \VariableTok{d}\NormalTok{.}\AttributeTok{getFullYear}\NormalTok{() }\OperatorTok{+} \StringTok{'/'} \OperatorTok{+}
\NormalTok{        ((}\StringTok{''}\OperatorTok{+}\NormalTok{month).}\AttributeTok{length}\OperatorTok{<}\DecValTok{2} \OperatorTok{?} \StringTok{'0'}\NormalTok{ : }\StringTok{''}\NormalTok{) }\OperatorTok{+}\NormalTok{ month }\OperatorTok{+} \StringTok{'/'} \OperatorTok{+}
\NormalTok{        ((}\StringTok{''}\OperatorTok{+}\NormalTok{day).}\AttributeTok{length}\OperatorTok{<}\DecValTok{2} \OperatorTok{?} \StringTok{'0'}\NormalTok{ : }\StringTok{''}\NormalTok{) }\OperatorTok{+}\NormalTok{ day}\OperatorTok{;}
        
      \CommentTok{// we assume only text may be updated. Does not make sense to modify author/date}
      
      \AttributeTok{$}\NormalTok{(}\StringTok{"#"} \OperatorTok{+}\NormalTok{ id)}
\NormalTok{        .}\AttributeTok{find}\NormalTok{(}\StringTok{".direct-chat-text"}\NormalTok{)}
\NormalTok{        .}\AttributeTok{eq}\NormalTok{(index }\OperatorTok{-} \DecValTok{1}\NormalTok{)}
\NormalTok{        .}\AttributeTok{replaceWith}\NormalTok{(}\StringTok{'<div class="direct-chat-text"><small class="text-red">(modified: '} \OperatorTok{+}\NormalTok{ today }\OperatorTok{+}\StringTok{')</small><br>'} \OperatorTok{+}\NormalTok{  text }\OperatorTok{+} \StringTok{'</div>'}\NormalTok{)}
    \OperatorTok{\}}
    
    \CommentTok{// Calls .initialize() for all of the input objects in all input bindings,}
    \CommentTok{// in the given scope (document)}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{initializeInputs}\NormalTok{()}\OperatorTok{;}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{bindAll}\NormalTok{()}\OperatorTok{;} \CommentTok{// bind all inputs/outputs}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Output is shown on Figure \ref{fig:shinydashboardPlus-chat-api}. To reproduce that figure,
you may click on add message, then click on update message leaving the numeric input to 1.

\begin{figure}
\includegraphics[width=1\linewidth]{images/survival-kit/shinydashboardPlus-chat-api} \caption{Chat user interface for {shinydashboardPlus}}\label{fig:shinydashboardPlus-chat-api}
\end{figure}

as well as a demonstration:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{shinyAppDir}\NormalTok{(}\KeywordTok{system.file}\NormalTok{(}\StringTok{"vignettes-demos/userMessages"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"shinydashboardPlus"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Why can't we use the \texttt{renderContent} function, thereby allowing use to remove the three extra steps (unbind, initialize and bind inputs). This would lead to a timing issue. Indeed,
let's say we first click on add message which creates one slider input and one plot output.
It works well the first time since those element don't exist for Shiny. If we remove the newly created message and click again on add, we obtain an error message \texttt{Uncaught\ Duplicate\ binding\ for\ ID\ distPlot}. The root cause is rather obvious and internal to \texttt{renderContent}. The later cannot be called before the target is in the DOM. It means that during some time, we actually added a second output (identical to the first one) without unbinding the first, thereby causing the duplication error.

Chapter \ref{custom-templates-interactivity} provide another case study to practice custom handler design.

\hypertarget{part-practice-1-a-dashboard-template}{%
\part*{Practice 1: a dashboard template}\label{part-practice-1-a-dashboard-template}}


In this chapter, you will learn how to build your own HTML templates taken from the web and package them, so that they can be re-used at any time by anybody.

\hypertarget{custom-templates-selection}{%
\chapter{Template selection}\label{custom-templates-selection}}

There are numerous HTML templates all over the web. However, few may be suitable for shiny.

\begin{itemize}
\tightlist
\item
  shiny is built on top of \href{https://getbootstrap.com/docs/3.3/}{Bootstrap 3} (HTML, CSS and Javascript framework), and changing the framework will not be a trivial endeavor. However, \href{https://github.com/ericrayanderson/shinymaterial}{shinymaterial} and \href{https://github.com/Appsilon/shiny.semantic}{shiny.semantic} are good examples that show this is possible.
\item
  shiny relies on \href{https://jquery.com}{jQuery} (currently v 3.4.1 for shiny). Consequently, all templates based upon \href{https://fr.reactjs.org}{React}, \href{https://vuejs.org}{Vue} and other Javascript framework will not be natively supported. Again, there exist some \href{https://github.com/alandipert/react-widget-demo/blob/master/app.R}{examples} for React with shiny and more generally,
  the \href{https://react-r.github.io/reactR/}{reactR} package developed by Kent Russell and Alan Dipert from RStudio.
\end{itemize}

See \href{https://github.com/rstudio/shiny/tree/master/inst/www/shared}{the github repository} for more details about all dependencies related to the shiny package.

\begin{quote}
Notes: As shiny depends on Bootstrap 3.4.1, we recommend the user whom is interested in experimenting with Bootstrap 4 to be consciously aware of the potential incompatibilities. See a working example here with \href{https://github.com/RinteRface/bs4Dash}{bs4Dash}.
\end{quote}

A good source of \textbf{open source} HTML templates is \href{https://colorlib.com}{Colorlib} and \href{https://www.creative-tim.com/bootstrap-themes/free}{Creative Tim}.

In the next chapter, we will focus on the \href{https://preview-dev.tabler.io/layout-dark.html}{tabler.io} dashboard template (See Figure \ref{fig:tabler-dark}).

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-dark} \caption{Tabler dashboard overview}\label{fig:tabler-dark}
\end{figure}

\hypertarget{custom-templates-dependencies}{%
\chapter{Define dependencies}\label{custom-templates-dependencies}}

The Tabler template is a tiny Bootstrap 4 dashboard template. In this chapter, we will describe how to customize Tabler by providing an R wrapper. In this way, the underlying JavaScript code is left untouched yet we are able to incorporate greater functionality.

\hypertarget{discover-the-project}{%
\section{Discover the project}\label{discover-the-project}}

The first step of any template adaptation consists of exploring the underlying Github repository (if open source) and look for mandatory elements, like CSS/JS dependencies. This is a similar strategy if you want to incorporate an htmlWidget as well.

As shown in Figure \ref{fig:tabler-github}, the most important folders are:

\begin{itemize}
\tightlist
\item
  dist: contains CSS and JS files as well as other libraries like Bootstrap and jQuery. It is also a good moment to look at the version of each dependency that might conflict with Shiny.
\item
  demo is the website folder used for demonstration purpose. This is our source to explore the template capabilities in depth.
\end{itemize}

The scss and build folder may be used to customize the tabler template directly. However as stated above, directions on how to do so are out of scope for this book.

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-github} \caption{Github project exploration}\label{fig:tabler-github}
\end{figure}

\hypertarget{identify-mandatory-dependencies}{%
\section{Identify mandatory dependencies}\label{identify-mandatory-dependencies}}

Bootstrap 4, jQuery, tabler.min.css and tabler.min.js are key elements for the template, contrary to flag icons which are optional (and take a lot of space). If your goal is to release your template on CRAN, be mindful of the 5 Mb maximum size limit. From personal experience, I can attest that this is quite challenging to manage.

To inspect dependencies, we proceed as follows

\begin{itemize}
\tightlist
\item
  Download or clone the Github repository
\item
  Go to the demo folder and open the layout-dark.html file
\item
  Open the HTML inspector
\end{itemize}

As depicted in Figure \ref{fig:tabler-deps} left-hand side, we need to include the tabler.min.css from the header. If you are not convinced, try to remove it from the DOM and see what happens. \href{https://www.10bestdesign.com/jqvmap/}{jqvmap} is actually related to an external visualization plugin used in the demo. Finally the demo.min.css file is for the demo purpose. This will not prevent the template from working, so we will skip it for now. So far so good, we only need one file thus!

\includegraphics[width=0.5\linewidth]{images/practice/tabler-deps-1} \includegraphics[width=0.5\linewidth]{images/practice/tabler-deps-2}

JavaScript dependencies are shown on the right-hand side and located at the end of the body tag. Because we will not need all chart-related dependencies like apexcharts, jquery.vmap and vmap world and may safely ignore them. We will keep the Bootstrap 4 bundle.js, jQuery core and tabler.min.js (the order is crucial).

\hypertarget{bundle-dependencies}{%
\section{Bundle dependencies}\label{bundle-dependencies}}

With the help of the \texttt{htmltoolsDependency} function, we are going to create our main Tabler HTML dependency containing all assets to allow our template to render properly. In this example, I am going to cheat a bit: instead of handling local files, I will use a CDN (content delivery network) that hosts all necessary Tabler \href{https://www.jsdelivr.com/package/npm/tabler}{assets}. This avoids to include all the necessary files in the R package, as well as in a github repository.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tablers_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"tabler"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"1.0.7"}\NormalTok{, }\CommentTok{# we take that of tabler,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://cdn.jsdelivr.net/npm/tabler@1.0.0-alpha.7/dist/"}\NormalTok{),}
  \DataTypeTok{script =} \StringTok{"js/tabler.min.js"}\NormalTok{,}
  \DataTypeTok{stylesheet =} \StringTok{"css/tabler.min.css"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

I advise the reader to create one HTML dependency per element. The Bootstrap version is v4.3.1 (Shiny relies on 3.4.1) and jQuery is 3.5.0 (Shiny relies on 3.4.1). We can also use a CDN:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bs4_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"Bootstrap"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"4.3.1"}\NormalTok{,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/"}\NormalTok{),}
  \DataTypeTok{script =} \StringTok{"bootstrap.bundle.min.js"}
\NormalTok{)}

\NormalTok{jQuery_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"jquery"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"3.5.0"}\NormalTok{,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://code.jquery.com/"}\NormalTok{),}
  \DataTypeTok{script =} \StringTok{"jquery-3.5.0.slim.min.js"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We finally create our dependency manager:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# add all dependencies to a tag. Don't forget to set append to TRUE to preserve any existing dependency}
\NormalTok{add_tabler_deps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
  \CommentTok{# below, the order is of critical importance!}
\NormalTok{  deps <-}\StringTok{ }\KeywordTok{list}\NormalTok{(bs4_deps, tablers_deps)}
  \KeywordTok{attachDependencies}\NormalTok{(tag, deps, }\DataTypeTok{append =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice the dependencies order in the \texttt{deps} list: this will be exactly the same order in the \texttt{head} of the HTML page. Some libraries require to be loaded at a specific place, like the Tabler dependencies which must come after Bootstrap.
It is not surprising since Tabler is built on top of Bootstrap 4.

Let's see how to use \texttt{add\_tabler\_deps}. We consider a \texttt{\textless{}div\textgreater{}} placeholder and check for its dependencies with \texttt{findDependencies} (should be NULL). Then, we wrap it with \texttt{add\_tabler\_deps}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag <-}\StringTok{ }\KeywordTok{div}\NormalTok{()}
\KeywordTok{findDependencies}\NormalTok{(tag)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag <-}\StringTok{ }\KeywordTok{add_tabler_deps}\NormalTok{(}\KeywordTok{div}\NormalTok{())}
\KeywordTok{findDependencies}\NormalTok{(tag)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## List of 10
##  $ name      : chr "Bootstrap"
##  $ version   : chr "4.3.1"
##  $ src       :List of 1
##   ..$ href: chr "https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/"
##  $ meta      : NULL
##  $ script    : chr "bootstrap.bundle.min.js"
##  $ stylesheet: NULL
##  $ head      : NULL
##  $ attachment: NULL
##  $ package   : NULL
##  $ all_files : logi TRUE
##  - attr(*, "class")= chr "html_dependency"
## 
## [[2]]
## List of 10
##  $ name      : chr "tabler"
##  $ version   : chr "1.0.7"
##  $ src       :List of 1
##   ..$ href: chr "https://cdn.jsdelivr.net/npm/tabler@1.0.0-alpha.7/dist/"
##  $ meta      : NULL
##  $ script    : chr "js/tabler.min.js"
##  $ stylesheet: chr "css/tabler.min.css"
##  $ head      : NULL
##  $ attachment: NULL
##  $ package   : NULL
##  $ all_files : logi TRUE
##  - attr(*, "class")= chr "html_dependency"
\end{verbatim}

As shown above, our dependencies are applied to the div, in the correct order. This order is set by the list \texttt{list(bs4\_deps,\ jQuery\_deps,\ tablers\_deps)} and allows use to avoid potential conflicts. If we try to run this simple tag in a shiny app, we notice that all dependencies are added to the \texttt{\textless{}head\textgreater{}} tag, whereas the original template loads JavaScript dependencies in the \texttt{\textless{}body\textgreater{}}. Unfortunately, htmltools does not allow developers to distribute dependencies in different places. Here there is no impact but for other templates like \href{https://framework7.io}{Framework7} (which is powering \href{https://github.com/RinteRface/shinyMobile}{shinyMobile}), JavaScript must be place in the body. In practice, this is challenging to guess and may only be solved by manual testing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(tag)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Even though the \texttt{add\_tabler\_deps} function may be applied to any tag, we will use it with the core HTML template, that remain to be designed!

Would you like to see if our dependency system works? Let's meet in the next chapter to design the main dashboard layout.

\hypertarget{custom-templates-skeleton}{%
\chapter{Template skeleton}\label{custom-templates-skeleton}}

The list of all available layouts is quite impressive (horizontal, vertical, compressed, right to left, dark, \ldots). In the next steps, we will focus on the dark-compressed template. We leave the reader to try other templates as an exercise.

\hypertarget{identify-template-elements}{%
\section{Identify template elements}\label{identify-template-elements}}

We are quite lucky since there is nothing fancy about the tabler layout. As usual, let's inspect the layout-condensed-dark.html (in the tabler /demo folder) in Figure \ref{fig:tabler-layout-intro}

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-layout-intro} \caption{Tabler condensed layout}\label{fig:tabler-layout-intro}
\end{figure}

There are 2 main components:
- the header containing the brand logo, the navigation and dropdown
- the content containing the dashboard body as well as the footer

Something important: the dashboard body does not mean \texttt{\textless{}body\textgreater{}} tag!

This is all!

\hypertarget{design-the-page-layout}{%
\section{Design the page layout}\label{design-the-page-layout}}

\hypertarget{the-page-wrapper}{%
\subsection{The page wrapper}\label{the-page-wrapper}}

Do you remember the structure of a basic html page seen in Chapter \ref{web-intro-html}? Well, if not, here is a reminder.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{HTML}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
  \CommentTok{<!-- head content here -->}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<p>}\NormalTok{Hello World}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

We actually don't need to include the \texttt{\textless{}html\textgreater{}} tag since shiny will automatically do it. Below we construct a list of tags with \texttt{tagList}, including the head and the body. In the head we have the \texttt{meta} tags which has multiple purposes:

\begin{itemize}
\tightlist
\item
  describe the encoding,
\item
  how to display the app on different devices. For instance \texttt{apple-mobile-web-app-status-bar-style} is for iOS devices mobile support.
\item
  Set the favicon, which is an icon representing the website icon, that is the one you may see on the right side of the searchbar. Try \href{https://twitter.com/home}{twitter} for instance.
\end{itemize}

The page title and favicon may be changed by the developer, so they may be included as parameters of the function. If you remember, there also should be CSS in the head but nothing here! Actually, the insertion of dependencies will be achieved by our \texttt{addDeps} function defined in Chapter \ref{custom-templates-dependencies}. Tabler comes with 2 main themes, namely white and dark, which may be applied through the \texttt{\textless{}body\textgreater{}} class attribute (respectively ``antialiased theme-dark'' and ``antialiased''). The \ldots{} parameter contain other template elements like the header and the dashboard body, that remain to be created. As shown in Figure \ref{fig:tabler-dark} of Chapter \ref{custom-templates-selection}, the tabler dashboard template may contain a navigation bar and a footer. As they are not mandatory, we will not create dedicated parameters and pass all elements in the \ldots slot.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{dark =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{favicon =} \OtherTok{NULL}\NormalTok{)\{}
  
  \CommentTok{# head}
\NormalTok{  head_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{charset =} \StringTok{"utf-8"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
      \DataTypeTok{name =} \StringTok{"viewport"}\NormalTok{, }
      \DataTypeTok{content =} \StringTok{"}
\StringTok{        width=device-width, }
\StringTok{        initial-scale=1, }
\StringTok{        viewport-fit=cover"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\StringTok{`}\DataTypeTok{http-equiv}\StringTok{`}\NormalTok{ =}\StringTok{ "X-UA-Compatible"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"ie=edge"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{title}\NormalTok{(title),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}
      \DataTypeTok{rel =} \StringTok{"preconnect"}\NormalTok{, }
      \DataTypeTok{href =} \StringTok{"https://fonts.gstatic.com/"}\NormalTok{, }
      \DataTypeTok{crossorigin =} \OtherTok{NA}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"msapplication-TileColor"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"#206bc4"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"theme-color"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"#206bc4"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"apple-mobile-web-app-status-bar-style"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"black-translucent"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"apple-mobile-web-app-capable"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"yes"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"mobile-web-app-capable"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"yes"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"HandheldFriendly"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"True"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"MobileOptimized"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"320"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{name =} \StringTok{"robots"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"noindex,nofollow,noarchive"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}\DataTypeTok{rel =} \StringTok{"icon"}\NormalTok{, }\DataTypeTok{href =}\NormalTok{ favicon, }\DataTypeTok{type =} \StringTok{"image/x-icon"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}\DataTypeTok{rel =} \StringTok{"shortcut icon"}\NormalTok{, }\DataTypeTok{href =}\NormalTok{ favicon, }\DataTypeTok{type=}\StringTok{"image/x-icon"}\NormalTok{)}
\NormalTok{  )}
  
  \CommentTok{# body}
\NormalTok{  body_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"antialiased "}\NormalTok{, }\ControlFlowTok{if}\NormalTok{(dark) }\StringTok{"theme-dark"}\NormalTok{),}
      \DataTypeTok{style =} \StringTok{"display: block;"}\NormalTok{,}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"page"}\NormalTok{, ...)}
\NormalTok{    )}
\NormalTok{  ) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{add_tabler_deps}\NormalTok{()}
  
  \KeywordTok{tagList}\NormalTok{(head_tag, body_tag)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Below we quickly test if a tabler element renders well which confirms our setup is adequate. To do this, we include a random tabler element taken from the demo html page, using \texttt{HTML}. Let's be clear: you should avoid as much as possible using \texttt{HTML} because of security \href{https://mastering-shiny.org/advanced-ui.html}{issues}. This also checks that our basic Shiny input/output system works as expected with a sliderInput linked to a plot output.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#thematic_on()}
\CommentTok{#onStop(thematic_off)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \StringTok{"test"}\NormalTok{, }
  \KeywordTok{sliderInput}\NormalTok{(}\StringTok{"obs"}\NormalTok{, }\StringTok{"Number of observations:"}\NormalTok{,}
              \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{value =} \DecValTok{500}
\NormalTok{  ),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{),}
  \KeywordTok{br}\NormalTok{(),}
  \KeywordTok{HTML}\NormalTok{(}
    \StringTok{'<div class="col-sm-6 col-lg-3">}
\StringTok{   <div class="card">}
\StringTok{      <div class="card-body">}
\StringTok{         <div class="d-flex align-items-center">}
\StringTok{            <div class="subheader">Sales</div>}
\StringTok{            <div class="ml-auto lh-1">}
\StringTok{               <div class="dropdown">}
\StringTok{                  <a class="dropdown-toggle text-muted" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">}
\StringTok{                  Last 7 days}
\StringTok{                  </a>}
\StringTok{                  <div class="dropdown-menu dropdown-menu-right">}
\StringTok{                     <a class="dropdown-item active" href="#">Last 7 days</a>}
\StringTok{                     <a class="dropdown-item" href="#">Last 30 days</a>}
\StringTok{                     <a class="dropdown-item" href="#">Last 3 months</a>}
\StringTok{                  </div>}
\StringTok{               </div>}
\StringTok{            </div>}
\StringTok{         </div>}
\StringTok{         <div class="h1 mb-3">75%</div>}
\StringTok{         <div class="d-flex mb-2">}
\StringTok{            <div>Conversion rate</div>}
\StringTok{            <div class="ml-auto">}
\StringTok{               <span class="text-green d-inline-flex align-items-center lh-1">}
\StringTok{                  7% }
\StringTok{                  <svg xmlns="http://www.w3.org/2000/svg" class="icon ml-1" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">}
\StringTok{                     <path stroke="none" d="M0 0h24v24H0z"></path>}
\StringTok{                     <polyline points="3 17 9 11 13 15 21 7"></polyline>}
\StringTok{                     <polyline points="14 7 21 7 21 14"></polyline>}
\StringTok{                  </svg>}
\StringTok{               </span>}
\StringTok{            </div>}
\StringTok{         </div>}
\StringTok{         <div class="progress progress-sm">}
\StringTok{            <div class="progress-bar bg-blue" style="width: 75%" role="progressbar" aria-valuenow="75" aria-valuemin="0" aria-valuemax="100">}
\StringTok{               <span class="sr-only">75% Complete</span>}
\StringTok{            </div>}
\StringTok{         </div>}
\StringTok{      </div>}
\StringTok{   </div>}
\StringTok{</div>}
\StringTok{    '}
\NormalTok{  ),}
\DataTypeTok{title =} \StringTok{"Tabler test"}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Ok, our info card and the shiny element work like a charm, which is a good start. Now we may focus on the aesthetics.

\hypertarget{the-body-content}{%
\subsection{The body content}\label{the-body-content}}

In this part, we translate the dashboard body HTML code to R. As a reminder, the \href{https://alandipert.shinyapps.io/html2r/}{html2r} by \href{https://github.com/alandipert}{Alan Dipert} substantially speeds up the conversion process. You copy the code in the HTML text area, click on convert and get the R shiny output. We create a function called \texttt{tabler\_body}. The \ldots{} parameter holds all the dashboard body elements and the footer is dedicated for the future \texttt{tabler\_footer} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_body <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{footer =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"content"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"container-xl"}\NormalTok{, ...),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{footer}\NormalTok{(}\DataTypeTok{class =} \StringTok{"footer footer-transparent"}\NormalTok{, footer)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let's test it with the previous example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}\KeywordTok{tabler_body}\NormalTok{(}\KeywordTok{h1}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)))}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Way better!

\hypertarget{the-footer}{%
\subsection{The footer}\label{the-footer}}

The footer is composed of a left and right containers. We decide to create parameters left and right in which the user will be able to pass any elements.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_footer <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{left =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{right =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"container"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"row text-center align-items-center flex-row-reverse"}\NormalTok{,}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"col-lg-auto ml-lg-auto"}\NormalTok{, right),}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"col-12 col-lg-auto mt-3 mt-lg-0"}\NormalTok{, left)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

All the class attributes are taken from the original HTML template. If you are already familiar with Bootstrap 4, you may easily customize the style. In short, \texttt{row} means that all elements will be aligned on a row, \texttt{text-center} amd \texttt{align-items-center} handle the text and content centering. \texttt{flex-row-reverse} display elements in a reversed order. Notice also that a \texttt{row} element contains columns created with the \texttt{col} class. The Bootstrap grid system relies on the Flexible Box Module, also known as \href{https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox}{flexbox}.

As above, let's check our brand new element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{, }\StringTok{"More"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-navbar-or-header}{%
\subsection{The navbar (or header)}\label{the-navbar-or-header}}

This function is called \texttt{tabler\_header}. In the Tabler template, the header has the \texttt{navbar\ navbar-expand-md\ navbar-light} classes. We don't need the navbar-light class since we are only interested in the dark theme. As shown in Figure \ref{fig:tabler-header}, the navbar is composed of 4 elements:

\begin{itemize}
\tightlist
\item
  the navbar toggler is only visible when we reduce the screen width, like on mobile devices
\item
  the brand image
\item
  the navigation
\item
  the dropdown menus (this is not mandatory)
\end{itemize}

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-header} \caption{Tabler header structure}\label{fig:tabler-header}
\end{figure}

You may have a look at the \href{https://getbootstrap.com/docs/4.0/components/navbar/}{Bootstrap 4} documentation for extra configuration and layout.

Each of these element will be considered as an input parameter to the \texttt{tabler\_navbar} function, except the navbar toggler which is a default element and must not be removed. Morever, we will only show the brand element when it is provided. The \ldots{} parameter is a slot for extra elements (between the menu and dropdowns). In the following, we start by creating the main container, that is \texttt{header\_tag} and its unique child \texttt{container\_tag}. The latter has 4 children \texttt{toggler\_tag}, \texttt{brand\_tag}, \texttt{dropdown\_tag} and \texttt{navmenu\_tag}. In this situations, \{htmltools\} functions like \texttt{tagAppendChild} and \texttt{tagAppendChildren} are game changers to better organize the code and make it more maintainable. One never knows in advance how much extra feature will be added to that component. Hence being cautious at the very beginning is crucial!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{brand_url =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{brand_image =} \OtherTok{NULL}\NormalTok{, nav_menu, }\DataTypeTok{nav_right =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  header_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{header}\NormalTok{(}\DataTypeTok{class =} \StringTok{"navbar navbar-expand-md"}\NormalTok{)}
\NormalTok{  container_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"container-xl"}\NormalTok{)}
  
  \CommentTok{# toggler for small devices (must not be removed)}
\NormalTok{  toggler_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"navbar-toggler"}\NormalTok{, }
    \DataTypeTok{type =} \StringTok{"button"}\NormalTok{, }
    \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "collapse"}\NormalTok{, }
    \StringTok{`}\DataTypeTok{data-target}\StringTok{`}\NormalTok{ =}\StringTok{ "#navbar-menu"}\NormalTok{,}
    \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"navbar-toggler-icon"}\NormalTok{)}
\NormalTok{  )}
  
  \CommentTok{# brand elements}
\NormalTok{  brand_tag <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(brand_url) }\OperatorTok{||}\StringTok{ }\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(brand_image)) \{}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{href =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(brand_url)) \{}
\NormalTok{        brand_url}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \StringTok{"#"}
\NormalTok{      \},}
      \DataTypeTok{class =} \StringTok{"navbar-brand navbar-brand-autodark d-none-navbar-horizontal pr-0 pr-md-3"}\NormalTok{,}
      \ControlFlowTok{if}\NormalTok{(}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(brand_image)) \{}
        \KeywordTok{img}\NormalTok{(}
          \DataTypeTok{src =}\NormalTok{ brand_image, }
          \DataTypeTok{alt =} \StringTok{"brand Image"}\NormalTok{,}
          \DataTypeTok{class =} \StringTok{"navbar-brand-image"}
\NormalTok{        )}
\NormalTok{      \}}
\NormalTok{    )}
\NormalTok{  \}}
  
\NormalTok{  dropdown_tag <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(nav_right)) \{}
    \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"navbar-nav flex-row order-md-last"}\NormalTok{, nav_right)}
\NormalTok{  \}}
  
\NormalTok{  navmenu_tag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"collapse navbar-collapse"}\NormalTok{, }
    \DataTypeTok{id =} \StringTok{"navbar-menu"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"d-flex flex-column flex-md-row flex-fill align-items-stretch align-items-md-center"}\NormalTok{,}
\NormalTok{      nav_menu}
\NormalTok{    ),}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(}\KeywordTok{list}\NormalTok{(...)) }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"ml-md-auto pl-md-4 py-2 py-md-0 mr-md-4 order-first order-md-last flex-grow-1 flex-md-grow-0"}\NormalTok{, }
\NormalTok{        ...}
\NormalTok{      )}
\NormalTok{    \}}
\NormalTok{  )}
  
\NormalTok{  container_tag <-}\StringTok{ }\NormalTok{container_tag }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChildren}\NormalTok{(}
\NormalTok{    toggler_tag,}
\NormalTok{    brand_tag,}
\NormalTok{    dropdown_tag,}
\NormalTok{    navmenu_tag}
\NormalTok{  )}
  
\NormalTok{  header_tag }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChild}\NormalTok{(container_tag)}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The navbar menu is the main component of the navbar. The \ldots{} parameter is a slot for the menu items. Compared to the original tabler dashboard template where there is only the class navbar-nav, we have to add at least, the \texttt{nav} class to make sure items are correctly activated/inactivated. The \texttt{nav-pills} class is to select pills instead of basic tabs (see \href{https://getbootstrap.com/docs/4.0/components/navs/}{here}), which is nothing more than a cosmetic consideration. Notice the \texttt{ul} tag that will contain \texttt{li} elements, that is the navbar items.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{ul}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav nav-pills navbar-nav"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Besides, each navbar menu item could be either a simple button or contain multiple menu sub-items. For now, we only focus on simple items.

\hypertarget{navbar-navigation}{%
\subsubsection{Navbar navigation}\label{navbar-navigation}}

The navbar is extremely important since it will drive the navigation of the template. We would like to associate each item to a separate page in the body content. This will allow us to go to a new page each time we change an item. In brief, it is very similar to the Shiny \texttt{tabsetPanel} function.

In HTML, menu items are \texttt{\textless{}a\textgreater{}} tags (links) with a given \texttt{href} attribute pointing to a specific page located in the server files. The point with a Shiny app is that we can't decide how to split our content into several pages. We only have app.R generating a simple HTML page. The strategy here is to create a tabbed navigation, to mimic multiple pages.

Let's see how tabset navigation works. In the menu list, all items must have:

\begin{itemize}
\tightlist
\item
  A \texttt{data-toggle} attribute set to \texttt{tab} or \texttt{pill}.
\item
  A \texttt{href} or \texttt{data-target} attribute holding a unique id. This unique id is mandatory since it will point the menu item to the corresponding body content. Importantly, \texttt{href} navigation appears to be broken on shinyapps.io, RStudio Connect (all rstudio product relying on workers to spread the user load across multiple R processes). Therefore, we'll choose the \texttt{data-target} attribute.
\end{itemize}

On the body side, tab panels are contained in a tabset panel (simple div container), have a \texttt{role} attribute set to tabpanel and an \texttt{id} corresponding the \texttt{data-target} passed in the menu item. The exact match between \texttt{id} and \texttt{data-target} is mandatory, as shown in Figure \ref{fig:tabler-tabset}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-tabset} \caption{Tabler tabset main principle}\label{fig:tabler-tabset}
\end{figure}

Below, we propose a possible implementation of a menu item, as well as the corresponding body tab panel. The text parameter corresponds to the nav item text displayed in the menu. We also added an optional icon and the ability to select the item at start.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(text, tabName, }\DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{selected =} \OtherTok{FALSE}\NormalTok{) \{}
  
\NormalTok{  item_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"nav-link"}\NormalTok{, }\ControlFlowTok{if}\NormalTok{(selected) }\StringTok{" active"}\NormalTok{)}
  
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"nav-item"}\NormalTok{,}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ item_cl,}
      \StringTok{`}\DataTypeTok{data-target}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, tabName),}
      \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "pill"}\NormalTok{, }\CommentTok{# see https://getbootstrap.com/docs/4.0/components/navs/}
      \StringTok{`}\DataTypeTok{data-value}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{tabName,}
      \DataTypeTok{role =} \StringTok{"tab"}\NormalTok{,}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav-link-icon d-md-none d-lg-inline-block"}\NormalTok{, icon),}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav-link-title"}\NormalTok{, text)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We also decided to add a fade transition effect between tabs, as per Bootstrap 4 documentation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_tab_items <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"tab-content"}\NormalTok{, ...)}
\NormalTok{\}}

\NormalTok{tabler_tab_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{tabName =} \OtherTok{NULL}\NormalTok{, ...) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{role =} \StringTok{"tabpanel"}\NormalTok{,}
    \DataTypeTok{class =} \StringTok{"tab-pane fade container-fluid"}\NormalTok{,}
    \DataTypeTok{id =}\NormalTok{ tabName,}
\NormalTok{    ...}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

What about testing this in a shiny app?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \KeywordTok{tabler_navbar_menu}\NormalTok{(}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 1"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{      ),}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 2"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab2"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_tab_items}\NormalTok{(}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Hello World"}\NormalTok{)}
\NormalTok{      ),}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Second Tab"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

At this point you might argue that we did not even validated the template elements. For instance, going back to the \texttt{tabler\_navbar\_menu\_item} function, we find the following possible issues:

\begin{itemize}
\tightlist
\item
  What happens if the user provides an invalid tabName, ie a text that is not valid for jQuery like \texttt{tab\&?++}?
\item
  What happens if the user accidentally activates 2 tabs at start?
\end{itemize}

We will see later in Chapter \ref{custom-templates-testing} how to validate those parameter.

\hypertarget{fine-tune-tabs-behavior}{%
\subsubsection{Fine tune tabs behavior}\label{fine-tune-tabs-behavior}}

Quite good isn't it? You will notice however that even if the first tab is selected by default, its content is not shown. To fix this, we will apply our jQuery skills. According to the Bootstrap documentation, we must trigger the show event on the active tab at start, as well as add the classes \texttt{show} and \texttt{active} to the associated tab panel in the dashboard body. We therefore target the nav item that has the active class and if no item is found, we select the first item by default and activate its body content.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// this makes sure to trigger the show event on the active   tab at start}
  \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#navbar-menu .nav-link.active'}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// if multiple items are found}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{activeTab}\NormalTok{.}\AttributeTok{length} \OperatorTok{>} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{let}\NormalTok{ tabId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{tabId}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{addClass}\NormalTok{(}\StringTok{'show active'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\StringTok{'#navbar-menu .nav-link'}\NormalTok{)}
\NormalTok{      .}\AttributeTok{first}\NormalTok{()}
\NormalTok{      .}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This script is included in the \texttt{www} folder of the below app. We'll see in Chapter \ref{custom-templates-inputs} that custom input binding may perfectly handle this situation and are preferred.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#thematic_on()}
\CommentTok{#onStop(thematic_off)}
\CommentTok{# example with custom JS code to activate tabs}
\KeywordTok{shinyAppDir}\NormalTok{(}\KeywordTok{system.file}\NormalTok{(}\StringTok{"chapter12/tabler_tabs"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

The result is shown in Figure \ref{fig:tabler-nav}. I'd also suggest to include at least 1 input/output per tab, to test whether everything works properly.

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-nav} \caption{Tabler template with navbar}\label{fig:tabler-nav}
\end{figure}

Looks like we are done for the main template elements. Actually, wouldn't it be better to include, at least, card containers?

\hypertarget{card-containers}{%
\subsection{Card containers}\label{card-containers}}

Card are a central piece of template as they may contain visualizations, metrics and much more. Fortunately, Tabler has a large range of card containers.

\hypertarget{classic-card}{%
\subsubsection{Classic card}\label{classic-card}}

What I call a classic card is like the \texttt{box} container of \href{https://rstudio.github.io/shinydashboard/structure.html}{shinydashboard}. The card structure has key elements:

\begin{itemize}
\tightlist
\item
  a width to control the space taken by the card in the Bootstrap \href{https://getbootstrap.com/docs/4.0/layout/grid/}{grid}
\item
  a title, in general in the header (tabler does always not follow this rule and header is optional)
\item
  a body where is the main content
\item
  style elements like color statuses
\item
  a footer (optional, tabler does not include this)
\end{itemize}

A comprehensive list of all tabler card features may be found \href{https://preview-dev.tabler.io/docs/cards.html}{here}. To be faster, I will copy the following HTML code in the \href{https://github.com/alandipert/html2r}{html2R} shiny app to convert it to Shiny tags

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"col-md-6"}\KeywordTok{>}
  \KeywordTok{<div}\OtherTok{ class=}\StringTok{"card"}\KeywordTok{>}
    \KeywordTok{<div}\OtherTok{ class=}\StringTok{"card-status-top bg-danger"}\KeywordTok{></div>}
    \KeywordTok{<div}\OtherTok{ class=}\StringTok{"card-body"}\KeywordTok{>}
      \KeywordTok{<h3}\OtherTok{ class=}\StringTok{"card-title"}\KeywordTok{>}\NormalTok{Title}\KeywordTok{</h3>}
      \KeywordTok{<p>}\NormalTok{Some Text.}\KeywordTok{</p>}
    \KeywordTok{</div>}
  \KeywordTok{</div>}
\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

Below is the result. The next step consist in replacing all content by parameters to the \texttt{tabler\_card} function, whenever necessary. For instance, the first \texttt{\textless{}div\textgreater{}} sets the width of the card. The Bootstrap grid ranges from 0 to 12, so why not creating a width parameter to control the card size. We proceed similarly for the title, status, body content. It seems reasonable to allow title to be NULL (if so, the title will not be shown), same thing for the status. Regarding the card default width, a value of six also makes sense, which would take half of the row.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{padding =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  card_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"card"}\NormalTok{, }
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" card-"}\NormalTok{, padding)}
\NormalTok{  )}
  
\NormalTok{  status_tag <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
    \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"card-status-top bg-"}\NormalTok{, status))}
\NormalTok{  \}}
  
\NormalTok{  body_tag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"card-body"}\NormalTok{,}
    \CommentTok{# we could have a smaller title like h4 or h5...}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) \{}
      \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, title)}
\NormalTok{    \},}
\NormalTok{    ...}
\NormalTok{  )}
  
\NormalTok{  main_wrapper <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"col-md-"}\NormalTok{, width))}
\NormalTok{  card_wrapper <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =}\NormalTok{ card_cl)}
  
\NormalTok{  card_wrapper <-}\StringTok{ }\NormalTok{card_wrapper }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChildren}\NormalTok{(status_tag, body_tag)}
\NormalTok{  main_wrapper }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChild}\NormalTok{(card_wrapper)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In the meantime, I'd be also nice to be able to display cards in the same row. Let's create the \texttt{tabler\_row}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_row <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"row row-deck"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Below, we show an example of the \texttt{tabler\_card} function, in combination with \href{https://github.com/dreamRs/apexcharter}{apexcharter} by \href{https://www.dreamrs.fr}{dreamRs}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# test the card}
\KeywordTok{data}\NormalTok{(}\StringTok{"economics_long"}\NormalTok{)}
\NormalTok{economics_long <-}\StringTok{ }\NormalTok{economics_long }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(variable) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice}\NormalTok{((}\KeywordTok{n}\NormalTok{()}\OperatorTok{-}\DecValTok{100}\NormalTok{)}\OperatorTok{:}\KeywordTok{n}\NormalTok{())}

\NormalTok{spark_data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{date =} \KeywordTok{Sys.Date}\NormalTok{() }\OperatorTok{+}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{,}
  \DataTypeTok{var1 =} \KeywordTok{round}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{10}\NormalTok{)),}
  \DataTypeTok{var2 =} \KeywordTok{round}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{10}\NormalTok{)),}
  \DataTypeTok{var3 =} \KeywordTok{round}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\NormalTok{)}

\NormalTok{my_card <-}\StringTok{ }\KeywordTok{tabler_card}\NormalTok{(}
  \KeywordTok{apexchartOutput}\NormalTok{(}\StringTok{"my_chart"}\NormalTok{), }
  \DataTypeTok{title =} \StringTok{"My card"}\NormalTok{, }
  \DataTypeTok{status =} \StringTok{"danger"}
\NormalTok{)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_row}\NormalTok{(}
\NormalTok{      my_card,}
      \KeywordTok{tabler_card}\NormalTok{(}
        \KeywordTok{apexchartOutput}\NormalTok{(}\StringTok{"spark_box"}\NormalTok{), }
        \DataTypeTok{title =} \StringTok{"My card"}\NormalTok{, }
        \DataTypeTok{status =} \StringTok{"success"}
\NormalTok{      ) }
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{my_chart <-}\StringTok{ }\KeywordTok{renderApexchart}\NormalTok{(\{}
    \KeywordTok{apex}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ economics_long, }\DataTypeTok{type =} \StringTok{"area"}\NormalTok{, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ date, }\DataTypeTok{y =}\NormalTok{ value01, }\DataTypeTok{fill =}\NormalTok{ variable)) }\OperatorTok{%>%}
\StringTok{      }\KeywordTok{ax_yaxis}\NormalTok{(}\DataTypeTok{decimalsInFloat =} \DecValTok{2}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\CommentTok{# number of decimals to keep}
\StringTok{      }\KeywordTok{ax_chart}\NormalTok{(}\DataTypeTok{stacked =} \OtherTok{TRUE}\NormalTok{) }\OperatorTok{%>%}
\StringTok{      }\KeywordTok{ax_yaxis}\NormalTok{(}\DataTypeTok{max =} \DecValTok{4}\NormalTok{, }\DataTypeTok{tickAmount =} \DecValTok{4}\NormalTok{)}
\NormalTok{  \})}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{spark_box <-}\StringTok{ }\KeywordTok{renderApexchart}\NormalTok{(\{}
    \KeywordTok{spark_box}\NormalTok{(}
      \DataTypeTok{data =}\NormalTok{ spark_data[, }\KeywordTok{c}\NormalTok{(}\StringTok{"date"}\NormalTok{, }\StringTok{"var3"}\NormalTok{)],}
      \DataTypeTok{title =} \KeywordTok{mean}\NormalTok{(spark_data}\OperatorTok{$}\NormalTok{var3), }
      \DataTypeTok{subtitle =} \StringTok{"Variable 3"}\NormalTok{,}
      \DataTypeTok{color =} \StringTok{"#FFF"}\NormalTok{, }\DataTypeTok{background =} \StringTok{"#2E93fA"}\NormalTok{,}
      \DataTypeTok{title_style =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{color =} \StringTok{"#FFF"}\NormalTok{),}
      \DataTypeTok{subtitle_style =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{color =} \StringTok{"#FFF"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The code output is also shown in Figure \ref{fig:tabler-card}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-card} \caption{Tabler card component}\label{fig:tabler-card}
\end{figure}

\hypertarget{ribbons-card-components}{%
\subsection{Ribbons: card components}\label{ribbons-card-components}}

Let's finish this part by including a card component, namely the \href{https://preview-dev.tabler.io/docs/ribbons.html}{ribbon}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_ribbon <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{position =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{color =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{bookmark =} \OtherTok{FALSE}\NormalTok{) \{}
  
\NormalTok{  ribbon_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"ribbon"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(position)) }\KeywordTok{sprintf}\NormalTok{(}\StringTok{" bg-%s"}\NormalTok{, position),}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(color)) }\KeywordTok{sprintf}\NormalTok{(}\StringTok{" bg-%s"}\NormalTok{, color),}
    \ControlFlowTok{if}\NormalTok{ (bookmark) }\StringTok{" ribbon-bookmark"}
\NormalTok{  )}
  \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =}\NormalTok{ ribbon_cl, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Integrating the freshly created ribbon component requires to modify the card structure since the ribbon is added after the body tag, and not parameter is associated with this slot. We could also modify the \texttt{tabler\_card} function but htmltools contains tools to help us. Since the ribbon should be put after the card body (but in the card container), we may think about the \texttt{tagAppendChild} function, introduced in Chapter \ref{htmltools-overview}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# add the ribbon to a card}
\NormalTok{my_card <-}\StringTok{ }\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{title =} \StringTok{"Ribbon"}\NormalTok{, }\DataTypeTok{status =} \StringTok{"info"}\NormalTok{)}

\KeywordTok{str}\NormalTok{(my_card)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 3
##  $ name    : chr "div"
##  $ attribs :List of 1
##   ..$ class: chr "col-md-6"
##  $ children:List of 1
##   ..$ :List of 3
##   .. ..$ name    : chr "div"
##   .. ..$ attribs :List of 1
##   .. .. ..$ class: chr "card"
##   .. ..$ children:List of 2
##   .. .. ..$ :List of 3
##   .. .. .. ..$ name    : chr "div"
##   .. .. .. ..$ attribs :List of 1
##   .. .. .. .. ..$ class: chr "card-status-top bg-info"
##   .. .. .. ..$ children: list()
##   .. .. .. ..- attr(*, "class")= chr "shiny.tag"
##   .. .. ..$ :List of 3
##   .. .. .. ..$ name    : chr "div"
##   .. .. .. ..$ attribs :List of 1
##   .. .. .. .. ..$ class: chr "card-body"
##   .. .. .. ..$ children:List of 1
##   .. .. .. .. ..$ :List of 3
##   .. .. .. .. .. ..$ name    : chr "h3"
##   .. .. .. .. .. ..$ attribs :List of 1
##   .. .. .. .. .. .. ..$ class: chr "card-title"
##   .. .. .. .. .. ..$ children:List of 1
##   .. .. .. .. .. .. ..$ : chr "Ribbon"
##   .. .. .. .. .. ..- attr(*, "class")= chr "shiny.tag"
##   .. .. .. ..- attr(*, "class")= chr "shiny.tag"
##   .. ..- attr(*, "class")= chr "shiny.tag"
##  - attr(*, "class")= chr "shiny.tag"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_card}\OperatorTok{$}\NormalTok{children[[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\NormalTok{my_card}\OperatorTok{$}\NormalTok{children[[}\DecValTok{1}\NormalTok{]] }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{tagAppendChild}\NormalTok{(}
    \KeywordTok{tabler_ribbon}\NormalTok{(}
      \KeywordTok{icon}\NormalTok{(}\StringTok{"info-circle"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"fa-lg"}\NormalTok{), }
      \DataTypeTok{bookmark =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{color =} \StringTok{"red"}
\NormalTok{    )}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

As shown above, the ribbon has been successfuly included in the card tag. Now, we check how it looks in a shiny app.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
\NormalTok{    my_card}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-ribbon} \caption{Tabler ribbon component}\label{fig:tabler-ribbon}
\end{figure}

\hypertarget{icons}{%
\subsection{Icons}\label{icons}}

Not mentioned before but we may include fontawesome icons provided with Shiny, as well as other libraries. Moreover, Tabler has a internal svg library located \href{https://preview-dev.tabler.io/icons.html}{here}.

\hypertarget{exercises-3}{%
\section{Exercises}\label{exercises-3}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Consider the tab card at the very bottom of the tabler \href{https://preview-dev.tabler.io/docs/cards.html}{documentation}. Propose an implementation of that feature.
\item
  Have a look at this \href{https://preview-dev.tabler.io/snippets.html}{page}. Select 2 elements and create the corresponding R functions.
\end{enumerate}

\hypertarget{custom-templates-testing}{%
\chapter{Testing and validating templates elements}\label{custom-templates-testing}}

Until now, we have been building the template boilerplate, that is the main skeleton functions (page, navbar, navbar menu, \ldots) as well as some components such as cards, ribbons, progress bars. We also exposed some techniques to substantially give more interactivity to the template, leveraging our freshly acquired JavaScript skills. Does this mean we are ready to make the template public? Not yet since some essentials steps are missing:

\begin{itemize}
\tightlist
\item
  Input validation is a crucial step toward success. Briefly, it consists in checking user inputs so that your functions fail safely and elegantly by providing meaningful error messages or warnings. This concept has already been covered in R for Data Science, Advanced R and a lot of other resources. Hence, I am not trying to reinvent the wheel and we will rely on already existing patterns, whose effectiveness is no longer to be demonstrated. Welcome to the defensive programming world!
\item
  On the other hand, testing components allows to check if a functions does what it is supposed to do. Consequently, it is a proof of robustness, and increases reproducibility. It significantly reduces the mental load when it comes to start code refactoring, thereby making you feel slightly less guilty about creating breaking changes since, most of the time, your tests will be able to capture those error.
\end{itemize}

\hypertarget{validate-template-functions}{%
\section{Validate template functions}\label{validate-template-functions}}

\hypertarget{create-your-own-validations}{%
\subsection{Create your own validations}\label{create-your-own-validations}}

Below, we will show some examples to validate user inputs. We first consider the \texttt{tabler\_card} element from Chapter \ref{custom-templates-skeleton}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{stacked =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{padding =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  card_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"card"}\NormalTok{, }
    \ControlFlowTok{if}\NormalTok{ (stacked) }\StringTok{" card-stacked"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" card-"}\NormalTok{, padding)}
\NormalTok{  )}
  
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"col-md-"}\NormalTok{, width),}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ card_cl,}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
        \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"card-status-top bg-"}\NormalTok{, status))}
\NormalTok{      \},}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body"}\NormalTok{,}
        \CommentTok{# we could have a smaller title like h4 or h5...}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) \{}
          \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, title)}
\NormalTok{        \},}
\NormalTok{        ...}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The first thing is to think about what to validate. Here, I see at least 3 test:

\begin{itemize}
\tightlist
\item
  checking the status value
\item
  checking the width value
\item
  checking the padding value
\end{itemize}

Writing validation tests requires knowledge about the underlying mechanisms. In our case, we must know the Bootstrap 4 grid rules and valid color statuses. The Bootstrap 4 \href{https://getbootstrap.com/docs/4.0/layout/grid/}{grid} ranges from 1 to 12. In other words, a card having a width of 12 will take the full page wherease, we may align 3 cards or width 4. Valid \href{https://getbootstrap.com/docs/4.0/utilities/colors/}{statuses} are primary, secondary, success, info, danger, warning, light and dark.

It is therefore pretty straightforward to validate the card width: it must be numeric and between 1 and 12. Moreover, since the template has other containers including the width parameter, we will create a function

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{validate_width <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(width) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.numeric}\NormalTok{(width)) \{}
    \ControlFlowTok{if}\NormalTok{ (width }\OperatorTok{<}\StringTok{ }\DecValTok{1} \OperatorTok{||}\StringTok{ }\NormalTok{width }\OperatorTok{>}\StringTok{ }\DecValTok{12}\NormalTok{) \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"width must belong to [1, 12], as per Bootstrap 4 grid documentation. See more at https://getbootstrap.com/docs/4.0/layout/grid/"}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"width must be numeric"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}

\CommentTok{# validate_width(-1)}
\CommentTok{# validate_width(13)}
\CommentTok{# validate_width("string")}
\end{Highlighting}
\end{Shaded}

To check the status parameter, we save the valid statuses in a vector and take the \texttt{validStatuses} function from shinydashboard \href{https://github.com/rstudio/shinydashboard/blob/master/R/utils.R}{utils}. It also make sense to create a function since this parameter is widely used among template components. Contrary to the shinydashboard function, our custom \texttt{valid\_status} does not fail if the status is NULL since it is not a mandatory parameter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{valid_statuses <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"primary"}\NormalTok{, }
  \StringTok{"secondary"}\NormalTok{,}
  \StringTok{"success"}\NormalTok{, }
  \StringTok{"info"}\NormalTok{, }
  \StringTok{"warning"}\NormalTok{, }
  \StringTok{"danger"}\NormalTok{,}
  \StringTok{"light"}\NormalTok{,}
  \StringTok{"dark"}
\NormalTok{)}

\NormalTok{validate_status <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(status) \{}

  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(status)) \{}
    \KeywordTok{return}\NormalTok{(}\OtherTok{TRUE}\NormalTok{) }
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \ControlFlowTok{if}\NormalTok{ (status }\OperatorTok{%in%}\StringTok{ }\NormalTok{valid_statuses) \{}
      \KeywordTok{return}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}

  \KeywordTok{stop}\NormalTok{(}\StringTok{"Invalid status: "}\NormalTok{, status, }\StringTok{". Valid statuses are: "}\NormalTok{,}
       \KeywordTok{paste}\NormalTok{(valid_statuses, }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{), }\StringTok{"."}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We finish by the padding validation. According to the Tabler documentation, there are three possible choices, namely \texttt{sm}, \texttt{md} or \texttt{lg}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{valid_paddings <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"sm"}\NormalTok{, }\StringTok{"md"}\NormalTok{, }\StringTok{"lg"}\NormalTok{)}

\NormalTok{validate_padding <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(padding) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) \{}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{(padding }\OperatorTok{%in%}\StringTok{ }\NormalTok{valid_paddings)) \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"Invalid status: "}\NormalTok{, padding, }\StringTok{". Valid choices are: "}\NormalTok{,}
       \KeywordTok{paste}\NormalTok{(valid_paddings, }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{), }\StringTok{"."}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We apply all these validation to our card element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{stacked =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{padding =} \OtherTok{NULL}\NormalTok{) \{}
  
  \KeywordTok{validate_status}\NormalTok{(status)}
  \KeywordTok{validate_width}\NormalTok{(width)}
  \KeywordTok{validate_padding}\NormalTok{(padding)}
  
\NormalTok{  card_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"card"}\NormalTok{, }
    \ControlFlowTok{if}\NormalTok{ (stacked) }\StringTok{" card-stacked"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" card-"}\NormalTok{, padding)}
\NormalTok{  )}
  
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"col-md-"}\NormalTok{, width),}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ card_cl,}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
        \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"card-status-top bg-"}\NormalTok{, status))}
\NormalTok{      \},}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body"}\NormalTok{,}
        \CommentTok{# we could have a smaller title like h4 or h5...}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) \{}
          \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, title)}
\NormalTok{        \},}
\NormalTok{        ...}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As of R 4.0.0, the \texttt{stopifnot} function may be a good alternative to \texttt{stop}.

We recommend to be reasonable and not to validate every single parameter.

\hypertarget{existing-utils-functions}{%
\subsection{Existing utils functions}\label{existing-utils-functions}}

\hypertarget{validating-tags}{%
\subsubsection{Validating tags}\label{validating-tags}}

The problem with the above approach is that it may take time to create all validation functions. Fortunately, packages like \{shinydashboard\} include really powerful validation functions, especially \texttt{tagAssert}. This function has been included in the book side package so that you may use it at any time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myTag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"bg-blue"}\NormalTok{)}

\KeywordTok{tagAssert}\NormalTok{(myTag, }\DataTypeTok{type =} \StringTok{"div"}\NormalTok{)}
\KeywordTok{tagAssert}\NormalTok{(myTag, }\DataTypeTok{type =} \StringTok{"li"}\NormalTok{) }\CommentTok{# will fail}
\KeywordTok{tagAssert}\NormalTok{(myTag, }\DataTypeTok{class =} \StringTok{"bg-blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Importantly, \texttt{tagAssert} will raise an error if the condition is not fulfilled. Another function, \texttt{tagMatches} simply returns TRUE/FALSE. It looks for \texttt{d}, \texttt{class}, \texttt{name} and any other tag attribute like \texttt{data-value}. Like \texttt{tagAssert}, \texttt{tagMatches} is also available in the book side package.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tagMatches}\NormalTok{(myTag, }\DataTypeTok{id =} \StringTok{"d"}\NormalTok{)}
\KeywordTok{tagMatches}\NormalTok{(myTag, }\DataTypeTok{class =} \StringTok{"bg-blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{validating-css-units}{%
\subsubsection{Validating CSS units}\label{validating-css-units}}

The \texttt{validateCssUnit} belongs to the Shiny exported function. It is useful to validate any parameter involving a CSS unit like \texttt{width} and \texttt{height}.

There is no point to reuse what already exists and these tools will help you to be efficient for validating your template elements.

\hypertarget{example-refine-navbar-menu-items}{%
\subsection{Example: refine navbar menu items}\label{example-refine-navbar-menu-items}}

\hypertarget{avoid-wrong-jquery-selectors}{%
\subsubsection{Avoid wrong jQuery selectors}\label{avoid-wrong-jquery-selectors}}

In Chapter \ref{custom-templates-skeleton}, we developed the \texttt{tabler\_navbar\_menu\_item} function. The tabName parameter is critical since it is responsible for driving the navigation. We must ensure that the value provided by the user is compatible with jQuery selectors \href{https://api.jquery.com/category/selectors/}{conventions}. To illustrate the problem, we consider the example below, where the second tab name is \texttt{hello\%\%\&1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \KeywordTok{tabler_navbar_menu}\NormalTok{(}
      \DataTypeTok{inputId =} \StringTok{"mymenu"}\NormalTok{,}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 1"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{      ),}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 2"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"hello%%&1"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_tab_items}\NormalTok{(}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \KeywordTok{sliderInput}\NormalTok{(}
          \StringTok{"obs"}\NormalTok{, }
          \StringTok{"Number of observations:"}\NormalTok{,}
          \DataTypeTok{min =} \DecValTok{0}\NormalTok{,}
          \DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }
          \DataTypeTok{value =} \DecValTok{500}
\NormalTok{        ),}
        \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{      ),}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"hello%%&1"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Second Tab"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{, }\StringTok{"More"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Notice that we cannot see the second tab content. Below is a proposal for the \texttt{validate\_tab} function. We first detect any punctuation in the provided input. Although not mandatory, we extract it to send a meaningful error message.
We finally raise an error if any punctuation is found.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{validate_tabName <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tabName) \{}
\NormalTok{  temp <-}\StringTok{ }\KeywordTok{grepl}\NormalTok{(}\StringTok{"[[:punct:]]"}\NormalTok{, tabName)}
\NormalTok{  wrong_selector <-}\StringTok{ }\NormalTok{stringr}\OperatorTok{::}\KeywordTok{str_extract_all}\NormalTok{(tabName, }\StringTok{"[[:punct:]]"}\NormalTok{)[[}\DecValTok{1}\NormalTok{]] }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\NormalTok{stringr}\OperatorTok{::}\KeywordTok{str_c}\NormalTok{(}\DataTypeTok{collapse =} \StringTok{""}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (temp) }\KeywordTok{stop}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{"Please do not use punctuation characters like"}\NormalTok{,  wrong_selector,}\StringTok{"in tabNames. This might cause JavaScript issues."}\NormalTok{))}
\NormalTok{\}}
\CommentTok{# validate_tabName("test%") # fails}
\KeywordTok{validate_tabName}\NormalTok{(}\StringTok{"plop"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{validate\_tabName} must be then inserted at the beginning of \texttt{tabler\_navbar\_menu\_item} as well as in \texttt{tabler\_tab\_item}, the latter also relying on tabName.

\hypertarget{checking-for-multiple-selected-items}{%
\subsubsection{Checking for multiple selected items}\label{checking-for-multiple-selected-items}}

Another issue is the possibility to have multiple selected tab items at start. Looking back at \texttt{tabler\_navbar\_menu}, this is not surprising since there are absolutely no checks!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{ul}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav nav-pills navbar-nav"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

A classic method to inspect items provided to \texttt{tabler\_navbar\_menu} is to capture them in a list. We extract the children of those items \texttt{lapply(list(...)\ ,\ "{[}",\ 3)} (A shiny tag is a structure where the first position holds the tag name, the second is a named list of attributes and the third slot is for children). For each children we apply the shinydashboard internal function \texttt{findAttribute}, that allows to search for a specific attribute value in a given tag. We use the \texttt{vapply} to return an atomic vector (like \texttt{c(1,\ 2}), lists are vectors but recursive!) and compute the sum of the vector. Each TRUE occurrence is counted as 1 and FALSE 0. Therefore, if the latter is higher than 1, it means that the user provided more than 1 selected tab, which should subsequently raise an error.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  
\NormalTok{  items <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(}\KeywordTok{list}\NormalTok{(...) , }\StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{  res <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{vapply}\NormalTok{(items, findAttribute, }\StringTok{"class"}\NormalTok{, }\StringTok{"nav-link active"}\NormalTok{, }\DataTypeTok{FUN.VALUE =} \KeywordTok{logical}\NormalTok{(}\DecValTok{1}\NormalTok{)))}
  \ControlFlowTok{if}\NormalTok{ (res }\OperatorTok{>}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{stop}\NormalTok{(}\StringTok{"Cannot have multiple selected items at start!"}\NormalTok{)}
  
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{ul}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav nav-pills navbar-nav"}\NormalTok{, ...)}
\NormalTok{\}}

\CommentTok{# the code below must fail}
\NormalTok{menu <-}\StringTok{ }\KeywordTok{tabler_navbar_menu}\NormalTok{(}
  \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
    \DataTypeTok{text =} \StringTok{"Tab 1"}\NormalTok{,}
    \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
    \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
    \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{  ),}
  \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
    \DataTypeTok{text =} \StringTok{"Tab 2"}\NormalTok{,}
    \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
    \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
    \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{testing-templates-elements}{%
\section{Testing templates elements}\label{testing-templates-elements}}

Imagine if one day, someone or yourself accidentally remove the width validation function, after a significant refactoring. Later, you receive a new message from github, stating that someone opened a new issue. According to the report, the card is not properly displayed although no error is thrown. Among the 400 lines of code provided, you hardly notice that the width parameter is set to 13, which is not in line with the Bootstrap 4 documentation, as it should remain between 1 and 12. You lost 10 minutes, so is your end user, which is even worse.

With a proper testing pipeline, this problem could have been avoided. Ironically, writing the corresponding test takes only 2 minutes.

A reference for testing functions is the \href{https://testthat.r-lib.org/index.html}{\{testthat\}} package. In short, a unit test consists in setting expectations about our function and check whether they fail or pass. For instance, with our \texttt{tabler\_card} example, the \texttt{validate\_width} must fail if the given width is not in the expected bounds or not numeric. We apply the \texttt{test\_that} function with a description of the test context, followed by the expectations inside the curly brackets.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{test_that}\NormalTok{(}\StringTok{"validate width works"}\NormalTok{, \{}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \DecValTok{-1}\NormalTok{))}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \DecValTok{13}\NormalTok{))}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \StringTok{"hello world"}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Test passed
\end{verbatim}

We then test \texttt{validate\_status} and \texttt{validate\_padding}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{test_that}\NormalTok{(}\StringTok{"validate status works"}\NormalTok{, \{}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{status =} \StringTok{"toto"}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Test passed
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{test_that}\NormalTok{(}\StringTok{"validate padding works"}\NormalTok{, \{}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \StringTok{"xs"}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Test passed
\end{verbatim}

So far so good. In few lines of code, we substantially increased the robustness of our function without increasing its complexity. Now, let's try to remove the \texttt{validate\_width} step from the \texttt{tabler\_card}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_card <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \DecValTok{6}\NormalTok{, }\DataTypeTok{stacked =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{padding =} \OtherTok{NULL}\NormalTok{) \{}
  
  \KeywordTok{validate_status}\NormalTok{(status)}
  \KeywordTok{validate_padding}\NormalTok{(padding)}
  
\NormalTok{  card_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"card"}\NormalTok{, }
    \ControlFlowTok{if}\NormalTok{ (stacked) }\StringTok{" card-stacked"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(padding)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" card-"}\NormalTok{, padding)}
\NormalTok{  )}
  
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"col-md-"}\NormalTok{, width),}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ card_cl,}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(status)) \{}
        \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"card-status-top bg-"}\NormalTok{, status))}
\NormalTok{      \},}
      \KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"card-body"}\NormalTok{,}
        \CommentTok{# we could have a smaller title like h4 or h5...}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) \{}
          \KeywordTok{h3}\NormalTok{(}\DataTypeTok{class =} \StringTok{"card-title"}\NormalTok{, title)}
\NormalTok{        \},}
\NormalTok{        ...}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{\}}


\KeywordTok{test_that}\NormalTok{(}\StringTok{"validate width works"}\NormalTok{, \{}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \DecValTok{-1}\NormalTok{))}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \DecValTok{13}\NormalTok{))}
  \KeywordTok{expect_error}\NormalTok{(}\KeywordTok{tabler_card}\NormalTok{(}\DataTypeTok{width =} \StringTok{"hello world"}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Notice how the 3 above tests elegantly fail. The provided context (``validate width works'') immediately indicates the culprit, which is a game changer for debugging.

\hypertarget{testing-template-behavior}{%
\subsection{Testing template behavior}\label{testing-template-behavior}}

Testing the JavaScript behavior is one of the biggest challenge to validate a template. If the
R component has been carefully validated, it does not mean that its JavaScript effects
are! For instance, let's consider the \texttt{tabler\_progress} that may be updated with \texttt{update\_tabler\_progress}:

\begin{itemize}
\tightlist
\item
  How do we check whether the progress value is correctly set?
\end{itemize}

\hypertarget{r-side}{%
\subsubsection{R side}\label{r-side}}

Testing the R side is quite easy. Let's recall the \texttt{update\_tabler\_progress} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{update_tabler_progress <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, value, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(id), }\DataTypeTok{value =}\NormalTok{ value)}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"update-progress"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function does 2 things:

\begin{itemize}
\tightlist
\item
  Captures the id of the targeted progress and its new value
\item
  Sends the message the JS
\end{itemize}

The test consists in checking whether we send all elements to the session. We first create
a dummy session environment which contains \texttt{ns} to mimic the \texttt{session\$ns} function
and \texttt{sendCustomMessage} to test the message handler part:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{session <-}\StringTok{ }\KeywordTok{as.environment}\NormalTok{(}
  \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{ns =}\NormalTok{ identity,}
    \DataTypeTok{sendCustomMessage =} \ControlFlowTok{function}\NormalTok{(type, message) \{}
\NormalTok{      session}\OperatorTok{$}\NormalTok{lastCustomMessage <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{type =}\NormalTok{ type, }\DataTypeTok{message =}\NormalTok{ message)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here, \texttt{sendCustomMessage} simply stores the last sent message in \texttt{session\$lastCustomMessage}.

We then call \texttt{update\_tabler\_progress} with some random parameters and capture the
last sent message in the \texttt{res} variable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{update_tabler_progress}\NormalTok{(}\DataTypeTok{id =} \StringTok{"myprogress"}\NormalTok{, }\DataTypeTok{value =} \DecValTok{10}\NormalTok{, }\DataTypeTok{session =}\NormalTok{ session)}
\NormalTok{res <-}\StringTok{ }\NormalTok{session}\OperatorTok{$}\NormalTok{lastCustomMessage}
\end{Highlighting}
\end{Shaded}

Importantly, don't forget to set the session parameter to \texttt{session}, otherwise,
it will default to \texttt{shiny::getDefaultReactiveDomain} that is \texttt{NULL}.

This is time to set expectations:

\begin{itemize}
\tightlist
\item
  \texttt{res} must be a list of length 2.
\item
  The expected custom handler type is \texttt{update-progress}.
\item
  The sent value is 10.
\item
  The sent id is \texttt{myprogress}.
\end{itemize}

and translate into \texttt{\{testthat\}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{test_that}\NormalTok{(}\StringTok{"update progress works"}\NormalTok{, \{}
  
\NormalTok{  session <-}\StringTok{ }\KeywordTok{as.environment}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{ns =}\NormalTok{ identity,}
      \DataTypeTok{sendCustomMessage =} \ControlFlowTok{function}\NormalTok{(type, message) \{}
\NormalTok{        session}\OperatorTok{$}\NormalTok{lastCustomMessage <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{type =}\NormalTok{ type, }\DataTypeTok{message =}\NormalTok{ message)}
\NormalTok{      \}}
\NormalTok{    )}
\NormalTok{  )}
  
  \KeywordTok{update_tabler_progress}\NormalTok{(}\DataTypeTok{id =} \StringTok{"myprogress"}\NormalTok{, }\DataTypeTok{value =} \DecValTok{10}\NormalTok{, }\DataTypeTok{session =}\NormalTok{ session)}
\NormalTok{  res <-}\StringTok{ }\NormalTok{session}\OperatorTok{$}\NormalTok{lastCustomMessage}
  
  \KeywordTok{expect_length}\NormalTok{(res, }\DecValTok{2}\NormalTok{)}
  \KeywordTok{expect_equal}\NormalTok{(res}\OperatorTok{$}\NormalTok{type, }\StringTok{"update-progress"}\NormalTok{)}
  \KeywordTok{expect_length}\NormalTok{(res}\OperatorTok{$}\NormalTok{message, }\DecValTok{2}\NormalTok{)}
  \KeywordTok{expect_equal}\NormalTok{(res}\OperatorTok{$}\NormalTok{message}\OperatorTok{$}\NormalTok{id, }\StringTok{"myprogress"}\NormalTok{)}
  \KeywordTok{expect_equal}\NormalTok{(res}\OperatorTok{$}\NormalTok{message}\OperatorTok{$}\NormalTok{value, }\DecValTok{10}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

This test being set, it ensures to seamlessly capture any breaking change in the API.

\hypertarget{custom-templates-testing-js}{%
\subsubsection{JS side}\label{custom-templates-testing-js}}

In the following, we have to test whether this piece of JS works as expected:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update-progress'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{)}
\NormalTok{    .}\AttributeTok{css}\NormalTok{(}\StringTok{'width'}\OperatorTok{,} \VariableTok{message}\NormalTok{.}\AttributeTok{value} \OperatorTok{+}\StringTok{'%'}\NormalTok{)}
\NormalTok{    .}\AttributeTok{attr}\NormalTok{(}\StringTok{'aria-valuenow'}\OperatorTok{,} \VariableTok{message}\NormalTok{.}\AttributeTok{value}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We are going to leverage the \texttt{\{crrry\}} packages developed by Colin Fay from ThinkR.
Overall, \href{https://github.com/ColinFay/crrry}{\texttt{\{crrry\}}} is an adaptation of \href{https://github.com/RLesur/crrri}{\texttt{\{crrri\}}} for \texttt{\{shiny\}}, which is a native Chrome Remote Interface in R using the Chrome Debugging Protocol. In other words, it provides tools to programmatically control
the web browser and do many things like inspecting a web page,
taking screenshots, testing\ldots{} You may know \texttt{\{shinytest\}} that relies on another technology,
phantomjs. The latter does not play well with \texttt{Bootstrap\ 4} templates, that's why we'll not use it
here.

\texttt{\{crrry\}} is already introduced in the \texttt{Engineering\ Production-Grade\ Shiny\ Apps} \href{https://engineering-shiny.org/step-secure.html\#testing-the-interactive-logic}{book}.

The first step is to run the \texttt{update\_tabler\_progress} example locally and add the returned
url to the following code. We run the app in another process with \texttt{\{processx\}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\NormalTok{processx}\OperatorTok{::}\NormalTok{process}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}
  \StringTok{"Rscript"}\NormalTok{, }
  \KeywordTok{c}\NormalTok{( }\StringTok{"-e"}\NormalTok{,  }\StringTok{"options('shiny.port'= 3515);OSUICode::update_tabler_progress_example()"}\NormalTok{ )}
\NormalTok{)}

\KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{2}\NormalTok{)}

\NormalTok{p}\OperatorTok{$}\KeywordTok{is_alive}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

That way, we can run our test in the main R process, after checking that \texttt{p} is alive (here the app
loads immediately but you may wait some time if there are computations):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(crrry)}
\KeywordTok{library}\NormalTok{(testthat)}
\NormalTok{test <-}\StringTok{ }\NormalTok{crrry}\OperatorTok{::}\NormalTok{CrrryOnPage}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}
  \DataTypeTok{chrome_bin =}\NormalTok{ pagedown}\OperatorTok{::}\KeywordTok{find_chrome}\NormalTok{(),}
  \DataTypeTok{chrome_port =}\NormalTok{ httpuv}\OperatorTok{::}\KeywordTok{randomPort}\NormalTok{(),}
  \DataTypeTok{url =} \StringTok{"http://localhost:3515/"}\NormalTok{,}
  \DataTypeTok{headless =} \OtherTok{TRUE}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We wait Shiny to be ready:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test}\OperatorTok{$}\KeywordTok{wait_for_shiny_ready}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Note the \texttt{-\/-remote-debugging-port=31683} that gives the link to the Chrome devtools link
to inspect the current app, as shown Figure \ref{fig:tabler-crrry-debug}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-crrry-debug} \caption{Tabler progress bar debug tools}\label{fig:tabler-crrry-debug}
\end{figure}

It is now time to write the JS testing logic. We know that moving the slider triggers
the \texttt{update\_tabler\_progress} function. This is how we change the slider value,
thanks to the noUiSlider \href{https://refreshless.com/nouislider/slider-read-write/\#section-setting}{API}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ slider }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{'progress_value'}\NormalTok{)}\OperatorTok{;}
\VariableTok{slider}\NormalTok{.}\VariableTok{noUiSlider}\NormalTok{.}\AttributeTok{set}\NormalTok{(}\DecValTok{50}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We use \texttt{call\_js} to update the slider value within our testing pipeline:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}
  \StringTok{"var slider = document.getElementById('progress_value');}
\StringTok{   slider.noUiSlider.set(50);}
\StringTok{  "}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

According to Figure \ref{fig:tabler-crrry-debug-2}, the slider is properly updated,
the progress bar also seems to have the expected value.

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-crrry-debug-2} \caption{Updated slider}\label{fig:tabler-crrry-debug-2}
\end{figure}

We recover the progress value knowing that it is contained in the \texttt{aria-valuenow}
attribute, as a string. We have to convert it to a number with \texttt{parseInt}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{val <-}\StringTok{ }\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}
  \StringTok{"parseInt($('#progress1').attr('aria-valuenow'));}
\StringTok{  "}
\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(val}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value, }\DecValTok{50}\NormalTok{)}

\CommentTok{# stop the test whenever satisfied}
\NormalTok{test}\OperatorTok{$}\KeywordTok{stop}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

The test pass, meaning that our \texttt{update\_tabler\_progress}, especially the associated
custom message handler, works. This test was simple and did not involve any input elements.
Yet, \texttt{\{crrry\}} also support setting input values with \texttt{shiny\_set\_input(id,\ value)}.

\hypertarget{test-input-bindings}{%
\subsection{Test input bindings}\label{test-input-bindings}}

We decide to add more complexity and show how to test a home made input binding. We are going to
test the tabler navbar JavaScript logic developed in Chapter \ref{custom-templates-inputs-navbar}.
Before starting to test, we define the expectations:

\begin{itemize}
\tightlist
\item
  If no \texttt{tabler\_navbar\_menu\_item} is selected by default, at start, the first item is selected.
  It must have the \texttt{active} class on it. We have to check whether the first \texttt{\textless{}a\ class="nav-link"\textgreater{}}
  has the active class.
\item
  Moreover, if one item is selected at start, we have to make sure this item has the \texttt{active} class.
\item
  We have to ensure that clicking on another link switch the currently selected link so that
  the corresponding input on the R side is properly updated.
\item
  When we call \texttt{update\_tabler\_tab\_item} we have to check whether the active link is
  successfully changed.
\item
  Each time a navbar item is active, the corresponding body \texttt{tabler\_tab\_item} must hold the
  \texttt{active\ show} class, to make sure the tab content is visible. Only on tab may have those classes at a time.
\end{itemize}

As described above, we run our app in another R process, so as to keep the main process
for the test:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\NormalTok{processx}\OperatorTok{::}\NormalTok{process}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}
  \StringTok{"Rscript"}\NormalTok{, }
  \KeywordTok{c}\NormalTok{( }\StringTok{"-e"}\NormalTok{,  }\StringTok{"options('shiny.port'= 3515);OSUICode::update_tabler_navbar_example()"}\NormalTok{ )}
\NormalTok{)}

\KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{2}\NormalTok{)}

\NormalTok{p}\OperatorTok{$}\KeywordTok{is_alive}\NormalTok{()}

\NormalTok{test <-}\StringTok{ }\NormalTok{crrry}\OperatorTok{::}\NormalTok{CrrryOnPage}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}
  \DataTypeTok{chrome_bin =}\NormalTok{ pagedown}\OperatorTok{::}\KeywordTok{find_chrome}\NormalTok{(),}
  \DataTypeTok{chrome_port =}\NormalTok{ httpuv}\OperatorTok{::}\KeywordTok{randomPort}\NormalTok{(),}
  \DataTypeTok{url =} \StringTok{"http://localhost:3515/"}\NormalTok{,}
  \DataTypeTok{headless =} \OtherTok{TRUE}
\NormalTok{)}

\NormalTok{test}\OperatorTok{$}\KeywordTok{wait_for_shiny_ready}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

At start, no link was selected, meaning we expect the first link to be active and shown. The navbar
may be targeted using the \texttt{navbar-nav} class and we use \texttt{find} to locate the active child which must
have the \texttt{nav-link\ active} classes. We also control that only 1 item is selected by inspecting the length
of the active nav link items.
We extract its index with \texttt{index} which is contained in the \texttt{data-value} attribute:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{active <-}\StringTok{ }\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"$('.navbar-nav').find('.nav-link.active').length"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(active}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value, }\DecValTok{1}\NormalTok{)}

\NormalTok{test}\OperatorTok{$}\KeywordTok{wait_for_shiny_ready}\NormalTok{()}

\NormalTok{res1 <-}\StringTok{ }\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"$('.navbar-nav').find('.nav-link.active').attr('data-value')"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(res1}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value, }\StringTok{"tab1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now let's see whether to body tab has the good index. We target the \texttt{tab-content} class and look
for the element having \texttt{active\ show} classes. We recover its id which contains the tab name:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res2 <-}\StringTok{ }\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"$('.tab-content').find('.active.show').attr('id')"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(res1}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value, res2}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value)}
\end{Highlighting}
\end{Shaded}

We programmatically change the active tab by clicking on the second link. Below we use
\texttt{.nav-link:eq(1)} to select the second link but we could use \texttt{.nav-link:not(.active)} since
we only have 2 links. We also recover the index of the selected link and the corresponding tab. If
everything happens well, we expect their value to be 2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"$('.navbar-nav .nav-link:eq(1)').click();"}\NormalTok{)}

\NormalTok{res3 <-}\StringTok{ }\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"$('.navbar-nav').find('.nav-link.active').attr('data-value')"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(res3}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value, }\StringTok{"tab2"}\NormalTok{)}

\NormalTok{test}\OperatorTok{$}\KeywordTok{wait_for_shiny_ready}\NormalTok{()}

\NormalTok{res4 <-}\StringTok{ }\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"$('.tab-content').find('.active.show').attr('id')"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(res3}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value, res4}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value)}
\end{Highlighting}
\end{Shaded}

We then click on the ``change tab'' button, that has the \texttt{update} id. The latter,
actually triggers \texttt{update\_tabler\_tab\_item}. We also want to check its behavior and expect
to be back on tab 1:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"$('#update').click();"}\NormalTok{)}

\NormalTok{res5 <-}\StringTok{ }\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"$('.navbar-nav').find('.nav-link.active').attr('data-value')"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(res5}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value, }\StringTok{"tab1"}\NormalTok{)}

\NormalTok{test}\OperatorTok{$}\KeywordTok{wait_for_shiny_ready}\NormalTok{()}

\NormalTok{res6 <-}\StringTok{ }\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"$('.tab-content').find('.active.show').attr('id')"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(res5}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value, res6}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value)}
\end{Highlighting}
\end{Shaded}

If the test is successful, it means that the \texttt{receiveMessage} and \texttt{setValue} methods
work as expected. We finally test the input value by setting its value to \texttt{tab2} with \texttt{shiny\_set\_input}.
All Shiny input values are stored in the \texttt{Shiny.shinyapp.\$inputValues} object, as shown in Chapter \ref{shiny-input-lifecycle}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test}\OperatorTok{$}\KeywordTok{shiny_set_input}\NormalTok{(}\StringTok{"current_tab"}\NormalTok{, }\StringTok{"tab2"}\NormalTok{)}
\NormalTok{tab_input <-}\StringTok{ }\NormalTok{test}\OperatorTok{$}\KeywordTok{call_js}\NormalTok{(}\StringTok{"Shiny.shinyapp.$inputValues.current_tab"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(tab_input}\OperatorTok{$}\NormalTok{result}\OperatorTok{$}\NormalTok{value, }\StringTok{"tab2"}\NormalTok{)}
\NormalTok{test}\OperatorTok{$}\KeywordTok{stop}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

This does not effect the navbar but triggers the notification.

As an exercise, we leave the reader to write a test to check the app behavior when
the second tab is active at start.

\hypertarget{custom-templates-inputs}{%
\chapter{Develop custom input widgets}\label{custom-templates-inputs}}

In the previous chapter, we built template dependencies, the page skeleton, as well as containers like cards. However, it would be nice to customize user interactions by integrating new inputs. In this chapter, we will apply knowledge from Chapter \ref{shiny-input-system} about creating new Shiny input.

\hypertarget{tabler-action-button}{%
\section{Tabler action button}\label{tabler-action-button}}

Let's start with a simple input: the action button. Tabler has built-in HTML buttons with a substantial amount of custom styles, compared to the classic Shiny action button.

\hypertarget{reminders-about-the-action-button}{%
\subsection{Reminders about the action button}\label{reminders-about-the-action-button}}

Below is the code of the \texttt{actionButton} input.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{actionButton <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (inputId, label, }\DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \OtherTok{NULL}\NormalTok{, ...)  \{}
\NormalTok{  value <-}\StringTok{ }\KeywordTok{restoreInput}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{default =} \OtherTok{NULL}\NormalTok{)}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{(}
    \DataTypeTok{id =}\NormalTok{ inputId, }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, }\KeywordTok{validateCssUnit}\NormalTok{(width), }\StringTok{";"}\NormalTok{), }
    \DataTypeTok{type =} \StringTok{"button"}\NormalTok{, }
    \DataTypeTok{class =} \StringTok{"btn btn-default action-button"}\NormalTok{, }
    \StringTok{`}\DataTypeTok{data-val}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{value, }
    \KeywordTok{list}\NormalTok{(}\KeywordTok{validateIcon}\NormalTok{(icon), label), ...}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The button tag has some attributes: id, style, type, class, \texttt{data-val}, label and children passed via \texttt{...}

When the app starts, the action button has the value 0 and each click will increment its value by 1. How is this behaviour created? For each Shiny input element (radio, slider), there is an associated JavaScript file, called input binding, which you can find \href{https://github.com/rstudio/shiny/tree/master/srcjs}{here}. In our case, we are only interested in the action button binding:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ actionButtonInputBinding }\OperatorTok{=} \KeywordTok{new} \AttributeTok{InputBinding}\NormalTok{()}\OperatorTok{;}
\VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(actionButtonInputBinding}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
    \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{".action-button"}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\},}
  \DataTypeTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
    \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'val'}\NormalTok{) }\OperatorTok{||} \DecValTok{0}\OperatorTok{;}
  \OperatorTok{\},}
  \CommentTok{// ... other methods}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

What you see above is \textbf{not} the whole script since we focus on the first method, that is \texttt{find}. It will look for \textbf{all} elements having the class \texttt{action-button}, making it possible to define multiple action buttons at the same time.

Consequently, if we go back to the previous section, the \texttt{actionButton} has the class \texttt{action-button}, thereby making it visible to the binding. Interestingly, all elements having the class \texttt{action-button} will be considered by the same shiny input binding.

\hypertarget{application-to-tabler}{%
\subsection{Application to Tabler}\label{application-to-tabler}}

First of all, let's compare the tabler HTML button to the Shiny action button.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<button}\OtherTok{ class=}\StringTok{"btn btn-primary"}\KeywordTok{>}\NormalTok{Button}\KeywordTok{</button>}
\end{Highlighting}
\end{Shaded}

We convert it to R. The button API contains more style and leave the reader to add extra elements as an exercise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_button <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, label, }\DataTypeTok{status =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{width =} \OtherTok{NULL}\NormalTok{, ...) \{}
  
\NormalTok{  btn_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"btn action-button"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(status)) \{}
      \StringTok{" btn-primary"}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \KeywordTok{paste0}\NormalTok{(}\StringTok{" btn-"}\NormalTok{, status)}
\NormalTok{    \}}
\NormalTok{  )}
  
\NormalTok{  value <-}\StringTok{ }\KeywordTok{restoreInput}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{default =} \OtherTok{NULL}\NormalTok{)}
  
  \CommentTok{# custom right margin}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(icon)) icon}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}
\NormalTok{    icon}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{class, }\StringTok{" mr-1"}
\NormalTok{  )}
  
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{button}\NormalTok{(}
    \DataTypeTok{id =}\NormalTok{ inputId, }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) }\KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, }\KeywordTok{validateCssUnit}\NormalTok{(width), }\StringTok{";"}\NormalTok{), }
    \DataTypeTok{type =} \StringTok{"button"}\NormalTok{, }
    \DataTypeTok{class =}\NormalTok{ btn_cl, }
    \StringTok{`}\DataTypeTok{data-val}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{value, }
    \KeywordTok{list}\NormalTok{(icon, label), ...}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In Tabler, the button status is mandatory, which is the reason why it is a parameter of the function. Moreover, we need to add an horizontal right margin to the icon, if provided so that the label renders well (\texttt{mr-1}, where m stands for margin, r is the right direction and 1 is the margin value). We assume that by default, the button wil have a blue color, that is given by \texttt{btn-primary}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_button}\NormalTok{(}
      \StringTok{"btn"}\NormalTok{, }
      \KeywordTok{HTML}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{"Value"}\NormalTok{, }\KeywordTok{textOutput}\NormalTok{(}\StringTok{"val"}\NormalTok{), }\DataTypeTok{sep =} \StringTok{":"}\NormalTok{)), }
      \DataTypeTok{icon =} \KeywordTok{icon}\NormalTok{(}\StringTok{"thumbs-up"}\NormalTok{), }
      \DataTypeTok{width =} \StringTok{"25%"}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{val <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(input}\OperatorTok{$}\NormalTok{btn)}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

We easily check that clicking on the button increments the related input. Thus, one may see how easy it is to implement a custom Tabler input button, built on top of the Shiny action button. The output is shown in Figure \ref{fig:tabler-button}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-button} \caption{Tabler action button}\label{fig:tabler-button}
\end{figure}

As a general rule, don't try to reinvent the wheel and see whether any existing Shiny element may be reused/adapted!

\hypertarget{toggle-switch}{%
\section{Toggle Switch}\label{toggle-switch}}

We implement the toggle \href{https://preview-dev.tabler.io/docs/form-elements.html\#custom-selectboxes}{switch} component.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<label}\OtherTok{ class=}\StringTok{"form-check form-switch"}\KeywordTok{>}
  \KeywordTok{<input}\OtherTok{ class=}\StringTok{"form-check-input"}\OtherTok{ type=}\StringTok{"checkbox"}\OtherTok{ checked}\KeywordTok{>}
  \KeywordTok{<span}\OtherTok{ class=}\StringTok{"form-check-label"}\KeywordTok{>}\NormalTok{Option 1}\KeywordTok{</span>}
\KeywordTok{</label>}
\end{Highlighting}
\end{Shaded}

Notice that the tabler switch has the checkbox type, which is very similar to the Shiny checkbox (a switch is a checkbox with a different style)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{checkboxInput}\NormalTok{(}\StringTok{"test"}\NormalTok{, }\StringTok{"Test"}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Therefore, we should again be able to build on top of an existing input \href{https://github.com/rstudio/shiny/blob/master/srcjs/input_binding_checkbox.js}{binding}. We create the \texttt{tabler\_switch} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_switch <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, label, }\DataTypeTok{value =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{width =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  value <-}\StringTok{ }\KeywordTok{restoreInput}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{default =}\NormalTok{ value)}
\NormalTok{  input_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{input}\NormalTok{(}
    \DataTypeTok{id =}\NormalTok{ inputId, }
    \DataTypeTok{type =} \StringTok{"checkbox"}\NormalTok{,}
    \DataTypeTok{class =} \StringTok{"form-check-input"}
\NormalTok{  )}
  
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(value) }\OperatorTok{&&}\StringTok{ }\NormalTok{value) \{}
\NormalTok{    input_tag <-}\StringTok{ }\NormalTok{input_tag }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendAttributes}\NormalTok{(}\DataTypeTok{checked =} \StringTok{"checked"}\NormalTok{)}
\NormalTok{  \}}
  
\NormalTok{  input_wrapper <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{label}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"form-check form-switch"}\NormalTok{, }
    \DataTypeTok{style =} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(width)) \{}
      \KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, }\KeywordTok{validateCssUnit}\NormalTok{(width), }\StringTok{";"}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  )}
  
\NormalTok{  input_wrapper }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChildren}\NormalTok{(}
\NormalTok{    input_tag,}
    \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"form-check-label"}\NormalTok{, label)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Besides, we may also create an \texttt{update\_tabler\_switch} function similar to the \texttt{updateCheckboxInput}. We will also need \texttt{dropNulls}, a function that removes all NULL elements from a list (this function is often used in all custom Shiny templates). If you remember, the \texttt{sendInputMessage} from R will be received by the \texttt{receiveMessage} method on the JavaScript side.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dropNulls <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x) \{}
\NormalTok{  x[}\OperatorTok{!}\KeywordTok{vapply}\NormalTok{(x, is.null, }\DataTypeTok{FUN.VALUE =} \KeywordTok{logical}\NormalTok{(}\DecValTok{1}\NormalTok{))]}
\NormalTok{\}}

\NormalTok{update_tabler_switch <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (session, inputId, }\DataTypeTok{label =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{value =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{dropNulls}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{label =}\NormalTok{ label, }\DataTypeTok{value =}\NormalTok{ value))}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In the following example, the action button toggles the switch input value when clicked, as shown in Figure \ref{fig:tabler-toggle}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Go!"}\NormalTok{, }\DataTypeTok{width =} \StringTok{"25%"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"mr-2"}\NormalTok{),}
      \KeywordTok{tabler_switch}\NormalTok{(}\StringTok{"toggle"}\NormalTok{, }\StringTok{"Switch"}\NormalTok{, }\DataTypeTok{value =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{width =} \StringTok{"25%"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(}\KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{toggle))}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
    \KeywordTok{update_tabler_switch}\NormalTok{(}
\NormalTok{      session, }
      \StringTok{"toggle"}\NormalTok{, }
      \DataTypeTok{value =} \OperatorTok{!}\NormalTok{input}\OperatorTok{$}\NormalTok{toggle}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-toggle} \caption{Tabler action button updating a toggle input}\label{fig:tabler-toggle}
\end{figure}

Et voil! Two inputs in few minutes.

\hypertarget{custom-templates-inputs-navbar}{%
\section{Navbar menu input}\label{custom-templates-inputs-navbar}}

As stated in Chapter \ref{shiny-input-system}, it is quite straightforward to bind other elements than pure inputs (HTML elements with the input tag) to Shiny. As a reminder, we created a custom input binding to detect the state of a shinydashboard box (collapsed/uncollapsed).
In chapter \ref{custom-templates-skeleton}, we created the \texttt{tabler\_navbar} as well as the \texttt{tabler\_navbar\_menu} and \texttt{tabler\_navbar\_menu\_item}. As in shinydashboard, it would be nice to capture the currently selected tab to be able to perform actions on the server side, updating the selected tab based on a button click.

Where do we start? First of all, we add an id attribute to the \texttt{tabler\_navbar\_menu} so that it holds the corresponding \texttt{input\$id}. Whether to use \texttt{inputId} or \texttt{id} as a parameter name is up to you, but keep in mind that \texttt{inputId} does not exist in HTML.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{inputId =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{ul}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ inputId, }\DataTypeTok{class =} \StringTok{"nav nav-pills navbar-nav"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The next step is the \texttt{navbarMenuBinding} creation. We decide to look for the \texttt{navbar-nav} class in the \texttt{find} method. Below, we describe the binding step by step. You may find the whole working code at the end of this example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
  \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{'.navbar-nav'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

In the \texttt{initialize} method, we ensure that if no tab is selected at start, the first tab will be selected by default. Otherwise, we select the activated tab. We use the string interpolation to ease the insertion of JS code in strings (\texttt{\$\{menuId\}\ .nav-link.active}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{initialize}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ menuId }\OperatorTok{=} \StringTok{'#'} \OperatorTok{+} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ .nav-link.active`}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// if multiple items are found}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{activeTab}\NormalTok{.}\AttributeTok{length} \OperatorTok{>} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{let}\NormalTok{ tabId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{tabId}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{addClass}\NormalTok{(}\StringTok{'show active'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ .nav-link`}\NormalTok{)}
\NormalTok{      .}\AttributeTok{first}\NormalTok{()}
\NormalTok{      .}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The role of \texttt{getValue} is to return the currently selected tab. As a reminder, here is the \texttt{tabler\_navbar\_menu\_item} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_navbar_menu_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(text, tabName, }\DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{selected =} \OtherTok{FALSE}\NormalTok{) \{}
  
\NormalTok{  item_cl <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"nav-link"}\NormalTok{, }\ControlFlowTok{if}\NormalTok{(selected) }\StringTok{" active"}\NormalTok{)}
  
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"nav-item"}\NormalTok{,}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{class =}\NormalTok{ item_cl,}
      \DataTypeTok{href =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, tabName),}
      \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "pill"}\NormalTok{, }\CommentTok{# see https://getbootstrap.com/docs/4.0/components/navs/}
      \StringTok{`}\DataTypeTok{data-value}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{tabName,}
      \DataTypeTok{role =} \StringTok{"tab"}\NormalTok{,}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav-link-icon d-md-none d-lg-inline-block"}\NormalTok{, icon),}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav-link-title"}\NormalTok{, text)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

From that function, the active item has is the \texttt{a} element with the classes \texttt{nav-link\ active}. We recover the tab value stored in the \texttt{data-value} attribute. A bit of jQuery will do the trick!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{find}\NormalTok{(}\StringTok{'a'}\NormalTok{).}\AttributeTok{filter}\NormalTok{(}\StringTok{'nav-link active'}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{setValue} is the function allowing to update the active tab. Bootstrap 4 already has
predefined methods to \href{https://getbootstrap.com/docs/4.0/components/navs/\#via-javascript}{activate} tabs. The easiest way is to select the tab by name like \texttt{\$(\textquotesingle{}\#tabMenu\ a{[}href="\#tab1"{]}\textquotesingle{}).tab(\textquotesingle{}show\textquotesingle{})}. The \texttt{receiveMessage} is simply applying the \texttt{setValue} method.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ value) }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ hrefVal }\OperatorTok{=} \StringTok{'#'} \OperatorTok{+}\NormalTok{ value}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ menuId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
  \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ a[href="}\SpecialCharTok{$\{}\NormalTok{hrefVal}\SpecialCharTok{\}}\VerbatimStringTok{"]`}\NormalTok{).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}

\NormalTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
  \KeywordTok{this}\NormalTok{.}\AttributeTok{setValue}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Besides, we have to create the \texttt{update\_tabler\_tab\_item} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{update_tabler_tab_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, value, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, }\DataTypeTok{message =}\NormalTok{ value)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{subscribe} will tell Shiny when to change the current input value and made it available
in the whole app. We may listen to multiple events, keeping in mind that events occur in the following order:

\begin{itemize}
\tightlist
\item
  hide.bs.tab (on the current active tab)
\item
  show.bs.tab (on the to-be-shown tab)
\item
  hidden.bs.tab (on the previous active tab, the same one as for the hide.bs.tab event)
\item
  shown.bs.tab (on the newly-active just-shown tab, the same one as for the show.bs.tab event)
\end{itemize}

Hence, it makes more sense to listen to \texttt{shown.bs.tab} (wait the current tab to be shown).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
  \CommentTok{// important to use shown.bs.tab and not show.bs.tab!}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'shown.bs.tab.navbarMenuBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
    \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\},}
  
\NormalTok{unsubscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{off}\NormalTok{(}\StringTok{'.navbarMenuBinding'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Below is a recap of the binding with the creation and registration included:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// Input binding}
  \KeywordTok{let}\NormalTok{ navbarMenuBinding }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{InputBinding}\NormalTok{()}
  \VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(navbarMenuBinding}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
      \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(scope).}\AttributeTok{find}\NormalTok{(}\StringTok{'.navbar-nav'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{initialize}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
      \KeywordTok{let}\NormalTok{ menuId }\OperatorTok{=} \StringTok{'#'} \OperatorTok{+} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
      \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ .nav-link.active`}\NormalTok{)}\OperatorTok{;}
      \CommentTok{// if multiple items are found}
      \ControlFlowTok{if}\NormalTok{ (}\VariableTok{activeTab}\NormalTok{.}\AttributeTok{length} \OperatorTok{>} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
        \KeywordTok{let}\NormalTok{ tabId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
        \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
        \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{tabId}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{addClass}\NormalTok{(}\StringTok{'show active'}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
        \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ .nav-link`}\NormalTok{)}
\NormalTok{          .}\AttributeTok{first}\NormalTok{()}
\NormalTok{          .}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\},}
    \CommentTok{// Given the DOM element for the input, return the value}
    \DataTypeTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
      \KeywordTok{let}\NormalTok{ activeTab }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{find}\NormalTok{(}\StringTok{'a'}\NormalTok{).}\AttributeTok{filter}\NormalTok{(}\StringTok{'.nav-link.active'}\NormalTok{)}\OperatorTok{;}
      \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(activeTab).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-value'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{setValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ value) }\OperatorTok{\{}
      \KeywordTok{let}\NormalTok{ hrefVal }\OperatorTok{=} \StringTok{'#'} \OperatorTok{+}\NormalTok{ value}\OperatorTok{;}
      \KeywordTok{let}\NormalTok{ menuId }\OperatorTok{=} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
      \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{menuId}\SpecialCharTok{\}}\VerbatimStringTok{ a[href="}\SpecialCharTok{$\{}\NormalTok{hrefVal}\SpecialCharTok{\}}\VerbatimStringTok{"]`}\NormalTok{).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
      \KeywordTok{this}\NormalTok{.}\AttributeTok{setValue}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
      \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'shown.bs.tab.navbarMenuBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
        \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \DataTypeTok{unsubscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
      \AttributeTok{$}\NormalTok{(el).}\AttributeTok{off}\NormalTok{(}\StringTok{'.navbarMenuBinding'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  
  \VariableTok{Shiny}\NormalTok{.}\VariableTok{inputBindings}\NormalTok{.}\AttributeTok{register}\NormalTok{(navbarMenuBinding}\OperatorTok{,} \StringTok{'navbar-menu'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

How do we include this custom input binding in our package? In the side package code, we created the following HTML dependency:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_custom_js <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"tabler-bindings"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"1.0.7"}\NormalTok{,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"tabler"}\NormalTok{),}
  \DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{,}
  \DataTypeTok{script =} \StringTok{"input-bindings/navbarMenuBinding.js"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also updated the \texttt{add\_tabler\_deps}, as below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add_tabler_deps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
  \CommentTok{# below, the order is of critical importance!}
\NormalTok{  deps <-}\StringTok{ }\KeywordTok{list}\NormalTok{(bs4_deps, tablers_deps, tabler_custom_js)}
  \KeywordTok{attachDependencies}\NormalTok{(tag, deps, }\DataTypeTok{append =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We test the new \texttt{navbar\_menu} binding below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \KeywordTok{tabler_navbar_menu}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"current_tab"}\NormalTok{,}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 1"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \DataTypeTok{selected =} \OtherTok{TRUE}
\NormalTok{      ),}
      \KeywordTok{tabler_navbar_menu_item}\NormalTok{(}
        \DataTypeTok{text =} \StringTok{"Tab 2"}\NormalTok{,}
        \DataTypeTok{icon =} \OtherTok{NULL}\NormalTok{,}
        \DataTypeTok{tabName =} \StringTok{"tab2"}
\NormalTok{      )}
\NormalTok{    ),}
    \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Change tab"}\NormalTok{, }\DataTypeTok{icon =} \KeywordTok{icon}\NormalTok{(}\StringTok{"exchange-alt"}\NormalTok{))}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_tab_items}\NormalTok{(}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab1"}\NormalTok{,}
        \KeywordTok{sliderInput}\NormalTok{(}
          \StringTok{"obs"}\NormalTok{, }
          \StringTok{"Number of observations:"}\NormalTok{,}
          \DataTypeTok{min =} \DecValTok{0}\NormalTok{,}
          \DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }
          \DataTypeTok{value =} \DecValTok{500}
\NormalTok{        ),}
        \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{      ),}
      \KeywordTok{tabler_tab_item}\NormalTok{(}
        \DataTypeTok{tabName =} \StringTok{"tab2"}\NormalTok{,}
        \KeywordTok{p}\NormalTok{(}\StringTok{"Second Tab"}\NormalTok{)}
\NormalTok{      )}
\NormalTok{    ),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{current_tab, \{}
    \KeywordTok{showNotification}\NormalTok{(}
      \KeywordTok{paste}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, input}\OperatorTok{$}\NormalTok{current_tab), }
      \DataTypeTok{type =} \StringTok{"message"}\NormalTok{,}
      \DataTypeTok{duration =} \DecValTok{1}
\NormalTok{    )}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
\NormalTok{    newTab <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (input}\OperatorTok{$}\NormalTok{current_tab }\OperatorTok{==}\StringTok{ "tab1"}\NormalTok{) }\StringTok{"tab2"} \ControlFlowTok{else} \StringTok{"tab1"}
    \KeywordTok{update_tabler_tab_item}\NormalTok{(}\StringTok{"current_tab"}\NormalTok{, newTab)}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Here we are!

\hypertarget{exercises-4}{%
\section{Exercises}\label{exercises-4}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Have a look at the Tabler documentation about \href{https://preview-dev.tabler.io/docs/buttons.html}{buttons} and extend the \texttt{tabler\_button} function accordingly.
\item
  Propose an implementation of the \texttt{Advanced\ selectboxes} shown \href{https://preview-dev.tabler.io/docs/form-elements.html\#}{here}.
\item
  Cards are a central elements of all templates. So are tabset panels. Improve the \texttt{tab\_card} function developed in exercise 1 of Chapter \ref{custom-templates-skeleton} so that one may easily recover the currently selected tab. Hint: a custom input binding is required.
\end{enumerate}

\hypertarget{custom-templates-interactivity}{%
\chapter{Adding more interactivity}\label{custom-templates-interactivity}}

In this part, we are going to add more life to the template element. We first see how to enhance an existing static HTML component. Then we will explore complex feedback mechanisms to provide more interactivity to your app.

All the JavaScript handlers described below are gathered in an HTML dependency, as well as the custom input binding(s).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# contains bindings and other JS code}
\NormalTok{tabler_custom_js <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"tabler-bindings"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"1.0.7"}\NormalTok{,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"tabler"}\NormalTok{),}
  \DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{,}
  \DataTypeTok{script =} \KeywordTok{c}\NormalTok{(}
    \StringTok{"input-bindings/navbarMenuBinding.js"}\NormalTok{,}
    \StringTok{"tabler_progress_handler.js"}\NormalTok{,}
    \StringTok{"tabler_toast_handler.js"}\NormalTok{,}
    \StringTok{"tabler_dropdown_handler.js"}\NormalTok{,}
    \StringTok{"tabler_insert_tab_handler.js"}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{custom-progress-bars}{%
\section{Custom progress bars}\label{custom-progress-bars}}

Progress bars are a good way to display metric related to a progress, for instance tracking the number of remaining tasks for a project. In general, those elements are static HTML. Hence, it would be interesting to be able to update the current value from the server side. Since it is not an proper input element, implementing an input binding is inappropriate and we decide to proceed with the \texttt{sendCustomMessage}/\texttt{addCustomMessageHandler} pair. We first create the \texttt{tabler\_progress} tag which is mainly composed of:

\begin{itemize}
\tightlist
\item
  \texttt{style} gives the current progress value. This is the main element
\item
  \texttt{min} and \texttt{max} are bounds, in general between 0 and 100
\item
  \texttt{id} ensures the progress bar uniqueness, thereby avoiding conflicts
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_progress <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, value) \{}
  \KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"progress"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(}
      \DataTypeTok{id =}\NormalTok{ id, }
      \DataTypeTok{class =} \StringTok{"progress-bar"}\NormalTok{,}
      \DataTypeTok{style =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"width: "}\NormalTok{, value, }\StringTok{"%"}\NormalTok{),}
      \DataTypeTok{role =} \StringTok{"progressbar"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{aria-valuenow}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{as.character}\NormalTok{(value),}
      \StringTok{`}\DataTypeTok{aria-valuemin}\StringTok{`}\NormalTok{ =}\StringTok{ "0"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{aria-valuemax}\StringTok{`}\NormalTok{ =}\StringTok{ "100"}\NormalTok{,}
      \KeywordTok{span}\NormalTok{(}\DataTypeTok{class =} \StringTok{"sr-only"}\NormalTok{, }\StringTok{"38% Complete"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{update_tabler_progress <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, value, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(id), }\DataTypeTok{value =}\NormalTok{ value)}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"update-progress"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The next element is the \texttt{update\_tabler\_progress} function which sends 2 elements from R to JS:

\begin{itemize}
\tightlist
\item
  The progress \texttt{id}
\item
  The new value
\end{itemize}

On the JS side, we have a basic \texttt{addCustomMessageHandler}. As mentioned in Chapter \ref{survival-kit-javascript}, \texttt{sendCustomMessage} and \texttt{addCustomMessageHandler} are connected by the \texttt{type} parameter. This is crucial! Moreover, as the sent message is a R list, it becomes an JSON, meaning that elements must be accessed with a \texttt{.} in JS:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update-progress'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{).}\AttributeTok{css}\NormalTok{(}\StringTok{'width'}\OperatorTok{,} \VariableTok{message}\NormalTok{.}\AttributeTok{value} \OperatorTok{+}\StringTok{'%'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We finally test these components in a simple app, whom output is depicted in Figure \ref{fig:tabler-progress}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{noUiSliderInput}\NormalTok{(}
      \DataTypeTok{inputId =} \StringTok{"progress_value"}\NormalTok{,}
      \DataTypeTok{label =} \StringTok{"Progress value"}\NormalTok{,}
      \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }
      \DataTypeTok{max =} \DecValTok{100}\NormalTok{,}
      \DataTypeTok{value =} \DecValTok{20}
\NormalTok{    ),}
    \KeywordTok{tabler_progress}\NormalTok{(}\DataTypeTok{id =} \StringTok{"progress1"}\NormalTok{, }\DecValTok{12}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{progress_value, \{}
    \KeywordTok{update_tabler_progress}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"progress1"}\NormalTok{, }
\NormalTok{      input}\OperatorTok{$}\NormalTok{progress_value}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-progress} \caption{Progress bar component updated by a slider}\label{fig:tabler-progress}
\end{figure}

NOTE: How to handle custom messages in shiny modules? Well, it is pretty straightforward: we wrap any id with the module namespace given by \texttt{session\$ns()} before sending it to JS. You may even do it by default (without modules) like in the previous example since \texttt{session\$ns()} will be \texttt{""}.

Is there a way to directly update the progress from the client which would avoid to exchange data between R and JS, thereby saving some time?

The idea is to get rid of the classic \texttt{session\$sendCustomMessage} and \texttt{Shiny.addCustomMessageHandler} method. We could directly create a function that
insert a script in the UI taking a trigger and target as main parameters. This function would have to be inserted multiple times if multiple triggers had to update the same target. The JS logic is slightly different:

\begin{itemize}
\tightlist
\item
  We have to wait for shiny to be connected so that all inputs/bindings are ready
\item
  We recover the trigger element with any JS/jQuery method
\item
  We leverage the noUiSlider \href{https://refreshless.com/nouislider/}{API} to listen to any update in the range. It's fine because the slider instance has already been initialized/defined in the shinyWidget \href{https://github.com/dreamRs/shinyWidgets/blob/master/inst/assets/nouislider/nouislider-bindings.js\#L100}{input binding}. This would not work if we were not waiting for shiny to be connected (you may try)! Notice the use of \texttt{this.get()} in the event listener, which avoids to repeat \texttt{slider.noUiSlider}
\item
  We modify the \texttt{width} CSS property of the target like in the previous example
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{on}\NormalTok{(}\StringTok{'shiny:connected'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ slider }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{'triggerId'}\NormalTok{)}\OperatorTok{;}
  \VariableTok{slider}\NormalTok{.}\VariableTok{noUiSlider}\NormalTok{.}\AttributeTok{on}\NormalTok{(}\StringTok{'update'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\StringTok{'#targetId'}\NormalTok{).}\AttributeTok{css}\NormalTok{(}\StringTok{'width'}\OperatorTok{,} \KeywordTok{this}\NormalTok{.}\AttributeTok{get}\NormalTok{() }\OperatorTok{+} \StringTok{'%'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{update_tabler_progress2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(trigger, target) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \KeywordTok{paste0}\NormalTok{(}
        \StringTok{"$(document).on('shiny:connected', function(event) \{}
\StringTok{            var slider = document.getElementById('"}\NormalTok{, trigger, }\StringTok{"');}
\StringTok{            slider.noUiSlider.on('update', function(event) \{}
\StringTok{              $('#"}\NormalTok{, target, }\StringTok{"').css('width', this.get() + '%');}
\StringTok{            \});}
\StringTok{          \});}
\StringTok{        "}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{update_tabler_progress2}\NormalTok{(}\StringTok{"progress_value"}\NormalTok{, }\StringTok{"progress1"}\NormalTok{),}
  \KeywordTok{update_tabler_progress2}\NormalTok{(}\StringTok{"progress_value2"}\NormalTok{, }\StringTok{"progress2"}\NormalTok{),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{fluidRow}\NormalTok{(}
      \KeywordTok{noUiSliderInput}\NormalTok{(}
        \DataTypeTok{inputId =} \StringTok{"progress_value"}\NormalTok{,}
        \DataTypeTok{label =} \StringTok{"Progress value 1"}\NormalTok{,}
        \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }
        \DataTypeTok{max =} \DecValTok{100}\NormalTok{,}
        \DataTypeTok{value =} \DecValTok{20}
\NormalTok{      ),}
      \KeywordTok{noUiSliderInput}\NormalTok{(}
        \DataTypeTok{inputId =} \StringTok{"progress_value2"}\NormalTok{,}
        \DataTypeTok{label =} \StringTok{"Progress value 2"}\NormalTok{,}
        \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }
        \DataTypeTok{max =} \DecValTok{100}\NormalTok{,}
        \DataTypeTok{value =} \DecValTok{80}\NormalTok{,}
        \DataTypeTok{color =} \StringTok{"red"}
\NormalTok{      )}
\NormalTok{    ),}
    \KeywordTok{tabler_progress}\NormalTok{(}\DataTypeTok{id =} \StringTok{"progress1"}\NormalTok{, }\DecValTok{12}\NormalTok{),}
    \KeywordTok{br}\NormalTok{(), }\KeywordTok{br}\NormalTok{(),}
    \KeywordTok{tabler_progress}\NormalTok{(}\DataTypeTok{id =} \StringTok{"progress2"}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Question: Run the above example in an external web browser, then stop the app from RStudio. Try to move both sliders. What happens for the progress bars? Compare with a classic \texttt{update} function. How could you explain this?

Overall this way is a bit more complex since you sometimes need to know the API of the trigger to listen to the correct events. Yet, assuming a very complex app with data manipulation, tons of inputs and visualizations, everything that can be done from the client (web browser) is less work for the R server part and a better end-user experience! Building outstanding shiny apps is not only designing amazing user interfaces, it's also about optimization and speed as mentioned by Colin Fay et al.~in their \href{https://engineering-shiny.org/optimjs.html}{book}.

\hypertarget{user-feedback-toasts}{%
\section{User feedback: toasts}\label{user-feedback-toasts}}

Toasts are components to send discrete user feedback, contrary to modals which open in the middle of the page. Toasts may open on all sides of the window and are similar to the Shiny notifications (see \href{https://shiny.rstudio.com/reference/shiny/0.14/showNotification.html}{here}). The tabler toast component is built on top of \href{https://getbootstrap.com/docs/4.3/components/toasts/}{Bootstrap 4}. Therefore, we will rely on this documentation.

\hypertarget{toast-skeleton}{%
\subsection{Toast skeleton}\label{toast-skeleton}}

The skeleton is the HTML structure of the toast:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"toast show"}\OtherTok{ role=}\StringTok{"alert"}\OtherTok{ aria-live=}\StringTok{"assertive"}\OtherTok{ aria-atomic=}\StringTok{"true"}\OtherTok{ data-autohide=}\StringTok{"false"}\OtherTok{ data-toggle=}\StringTok{"toast"}\KeywordTok{>}
  \KeywordTok{<div}\OtherTok{ class=}\StringTok{"toast-header"}\KeywordTok{>}
    \KeywordTok{<span}\OtherTok{ class=}\StringTok{"avatar mr-2"}\OtherTok{ style=}\StringTok{"background-image: url(...)"}\KeywordTok{></span>}
    \KeywordTok{<strong}\OtherTok{ class=}\StringTok{"mr-auto"}\KeywordTok{>}\NormalTok{Mallory Hulme}\KeywordTok{</strong>}
    \KeywordTok{<small>}\NormalTok{11 mins ago}\KeywordTok{</small>}
    \KeywordTok{<button}\OtherTok{ type=}\StringTok{"button"}\OtherTok{ class=}\StringTok{"ml-2 close"}\OtherTok{ data-dismiss=}\StringTok{"toast"}\OtherTok{ aria-label=}\StringTok{"Close"}\KeywordTok{>}
      \KeywordTok{<span}\OtherTok{ aria-hidden=}\StringTok{"true"}\KeywordTok{>}\DecValTok{&times;}\KeywordTok{</span>}
    \KeywordTok{</button>}
  \KeywordTok{</div>}
  \KeywordTok{<div}\OtherTok{ class=}\StringTok{"toast-body"}\KeywordTok{>}
\NormalTok{    Hello, world! This is a toast message.}
  \KeywordTok{</div>}
\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

Toasts are mainly composed of a header and a body. There might be a close button in case the toast does not hide itself. If multiple toasts appear one after each others, they are stacked, the latest being at the bottom of the stack. The position is controled with the style attribute like \texttt{style="position:\ absolute;\ top:\ 0;\ right:\ 0;"} for a top-right placement. Accessibility parameters like \texttt{aria-live} are detailed \href{https://getbootstrap.com/docs/4.3/components/toasts/\#accessibility}{here}.

\hypertarget{the-toast-api}{%
\subsection{The toast API}\label{the-toast-api}}

Toasts have a JS API to control their behaviour, for instance \texttt{\$(\textquotesingle{}\textless{}toast\_selector\textgreater{}\textquotesingle{}).toast(option)}, where option is a JSON with the following fields:

\begin{itemize}
\tightlist
\item
  animation applies a CSS fade transition to the toast and is TRUE by default
\item
  autohide automatically hides the toast (TRUE by default)
\item
  delay is the delay to hide the toast (500 ms)
\end{itemize}

There are 3 methods: hide, show and dispose (dispose ensures the toast does not appear anymore). Finally, we may fine tune the toast behavior with 4 events: show.bs.toast, shown.bs.toast, hide.bs.toast, hide.bs.toast, hidden.bs.toast (like for tabs).

\hypertarget{r-implementation}{%
\subsection{R implementation}\label{r-implementation}}

We first create the toast skeleton. We assume our toast will hide automatically, so that we may remove the delete button as well as the \texttt{data-autohide="false} attribute. All parameters are optional except the toast id, which is required to toggle the toast:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_toast <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{subtitle =} \OtherTok{NULL}\NormalTok{, ..., }\DataTypeTok{img =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  toast_header <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"toast-header"}\NormalTok{,}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(img)) \{}
      \KeywordTok{span}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"avatar mr-2"}\NormalTok{, }
        \DataTypeTok{style =} \KeywordTok{sprintf}\NormalTok{(}\StringTok{"background-image: url(%s)"}\NormalTok{, img)}
\NormalTok{      )}
\NormalTok{    \},}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(title)) }\KeywordTok{strong}\NormalTok{(}\DataTypeTok{class =} \StringTok{"mr-2"}\NormalTok{, title),}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(subtitle)) tags}\OperatorTok{$}\KeywordTok{small}\NormalTok{(subtitle)}
\NormalTok{  )}
  
\NormalTok{  toast_body <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"toast-body"}\NormalTok{, ...)}
  
\NormalTok{  toast_wrapper <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{id =}\NormalTok{ id,}
    \DataTypeTok{class =} \StringTok{"toast"}\NormalTok{,}
    \DataTypeTok{role =} \StringTok{"alert"}\NormalTok{,}
    \DataTypeTok{style =} \StringTok{"position: absolute; top: 0; right: 0;"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{aria-live}\StringTok{`}\NormalTok{ =}\StringTok{ "assertive"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{aria-atomic}\StringTok{`}\NormalTok{ =}\StringTok{ "true"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "toast"}
\NormalTok{  )}
  
\NormalTok{  toast_wrapper }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChildren}\NormalTok{(toast_header, toast_body)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We create the \texttt{show\_tabler\_toast} function. Since the toast automatically hides, it does not make sense to create the hide function, as well as the dispose.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_tabler_toast <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{dropNulls}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{id =}\NormalTok{ id,}
      \DataTypeTok{options =}\NormalTok{ options}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"tabler-toast"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The corresponding JS handler is given by:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'tabler-toast'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}
\NormalTok{      .}\AttributeTok{toast}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{options}\NormalTok{)}
\NormalTok{      .}\AttributeTok{toast}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}

    \CommentTok{// add custom Shiny input to listen to the toast state}
    \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'hidden.bs.toast'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
      \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \KeywordTok{true}\OperatorTok{,} \OperatorTok{\{}\DataTypeTok{priority}\OperatorTok{:} \StringTok{'event'}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We first configure the toast and show it. Notice how we chained jQuery methods (see Chapter \ref{survival-kit-javascript})! We optionally add an event listener to capture the \texttt{hidden.bs.toast} event, so that we may trigger an action when the toast is closed. The \texttt{input\$id} will be used for that purpose in combination with the \texttt{Shiny.setInputValue}. Notice the extra parameter \texttt{\{priority:\ \textquotesingle{}event\textquotesingle{}\}}: basically, once the toast is closed, \texttt{input\$id} will always be TRUE, thereby breaking the reactivity. Adding this extra parameter forces the evaluation of the input, although constant over time.

\hypertarget{wrap-up}{%
\subsection{Wrap up}\label{wrap-up}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_toast}\NormalTok{(}
    \DataTypeTok{id =} \StringTok{"toast"}\NormalTok{, }
    \DataTypeTok{title =} \StringTok{"Hello"}\NormalTok{, }
    \DataTypeTok{subtitle =} \StringTok{"now"}\NormalTok{, }
    \StringTok{"Toast body"}\NormalTok{,}
    \DataTypeTok{img =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}
\NormalTok{  ),}
  \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"launch"}\NormalTok{, }\StringTok{"Go!"}\NormalTok{, }\DataTypeTok{width =} \StringTok{"25%"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(}\KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{toast))}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{launch, \{}
    \KeywordTok{removeNotification}\NormalTok{(}\StringTok{"notif"}\NormalTok{)}
    \KeywordTok{show_tabler_toast}\NormalTok{(}
      \StringTok{"toast"}\NormalTok{, }
      \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{animation =} \OtherTok{FALSE}\NormalTok{,}
        \DataTypeTok{delay =} \DecValTok{3000}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{toast, \{}
    \KeywordTok{showNotification}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"notif"}\NormalTok{,}
      \StringTok{"Toast was closed"}\NormalTok{, }
      \DataTypeTok{type =} \StringTok{"warning"}\NormalTok{,}
      \DataTypeTok{duration =} \DecValTok{1}\NormalTok{,}
      
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-toast} \caption{Tabler toast element}\label{fig:tabler-toast}
\end{figure}

\hypertarget{transform-an-element-in-a-custom-action-button}{%
\section{Transform an element in a custom action button}\label{transform-an-element-in-a-custom-action-button}}

As seen in Chapter \ref{custom-templates-inputs}, any \texttt{\textless{}button\textgreater{}}, \texttt{\textless{}a\textgreater{}} element holding the \texttt{action-button} class may eventually become an action button. The Tabler template has dropdown menus in the navbar and we would like to transform those dropdown items in action buttons. The \texttt{tabler\_dropdown} functions takes the following parameters:

\begin{itemize}
\tightlist
\item
  id is required by the \texttt{show\_tabler\_dropdown} (see below) function which opens the menu
\item
  title is the dropdown menu name
\item
  subtitle is optional text
\item
  img is an optional image
\item
  \ldots{} hosts the \texttt{tabler\_dropdown\_item} (see below)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_dropdown <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, title, }\DataTypeTok{subtitle =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{img =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  img_tag <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(img)) \{}
    \KeywordTok{span}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"avatar"}\NormalTok{, }
      \DataTypeTok{style =} \KeywordTok{sprintf}\NormalTok{(}\StringTok{"background-image: url(%s)"}\NormalTok{, img)}
\NormalTok{    )}
\NormalTok{  \}}
  
\NormalTok{  titles_tag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"d-none d-xl-block pl-2"}\NormalTok{,}
    \KeywordTok{div}\NormalTok{(title),}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(subtitle)) \{}
      \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"mt-1 small text-muted"}\NormalTok{, subtitle)}
\NormalTok{    \}}
\NormalTok{  )}
  
\NormalTok{  link_tag <-}\StringTok{ }\KeywordTok{a}\NormalTok{(}
    \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
    \DataTypeTok{id =}\NormalTok{ id, }
    \DataTypeTok{class =} \StringTok{"nav-link d-flex lh-1 text-reset p-0"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "dropdown"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{aria-expanded}\StringTok{`}\NormalTok{ =}\StringTok{ "false"}
\NormalTok{  ) }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{tagAppendChildren}\NormalTok{(img_tag, titles_tag)}
  
\NormalTok{  dropdown_tag <-}\StringTok{ }\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"dropdown-menu dropdown-menu-right"}\NormalTok{, }
    \StringTok{`}\DataTypeTok{aria-labelledby}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{id, }
\NormalTok{    ...}
\NormalTok{  )}
  
  \KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"nav-item dropdown"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{tagAppendChildren}\NormalTok{(}
\NormalTok{    link_tag,}
\NormalTok{    dropdown_tag}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To convert a dropdown item in an action button , we add the \texttt{action-button} class as well as the \texttt{id} parameter to recover the corresponding input id.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabler_dropdown_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{a}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ id, }\DataTypeTok{class =} \StringTok{"dropdown-item action-button"}\NormalTok{, }\DataTypeTok{href =} \StringTok{"#"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We finally create the \texttt{show\_tabler\_dropdown} as well as the corresponding Shiny message handler.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_tabler_dropdown <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"show-dropdown"}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ id)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To show the dropdown, we use the \texttt{dropdown} method which is linked to the \texttt{data-toggle="dropdown"} of \texttt{tabler\_dropdown}.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'show-dropdown'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\VerbatimStringTok{`#}\SpecialCharTok{$\{}\NormalTok{message}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{).}\AttributeTok{dropdown}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Let's play with it! (See Figure \ref{fig:tabler-dropdown})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{tabler_page}\NormalTok{(}
  \KeywordTok{tabler_navbar}\NormalTok{(}
    \DataTypeTok{brand_url =} \StringTok{"https://preview-dev.tabler.io"}\NormalTok{, }
    \DataTypeTok{brand_image =} \StringTok{"https://preview-dev.tabler.io/static/logo.svg"}\NormalTok{, }
    \DataTypeTok{nav_menu =} \OtherTok{NULL}\NormalTok{, }
    \KeywordTok{tabler_dropdown}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"mydropdown"}\NormalTok{,}
      \DataTypeTok{title =} \StringTok{"Dropdown"}\NormalTok{,}
      \DataTypeTok{subtitle =} \StringTok{"click me"}\NormalTok{,}
      \KeywordTok{tabler_dropdown_item}\NormalTok{(}
        \DataTypeTok{id =} \StringTok{"item1"}\NormalTok{,}
        \StringTok{"Show Notification"}
\NormalTok{      ),}
      \KeywordTok{tabler_dropdown_item}\NormalTok{(}
        \StringTok{"Do nothing"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \KeywordTok{tabler_body}\NormalTok{(}
    \KeywordTok{tabler_button}\NormalTok{(}\StringTok{"show"}\NormalTok{, }\StringTok{"Open dropdown"}\NormalTok{, }\DataTypeTok{width =} \StringTok{"25%"}\NormalTok{),}
    \DataTypeTok{footer =} \KeywordTok{tabler_footer}\NormalTok{(}
      \DataTypeTok{left =} \StringTok{"Rstats, 2020"}\NormalTok{, }
      \DataTypeTok{right =} \KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{)}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{show, \{}
    \KeywordTok{show_tabler_dropdown}\NormalTok{(}\StringTok{"mydropdown"}\NormalTok{)}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{item1, \{}
    \KeywordTok{showNotification}\NormalTok{(}
      \StringTok{"Success"}\NormalTok{, }
      \DataTypeTok{type =} \StringTok{"message"}\NormalTok{,}
      \DataTypeTok{duration =} \DecValTok{2}\NormalTok{,}
      
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-dropdown} \caption{Tabler dropdown element}\label{fig:tabler-dropdown}
\end{figure}

\hypertarget{tab-events}{%
\section{Tab events}\label{tab-events}}

Do you remember about the navbar element and the tabsetpanel system of Chapter \ref{custom-templates-skeleton}? Navs allow to organize any app into several tabs, acting like pages. This is a powerful tool for Shiny since it is currently not straightforward to create \href{https://community.rstudio.com/t/shiny-app-composed-of-many-many-pages/7698}{multi-pages} Shiny apps like anyone would do with a website. Navs relie on the Bootstrap4 API but we only used few JS functions.

\hypertarget{insert-tabs}{%
\subsection{Insert/Remove tabs in tabsetpanel}\label{insert-tabs}}

How about dynamically inserting/removing tabs from a \texttt{tabler\_navbar}? I chose this example since it involves extra technical details about Shiny.

How do we proceed? if you remember about the \texttt{tabler\_navbar\_menu\_item} and \texttt{tabler\_tab\_item} coupling, inserting a tab implies to insert the trigger in the navigation menu as well as the content in the dashboard body. Therefore, we need to know the structure of what we insert. Below is a reminder:

\begin{itemize}
\tightlist
\item
  \texttt{tabler\_navbar\_menu\_item} are \texttt{\textless{}li\textgreater{}} elements
\item
  \texttt{tabler\_navbar\_menu\_item} is a \texttt{\textless{}div\textgreater{}} element with specific classes
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<li}\OtherTok{ class=}\StringTok{"nav-item"}\KeywordTok{>}
  \KeywordTok{<a}\OtherTok{ class=}\StringTok{"nav-link"}\OtherTok{ href=}\StringTok{"#ww"}\OtherTok{ data-toggle=}\StringTok{"pill"}\OtherTok{ data-value=}\StringTok{"ww"}\OtherTok{ role=}\StringTok{"tab"}\KeywordTok{>}
    \KeywordTok{<span}\OtherTok{ class=}\StringTok{"nav-link-icon d-md-none d-lg-inline-block"}\KeywordTok{></span>}
    \KeywordTok{<span}\OtherTok{ class=}\StringTok{"nav-link-title"}\KeywordTok{>}\NormalTok{ww}\KeywordTok{</span>}
  \KeywordTok{</a>}
\KeywordTok{</li>}

\KeywordTok{<div}\OtherTok{ role=}\StringTok{"tabpanel"}\OtherTok{ class=}\StringTok{"tab-pane fade container-fluid"}\OtherTok{ id=}\StringTok{"ww"}\KeywordTok{></div>}
\end{Highlighting}
\end{Shaded}

We design the \texttt{insert\_tabler\_tab} function similar to the Shiny \texttt{insertTab}.
To handle shiny modules, we wrap the inputId in the session namespace \texttt{session\$ns}. We create the menu item element based on the provided new tab.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{insert_tabler_tab <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, tab, target, }\DataTypeTok{position =} \KeywordTok{c}\NormalTok{(}\StringTok{"before"}\NormalTok{, }\StringTok{"after"}\NormalTok{),}
                              \DataTypeTok{select =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
  
\NormalTok{  inputId <-}\StringTok{ }\NormalTok{session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(inputId)}
\NormalTok{  position <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(position)}
\NormalTok{  navbar_menu_item <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"nav-item"}\NormalTok{,}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"nav-link"}\NormalTok{,}
      \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{data-target}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id)),}
      \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "pill"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{data-value}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id,}
      \DataTypeTok{role =} \StringTok{"tab"}\NormalTok{,}
\NormalTok{      tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{  tab <-}\StringTok{ }\KeywordTok{force}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(tab))}
\NormalTok{  navbar_menu_item <-}\StringTok{ }\KeywordTok{force}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(navbar_menu_item))}
  
\NormalTok{  message <-}\StringTok{ }\KeywordTok{dropNulls}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{inputId =}\NormalTok{ inputId,}
      \DataTypeTok{content =}\NormalTok{ tab,}
      \DataTypeTok{link =}\NormalTok{ navbar_menu_item,}
      \DataTypeTok{target =}\NormalTok{ target,}
      \DataTypeTok{position =}\NormalTok{ position,}
      \DataTypeTok{select =}\NormalTok{ select}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"insert-tab"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

On the JS side, we capture the R message (list) in two elements:

\begin{itemize}
\tightlist
\item
  \texttt{\$divTag} contains the tab content
\item
  \texttt{\$liTag} contains the tab link, ie the navigation part
\end{itemize}

Depending on the position parameter, we use the \texttt{insertAfter} and \texttt{insertBefore} jQuery methods. Finally, if the newly inserted tab has to be
selected, we activate the corresponding tab element with \texttt{\$(tablink).tab(\textquotesingle{}show\textquotesingle{})}.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'insert-tab'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \CommentTok{// define div and li targets}
    \KeywordTok{let}\NormalTok{ $divTag }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{content}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{let}\NormalTok{ $liTag }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{link}\NormalTok{)}\OperatorTok{;}
    
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{position} \OperatorTok{===} \StringTok{'after'}\NormalTok{) }\OperatorTok{\{}
      \VariableTok{$divTag}\NormalTok{.}\AttributeTok{insertAfter}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target}\NormalTok{))}\OperatorTok{;}
      \VariableTok{$liTag}\NormalTok{.}\AttributeTok{insertAfter}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'[data-target="#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target} \OperatorTok{+} \StringTok{'"]'}\NormalTok{).}\AttributeTok{parent}\NormalTok{())}\OperatorTok{;}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{position} \OperatorTok{===} \StringTok{'before'}\NormalTok{) }\OperatorTok{\{}
      \VariableTok{$divTag}\NormalTok{.}\AttributeTok{insertBefore}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target}\NormalTok{))}\OperatorTok{;}
      \VariableTok{$liTag}\NormalTok{.}\AttributeTok{insertBefore}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'[data-target="#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target} \OperatorTok{+} \StringTok{'"]'}\NormalTok{).}\AttributeTok{parent}\NormalTok{())}\OperatorTok{;}
    \OperatorTok{\}}
    
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{select}\NormalTok{) }\OperatorTok{\{}
      \CommentTok{// trigger a click on corresponding the new tab button. }
      \KeywordTok{let}\NormalTok{ newTabId }\OperatorTok{=} \VariableTok{$divTag}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
      \AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{inputId} \OperatorTok{+} \StringTok{' a[data-target="#'} \OperatorTok{+}\NormalTok{ newTabId }\OperatorTok{+}\StringTok{'"]'}\NormalTok{).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{insert_tabler_tab_example}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If the tab is well inserted, we notice that the slider and the plot are not properly shown, as illustrated in Figure \ref{fig:tabler-insert-tab-fail}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/tabler-insert-tab-fail} \caption{The newly inserted tab fails to render its content!}\label{fig:tabler-insert-tab-fail}
\end{figure}

How could we explain that? It is a dependency issue: the slider input relies on a specific JS \href{http://ionden.com/a/plugins/ion.rangeSlider/}{library}, namely ionRangesSlider, as depicted in Figure \ref{fig:slider-deps}. In our previous example, if you open the HTML inspector, the dependency is not included in the page.

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/slider-deps} \caption{Slider dependencies.}\label{fig:slider-deps}
\end{figure}

Even stranger, when we use \texttt{renderUI} to conditionally render the slider (note: this is a dummy example), the dependency is only included when the go button is pressed. How does Shiny includes them?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  shiny}\OperatorTok{::}\KeywordTok{actionButton}\NormalTok{(}\StringTok{"go"}\NormalTok{, }\StringTok{"Go!"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"btn-success"}\NormalTok{),}
  \KeywordTok{uiOutput}\NormalTok{(}\StringTok{"slider"}\NormalTok{),}
  \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"distPlot"}\NormalTok{)}
\NormalTok{)}

\CommentTok{# Server logic}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output) \{}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{slider <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
    \KeywordTok{req}\NormalTok{(input}\OperatorTok{$}\NormalTok{go }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{)}
    \KeywordTok{sliderInput}\NormalTok{(}
      \StringTok{"obs"}\NormalTok{, }
      \StringTok{"Number of observations:"}\NormalTok{,}
      \DataTypeTok{min =} \DecValTok{0}\NormalTok{, }
      \DataTypeTok{max =} \DecValTok{1000}\NormalTok{, }
      \DataTypeTok{value =} \DecValTok{500}
\NormalTok{    )}
\NormalTok{  \})}
  
\NormalTok{  output}\OperatorTok{$}\NormalTok{distPlot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
    \KeywordTok{req}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs)}
    \KeywordTok{hist}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(input}\OperatorTok{$}\NormalTok{obs))}
\NormalTok{  \})}
\NormalTok{\}}

\CommentTok{# Complete app with UI and server components}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Let's look at \texttt{renderUI}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{renderUI <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (expr, }\DataTypeTok{env =} \KeywordTok{parent.frame}\NormalTok{(), }\DataTypeTok{quoted =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{outputArgs =} \KeywordTok{list}\NormalTok{()) \{}
  \KeywordTok{installExprFunction}\NormalTok{(expr, }\StringTok{"func"}\NormalTok{, env, quoted)}
  \KeywordTok{createRenderFunction}\NormalTok{(func, }\ControlFlowTok{function}\NormalTok{(result, shinysession, }
\NormalTok{                                      name, ...) \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(result) }\OperatorTok{||}\StringTok{ }\KeywordTok{length}\NormalTok{(result) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }
      \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
    \CommentTok{#processDeps(result, shinysession)}
\NormalTok{    result}
\NormalTok{  \}, uiOutput, outputArgs)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The last line returned is \texttt{processDeps(result,\ shinysession)}. This function is responsible to handle dependencies during run time. \texttt{processDeps} (R side) works with \texttt{Shiny.renderContent} (JS side),
as already mentioned in part \ref{insert-ui}. The latter takes a tag element as well as an
object containing its HTML code and dependencies, for instance:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{exports}\NormalTok{.}\AttributeTok{renderContent}\NormalTok{($tag[}\DecValTok{0}\NormalTok{]}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{html}\OperatorTok{:} \VariableTok{$tag}\NormalTok{.}\AttributeTok{html}\NormalTok{()}\OperatorTok{,}
  \DataTypeTok{deps}\OperatorTok{:} \VariableTok{message}\NormalTok{.}\VariableTok{tag}\NormalTok{.}\AttributeTok{deps}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;} 
\end{Highlighting}
\end{Shaded}

In the following, we modify the \texttt{insert\_tabler\_tab} to include the dependencies processing step.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{insert_tabler_tab <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, tab, target, }\DataTypeTok{position =} \KeywordTok{c}\NormalTok{(}\StringTok{"before"}\NormalTok{, }\StringTok{"after"}\NormalTok{),}
                              \DataTypeTok{select =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{session =} \KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
  
\NormalTok{  inputId <-}\StringTok{ }\NormalTok{session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(inputId)}
\NormalTok{  position <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(position)}
\NormalTok{  navbar_menu_item <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"nav-item"}\NormalTok{,}
    \KeywordTok{a}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"nav-link"}\NormalTok{,}
      \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{data-target}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id)),}
      \StringTok{`}\DataTypeTok{data-toggle}\StringTok{`}\NormalTok{ =}\StringTok{ "pill"}\NormalTok{,}
      \StringTok{`}\DataTypeTok{data-value}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id,}
      \DataTypeTok{role =} \StringTok{"tab"}\NormalTok{,}
\NormalTok{      tab}\OperatorTok{$}\NormalTok{attribs}\OperatorTok{$}\NormalTok{id}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{  message <-}\StringTok{ }\KeywordTok{dropNulls}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{inputId =}\NormalTok{ inputId,}
      \DataTypeTok{content =} \KeywordTok{processDeps}\NormalTok{(tab, session),}
      \DataTypeTok{link =} \KeywordTok{processDeps}\NormalTok{(navbar_menu_item, session),}
      \DataTypeTok{target =}\NormalTok{ target,}
      \DataTypeTok{position =}\NormalTok{ position,}
      \DataTypeTok{select =}\NormalTok{ select}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"insert-tab"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We then apply the \texttt{Shiny.renderContent} method to the tab content and navigation item.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'insert-tab'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
    \CommentTok{// define div and li targets}
    \KeywordTok{let}\NormalTok{ $divTag }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VariableTok{message}\NormalTok{.}\VariableTok{content}\NormalTok{.}\AttributeTok{html}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{let}\NormalTok{ $liTag }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\VariableTok{message}\NormalTok{.}\VariableTok{link}\NormalTok{.}\AttributeTok{html}\NormalTok{)}\OperatorTok{;}
    
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{position} \OperatorTok{===} \StringTok{'after'}\NormalTok{) }\OperatorTok{\{}
      \VariableTok{$divTag}\NormalTok{.}\AttributeTok{insertAfter}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target}\NormalTok{))}\OperatorTok{;}
      \VariableTok{$liTag}\NormalTok{.}\AttributeTok{insertAfter}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'[data-target="#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target} \OperatorTok{+}   \StringTok{'"]'}\NormalTok{).}\AttributeTok{parent}\NormalTok{())}\OperatorTok{;}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{position} \OperatorTok{===} \StringTok{'before'}\NormalTok{) }\OperatorTok{\{}
      \VariableTok{$divTag}\NormalTok{.}\AttributeTok{insertBefore}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target}\NormalTok{))}\OperatorTok{;}
      \VariableTok{$liTag}\NormalTok{.}\AttributeTok{insertBefore}\NormalTok{(}\AttributeTok{$}\NormalTok{(}\StringTok{'[data-target="#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{target} \OperatorTok{+}   \StringTok{'"]'}\NormalTok{).}\AttributeTok{parent}\NormalTok{())}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// needed to render input/output in newly added tab. It takes the possible}
    \CommentTok{// deps and add them to the tag. Indeed, if we insert a tab, its deps are not}
    \CommentTok{// included in the page so it can't render properly}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{renderContent}\NormalTok{($liTag[}\DecValTok{0}\NormalTok{]}\OperatorTok{,} \OperatorTok{\{}\DataTypeTok{html}\OperatorTok{:} \VariableTok{$liTag}\NormalTok{.}\AttributeTok{html}\NormalTok{()}\OperatorTok{,} \DataTypeTok{deps}\OperatorTok{:} \VariableTok{message}\NormalTok{.}\VariableTok{link}\NormalTok{.}\AttributeTok{deps}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{renderContent}\NormalTok{($divTag[}\DecValTok{0}\NormalTok{]}\OperatorTok{,} \OperatorTok{\{}\DataTypeTok{html}\OperatorTok{:} \VariableTok{$divTag}\NormalTok{.}\AttributeTok{html}\NormalTok{()}\OperatorTok{,} \DataTypeTok{deps}\OperatorTok{:} \VariableTok{message}\NormalTok{.}\VariableTok{content}\NormalTok{.}\AttributeTok{deps}\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{select}\NormalTok{) }\OperatorTok{\{}
      \CommentTok{// trigger a click on corresponding the new tab button. }
      \KeywordTok{let}\NormalTok{ newTabId }\OperatorTok{=} \VariableTok{$divTag}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{'id'}\NormalTok{)}\OperatorTok{;}
      \AttributeTok{$}\NormalTok{(}\StringTok{'#'} \OperatorTok{+} \VariableTok{message}\NormalTok{.}\AttributeTok{inputId} \OperatorTok{+} \StringTok{' a[data-target="#'} \OperatorTok{+}\NormalTok{ newTabId   }\OperatorTok{+}\StringTok{'"]'}\NormalTok{).}\AttributeTok{tab}\NormalTok{(}\StringTok{'show'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We check if our approach works as expected.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{insert_tabler_tab_example}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/practice/process-deps} \caption{processDeps and Shiny.renderContent in action.}\label{fig:process-deps}
\end{figure}

Et voila! As shown in Figure \ref{fig:process-deps}, everything is properly displayed.

\hypertarget{exercises-5}{%
\section{Exercises}\label{exercises-5}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Taking inspiration on the \texttt{insert\_tabler\_tab} function, write the \texttt{remove\_tabler\_tab} function.
\item
  Based on the Tabler \href{https://preview-dev.tabler.io/docs/tooltips.html}{documentation}, add the \texttt{tabler\_tooltip} function. Hint: you may also check the corresponding Bootstrap 4 help.
\end{enumerate}

\hypertarget{part-toward-a-better-workflow}{%
\part*{Toward a better workflow}\label{part-toward-a-better-workflow}}


\hypertarget{workflow-charpente}{%
\chapter{Introduction to \{charpente\}}\label{workflow-charpente}}

\begin{figure}

{\centering \includegraphics[width=0.25\linewidth]{images/workflow/charpente-hex} 

}

\caption{The {charpente} package}\label{fig:workflow-charpente-hex}
\end{figure}

\hypertarget{motivations-1}{%
\section{Motivations}\label{motivations-1}}

Translating an HTML template into an R API requires the creation of a package. As stated in Chapter \ref{welcome-code-structure}, this is not a good practice to proceed as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{useShinydashboard}\NormalTok{(),}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"$(function() \{}
\StringTok{      let boxBinding = new Shiny.InputBinding();}
\StringTok{      $.extend(boxBinding, \{}
\StringTok{        initialize: function(el) \{}
\StringTok{          $(el).activateBox();}
\StringTok{        \},}
\StringTok{        find: function(scope) \{}
\StringTok{          return $(scope).find('.box');}
\StringTok{        \},}
\StringTok{        getValue: function(el) \{}
\StringTok{          let isCollapsed = $(el).hasClass('collapsed-box');}
\StringTok{          return \{collapsed: isCollapsed\}; // this will be a list in R}
\StringTok{        \},}
\StringTok{        setValue: function(el, value) \{}
\StringTok{          $(el).toggleBox();}
\StringTok{        \}, }
\StringTok{        receiveMessage: function(el, data) \{}
\StringTok{          this.setValue(el, data);}
\StringTok{          $(el).trigger('change');}
\StringTok{        \},}
\StringTok{        subscribe: function(el, callback) \{}
\StringTok{          $(el).on('click', '[data-widget=}\CharTok{\textbackslash{}"}\StringTok{collapse}\CharTok{\textbackslash{}"}\StringTok{]', function(event) \{}
\StringTok{            setTimeout(function() \{}
\StringTok{              callback();}
\StringTok{            \}, 550);}
\StringTok{          \}); }
\StringTok{          $(el).on('change', function(event) \{}
\StringTok{            setTimeout(function() \{}
\StringTok{              callback();}
\StringTok{            \}, 550);}
\StringTok{          \});}
\StringTok{        \},}
\StringTok{        unsubscribe: function(el) \{}
\StringTok{          $(el).off('.boxBinding');}
\StringTok{        \}}
\StringTok{      \});}
\StringTok{      Shiny.inputBindings.register(boxBinding, 'box-input');}
\StringTok{    \});}
\StringTok{    "}
\NormalTok{  ),}
  
  \KeywordTok{box2}\NormalTok{(}
    \DataTypeTok{title =} \KeywordTok{textOutput}\NormalTok{(}\StringTok{"box_state"}\NormalTok{),}
    \StringTok{"Box body"}\NormalTok{,}
    \DataTypeTok{inputId =} \StringTok{"mybox"}\NormalTok{,}
    \DataTypeTok{collapsible =} \OtherTok{TRUE}\NormalTok{,}
    \KeywordTok{plotOutput}\NormalTok{(}\StringTok{"plot"}\NormalTok{)}
\NormalTok{  ),}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"toggle_box"}\NormalTok{, }\StringTok{"Toggle Box"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
\NormalTok{  output}\OperatorTok{$}\NormalTok{plot <-}\StringTok{ }\KeywordTok{renderPlot}\NormalTok{(\{}
      \KeywordTok{req}\NormalTok{(}\OperatorTok{!}\NormalTok{input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed)}
      \KeywordTok{plot}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{200}\NormalTok{))}
\NormalTok{    \})}
    
\NormalTok{    output}\OperatorTok{$}\NormalTok{box_state <-}\StringTok{ }\KeywordTok{renderText}\NormalTok{(\{}
\NormalTok{      state <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (input}\OperatorTok{$}\NormalTok{mybox}\OperatorTok{$}\NormalTok{collapsed) }\StringTok{"collapsed"} \ControlFlowTok{else} \StringTok{"uncollapsed"}
      \KeywordTok{paste}\NormalTok{(}\StringTok{"My box is"}\NormalTok{, state)}
\NormalTok{    \})}
    
    \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{toggle_box, \{}
      \KeywordTok{updateBox2}\NormalTok{(}\StringTok{"mybox"}\NormalTok{)}
\NormalTok{    \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Imagine if we had to repeat the process for more than twenty components. The package structure provides many advantages like:

\begin{itemize}
\tightlist
\item
  Develop a comprehensive documentation of the underlying API
\item
  Design unit tests to guaranty code robustness and improve long term plan
\item
  Relevant file organization
\end{itemize}

\hypertarget{general-idea}{%
\section{General idea}\label{general-idea}}

\href{https://github.com/RinteRface/charpente}{\{charpente\}} is a game changer for custom template creation.
It is not yet on CRAN but has been widely used to help developing RinteRface packages.
\texttt{\{charpente\}} drastically:

\begin{itemize}
\tightlist
\item
  Eases the import of external dependencies.
\item
  Speeds up the HTML to R conversion, which is quite frankly a rather boring process,
  allowing to focus on the features rather than the syntax. This feature builds on top of the \texttt{\{html2R\}} shiny app by Alan Dipert, already mentioned in Chapter \ref{htmltools-overview}.
\item
  Eases JS code management, leveraging \href{https://esbuild.github.io/}{esbuild}.
\end{itemize}

Let's try below with \texttt{html\_2\_R}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(charpente)}
\KeywordTok{html_2_R}\NormalTok{(}\StringTok{'<div class="divclass" id = "someid"></div>'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
\end{verbatim}

\begin{verbatim}
## -- Converting code ... --
\end{verbatim}

\begin{verbatim}
## 
\end{verbatim}

\begin{verbatim}
## v Code converted with success.
\end{verbatim}

\begin{verbatim}
## i Copy and paste the following R code
\end{verbatim}

\begin{verbatim}
## --------------------------------------------------------------------------------
\end{verbatim}

\begin{verbatim}
## tags$div(
##   class = "divclass",
##   id = "someid"
## )
\end{verbatim}

\texttt{html\_2\_R} has a \textbf{prefix} parameter which adds a \texttt{tags\$} prefix if TRUE. It is
TRUE by default which prevents errors with non exported Shiny tags like \texttt{nav}.

The second main benefice of \texttt{\{charpente\}} is the dependency management system.

\hypertarget{a-case-study-shinybulma}{%
\section{\texorpdfstring{A case study: \texttt{\{shinybulma\}}}{A case study: \{shinybulma\}}}\label{a-case-study-shinybulma}}

In the following, we'll illustrate \texttt{\{charpente\}}'s workflow, through the R in Pharma workshop \href{https://github.com/RinteRface/Unleash-Shiny-Exercise-1}{exercises} focused on \texttt{\{shinybulma\}}.

\href{https://bulma.io/}{bulma} is a more and more popular open source CSS framework for the web.
Importantly, there \textbf{isn't} any JavaScript helper in the bulma core.
We'll see later that the recent \href{https://bulmajs.tomerbe.co.uk/}{bulma JS} provides such feature.
For now, we only focus on HTML and CSS.

To initialize a \texttt{\{charpente\}} package, we do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"mypkg"}\NormalTok{)}
\KeywordTok{create_charpente}\NormalTok{(path, }\DataTypeTok{license =} \StringTok{"mit"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This sets up a minimal viable package with git and optionally github remote setup,
Figure \ref{fig:workflow-charpente-pkg}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/workflow/charpente-pkg} 

}

\caption{Package structure for {charpente}}\label{fig:workflow-charpente-pkg}
\end{figure}

By default, the package \texttt{DESCRIPTION} \texttt{Imports} field has \texttt{shiny}, \texttt{htmltools} and
\texttt{utils}. \texttt{\{charpente\}} is never required to be a dependency of your package since it might
be invasive.

In the \texttt{./R} folder, \texttt{\{charpente\}} creates a \texttt{mypkg-utils.R} script containing:

\begin{itemize}
\tightlist
\item
  Tools to facilitate HTML dependency management like \texttt{add\_dependencies} (see corresponding section below),
  \texttt{processDeps}.
\item
  Some validation functions mentioned in Chapter \ref{custom-templates-testing}.
\end{itemize}

Finally, you may see some exotic folders and files like \texttt{srcjs}, \texttt{package.json}, \texttt{package-lock.json} and \texttt{node\_modules}. Fear not, we describe them later in \ref{organize-your-js}. Overall, they are here to support to JS code management.

\hypertarget{build-the-html-dependency}{%
\subsection{Build the HTML dependency}\label{build-the-html-dependency}}

The interested reader may have a look at the \textbf{Getting started \href{https://bulma.io/documentation/overview/start/}{guide}},
so as to know more how to get bulma. To install bulma dependencies, there are several ways:

\begin{itemize}
\tightlist
\item
  The CDN method (content delivery network) which consists in getting dependencies from a dedicated server.
  Files are not stored locally which may be a problem if one does not have internet.
\item
  The local method consists in downloading the production files (minified CSS).
\item
  Using npm that installs bulma sources as well as production files. It means one can modify
  sources at anytime, which is not recommended since it would be hard to
  maintain.
\end{itemize}

In our case, we show the two first methods, the third being out of the scope of this book.

As shown in previous Chapter \ref(custom-templates-dependencies),
we could build the bulma dependency as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(htmltools)}
\NormalTok{bulma_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =}\NormalTok{ ...,}
  \DataTypeTok{version =}\NormalTok{ ...,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =}\NormalTok{ ...),}
  \DataTypeTok{stylesheet =}\NormalTok{ ...}
\NormalTok{)}

\NormalTok{add_bulma_deps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
  \KeywordTok{tagList}\NormalTok{(..., ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

but this already takes too much time. This is where \texttt{\{charpente\}} comes into play.
Specifically, the \texttt{create\_dependency} function automatically download/points to the specified dependency by just providing its name. It means you have to know what you are looking for. Best practice is to have a look at the \href{https://www.jsdelivr.com/}{jsdelivr} website (\texttt{\{charpente\}} is built on top of jsdelivr) and find the good repository, as shown Figure \ref{fig:workflow-jsdelivr-bulma}. \texttt{create\_dependency} also creates the \texttt{add\_\textless{}DEP\_NAME\textgreater{}\_deps} function in a \texttt{\textless{}DEP\_NAME\textgreater{}-\/-dependencies.R} script and opens it.

\texttt{charpente\_options(local\ =\ FALSE)} allows to fine tune the behavior. If local is FALSE,
\texttt{\{charpente\}} points to the CDN without downloading any file. It is substantially faster than
the local option but requires an internet connection. Package developers will prefer the
\texttt{local\ =\ TRUE} to ensure dependencies are always accessible.
Extra parameters like \textbf{tag} control the downloaded version since HTML templates
may have several flavors. It is always good to be able to test multiple versions and select
the best option.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/workflow/jsdelivr-bulma} 

}

\caption{jsdelivr result for bulma}\label{fig:workflow-jsdelivr-bulma}
\end{figure}

Once satisfied, we simply run the below code to get the latest version, or a specific
version if \textbf{tag} is used:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# CDN method }
\KeywordTok{create_dependency}\NormalTok{(}\StringTok{"bulma"}\NormalTok{, }\DataTypeTok{options =} \KeywordTok{charpente_options}\NormalTok{(}\DataTypeTok{local =} \OtherTok{FALSE}\NormalTok{))}
\KeywordTok{create_dependency}\NormalTok{(}\StringTok{"bulma"}\NormalTok{, }\DataTypeTok{tag =} \StringTok{"0.7.0"}\NormalTok{, }\DataTypeTok{options =} \KeywordTok{charpente_options}\NormalTok{(}\DataTypeTok{local =} \OtherTok{FALSE}\NormalTok{))}

\CommentTok{# local method (default)}
\KeywordTok{create_dependency}\NormalTok{(}\StringTok{"bulma"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Moreover, \texttt{create\_dependency} is able to filter all files, through the \texttt{charpente\_options}:

\begin{itemize}
\tightlist
\item
  \textbf{minified} targets all files with \texttt{.min}, if TRUE.
\item
  \textbf{bundle} targets all files containing \texttt{.bundle}, if TRUE.
\item
  \textbf{lite} targets files with \texttt{lite} keyword, if TRUE.
\item
  \textbf{rtl} target all files with \texttt{.rtl}, if TRUE. rtl design stands for right to left
  and is common in some countries for instance.
\end{itemize}

You may imagine that \texttt{charpente\_options} targets \texttt{.min} files by default. If you don't find
any script, you probably have to change options. For instance, some templates
like Bootstrap and Framework7 have \texttt{bundle.min} files (\texttt{charpente\_options(bunlde\ =\ TRUE)}), whereas bulma doesn't.

We can test our new dependency:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load_all}\NormalTok{()}
\KeywordTok{findDependencies}\NormalTok{(}\KeywordTok{add_bulma_deps}\NormalTok{(}\KeywordTok{div}\NormalTok{()))}
\end{Highlighting}
\end{Shaded}

which works like a charm. If you chose the local option, you also get an \texttt{inst/bulma-\textless{}BULMA-VERSION\textgreater{}} folder
with all relevant files sorted by type. The \texttt{bulma-dependencies.R} script contains the
newly created \texttt{add\_bulma\_deps} function, either pointing to the CDN or the local
files, depending on the chosen strategy:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# local dependency script output}

\CommentTok{#' bulma dependencies utils}
\CommentTok{#'}
\CommentTok{#' @description This function attaches bulma. dependencies to the given tag}
\CommentTok{#'}
\CommentTok{#' @param tag Element to attach the dependencies.}
\CommentTok{#'}
\CommentTok{#' @importFrom htmltools tagList htmlDependency}
\CommentTok{#' @export}
\NormalTok{add_bulma_deps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
\NormalTok{ bulma_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"bulma"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"0.9.1"}\NormalTok{,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{file =} \StringTok{"bulma-0.9.1"}\NormalTok{),}
  \DataTypeTok{stylesheet =} \StringTok{"css/bulma.min.css"}\NormalTok{,}
  \DataTypeTok{package =} \StringTok{"mypkg"}\NormalTok{,}
\NormalTok{ )}
 \KeywordTok{tagList}\NormalTok{(tag, bulma_deps)}
\NormalTok{\}}

\CommentTok{# CDN dependencies}

\CommentTok{#' bulma dependencies utils}
\CommentTok{#'}
\CommentTok{#' @description This function attaches bulma. dependencies to the given tag}
\CommentTok{#'}
\CommentTok{#' @param tag Element to attach the dependencies.}
\CommentTok{#'}
\CommentTok{#' @importFrom htmltools tagList htmlDependency}
\CommentTok{#' @export}
\NormalTok{add_bulma_deps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
\NormalTok{ bulma_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"bulma"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"0.9.1"}\NormalTok{,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://cdn.jsdelivr.net/npm/bulma@0.9.1/"}\NormalTok{),}
  \DataTypeTok{stylesheet =} \StringTok{"css/bulma.min.css"}
\NormalTok{ )}
 \KeywordTok{tagList}\NormalTok{(tag, bulma_deps)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{\{charpente\}} sets the roxygen skeleton so that you don't have to worry about function
imports.

\hypertarget{set-up-the-minimal-page-template}{%
\subsection{Set up the minimal page template}\label{set-up-the-minimal-page-template}}

According to the bulma \href{https://bulma.io/documentation/overview/start/\#starter-template}{documentation}, the starter page template is:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
    \KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"utf-8"}\KeywordTok{>}
    \KeywordTok{<meta}\OtherTok{ name=}\StringTok{"viewport"}\OtherTok{ content=}\StringTok{"width=device-width, initial-scale=1"}\KeywordTok{>}
    \KeywordTok{<title>}\NormalTok{Hello Bulma!}\KeywordTok{</title>}
    \KeywordTok{<link}\OtherTok{ rel=}\StringTok{"stylesheet"}\OtherTok{ href=}\StringTok{"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css"}\KeywordTok{>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<section}\OtherTok{ class=}\StringTok{"section"}\KeywordTok{>}
      \KeywordTok{<div}\OtherTok{ class=}\StringTok{"container"}\KeywordTok{>}
        \KeywordTok{<h1}\OtherTok{ class=}\StringTok{"title"}\KeywordTok{>}
\NormalTok{          Hello World}
        \KeywordTok{</h1>}
        \KeywordTok{<p}\OtherTok{ class=}\StringTok{"subtitle"}\KeywordTok{>}
\NormalTok{          My first website with }\KeywordTok{<strong>}\NormalTok{Bulma}\KeywordTok{</strong>}\NormalTok{!}
        \KeywordTok{</p>}
      \KeywordTok{</div>}
    \KeywordTok{</section>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

Adding some \texttt{\{charpente\}} magic with \texttt{html\_2\_R}, we set the path parameter to \texttt{/html} to get the entire template. We, replace \texttt{...} by the appropriate content (see above). Since the copied HTML contains double quotations marks like \texttt{\textless{}p\ class="subtitle"\textgreater{}\textless{}/p\textgreater{}}, we put the string in single quotation marks.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{html_2_R}\NormalTok{(}
  \StringTok{'<html>}
\StringTok{  <head>}
\StringTok{    <meta charset="utf-8">}
\StringTok{    <meta name="viewport" content="width=device-width, initial-scale=1">}
\StringTok{    <title>Hello Bulma!</title>}
\StringTok{    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css">}
\StringTok{  </head>}
\StringTok{  <body>}
\StringTok{    <section class="section">}
\StringTok{      <div class="container">}
\StringTok{        <h1 class="title">}
\StringTok{          Hello World}
\StringTok{        </h1>}
\StringTok{        <p class="subtitle">}
\StringTok{          My first website with <strong>Bulma</strong>!}
\StringTok{        </p>}
\StringTok{      </div>}
\StringTok{    </section>}
\StringTok{  </body>}
\StringTok{</html>}
\StringTok{  '}\NormalTok{,}
  \DataTypeTok{path =} \StringTok{"/html"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
\end{verbatim}

\begin{verbatim}
## -- Converting code ... --
\end{verbatim}

\begin{verbatim}
## 
\end{verbatim}

\begin{verbatim}
## v Code converted with success.
\end{verbatim}

\begin{verbatim}
## i Copy and paste the following R code
\end{verbatim}

\begin{verbatim}
## --------------------------------------------------------------------------------
\end{verbatim}

\begin{verbatim}
## tags$html(
##   tags$head(
##     tags$meta(charset = "utf-8"),
##     tags$meta(
##       name = "viewport",
##       content = "width=device-width, initial-scale=1"
##     ),
##     tags$title("Hello Bulma!"),
##     tags$link(
##       rel = "stylesheet",
##       href = "https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css"
##     )
##   ),
##   tags$body(tags$section(
##     class = "section",
##     tags$div(
##       class = "container",
##       tags$h1(
##         class = "title",
##         "Hello World"
##       ),
##       tags$p(
##         class = "subtitle",
##         "My first website with",
##         tags$strong("Bulma"),
##         "!"
##       )
##     )
##   ))
## )
\end{verbatim}

\begin{noteblock}
At run time, shiny adds \texttt{html} around the UI, thereby making it not necessary to include.
We also don't need the \texttt{link(rel\ =\ "stylesheet",\ href\ =\ "https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css")}
since \texttt{add\_bulma\_deps} does already attach the dependencies to the page.

\end{noteblock}

The \texttt{prefix} parameter defaults to TRUE, so that we don't have to worry about whether tags functions are exported
by shiny (see Chapter \ref{htmltools-overview}).

The \texttt{bulma\_page} function is defined below, that we save in the \texttt{R} package folder:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bulma_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{tagList}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{charset =} \StringTok{"utf-8"}\NormalTok{),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"viewport"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"width=device-width, initial-scale=1"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{title}\NormalTok{(title)}
\NormalTok{    ),}
    \KeywordTok{add_bulma_deps}\NormalTok{(tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(...)) }
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

With some practice, going from step one to the bulma page templates literally takes three minutes,
while it would have taken more than 30 minutes by hand. At any time, you may replace
the dependency with another version. Be careful, since \texttt{\{charpente\}} does not make snapshots
of old versions.

\hypertarget{exercise-add-bulmajs}{%
\subsection{Exercise: add bulmaJS}\label{exercise-add-bulmajs}}

As stated in the above, bulma only contains CSS things! It means we need
either to develop custom JS code to add interactivity or rely on any third party existing API.
\href{https://bulmajs.tomerbe.co.uk/}{bulma JS} is one of these!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Using \texttt{\{charpente\}}, create a bulma js dependency. We point to \href{https://bulmajs.tomerbe.co.uk/}{vizuaalog/bulmajs} since some bulmajs already exist and are not what we want. Run the following code in the R console.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{create_dependency}\NormalTok{(...)}
\end{Highlighting}
\end{Shaded}

Notice how many files are added to the dependency. Below, we only work with \textbf{notifications}:

\begin{itemize}
\tightlist
\item
  Only keep \texttt{notification.js} and remove all the unnecessary files
\item
  Only keep \texttt{bulma.js} that gather all plugins in 1 script.
\end{itemize}

The best practice is usually to \textbf{keep only what we need} since some scripts may be \textbf{heavy to load}!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Run \texttt{devtools::load\_all()}. Modify the below code to test the newly created dependency. Hint: toggle the HTML inspector to check all appropriate dependencies are there!
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{bulma_page}\NormalTok{()}
\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{add-custom-js}{%
\subsection{Add custom JS}\label{add-custom-js}}

Notifications are always useful to send user feedback. Shiny has a notification system through \texttt{shiny::showNotification}. Like Shiny, Bulma \href{https://bulmajs.tomerbe.co.uk/docs/0.11/2-core-components/notification/}{notifications} are entirely built from JS (no need for any HTML code).

The API works as follows:

\begin{itemize}
\tightlist
\item
  \texttt{Bulma(target).notification(config)} creates the notification based on a JSON option list (config).
  \texttt{target} expects a jQuery selector.
\item
  \texttt{show} toggles the newly instantiated notification
\end{itemize}

In other words the below code attaches the notification to the \texttt{body}:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{Bulma}\NormalTok{(}\StringTok{'body'}\NormalTok{).}\AttributeTok{notification}\NormalTok{(}\OperatorTok{\{}
  \DataTypeTok{body}\OperatorTok{:} \StringTok{'Example notification'}\OperatorTok{,}
  \DataTypeTok{color}\OperatorTok{:} \StringTok{'info'}
\OperatorTok{\}}\NormalTok{).}\AttributeTok{show}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In the following we design the R interface and JavaScript handler (which is no more than an event listener).
\texttt{\{charpente\}} has a function that creates both pieces, namely \texttt{create\_custom\_handler}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{create_custom_handler}\NormalTok{(}\StringTok{"notification"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We obtain the \texttt{notification-handler.R} script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{send_notification_message <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
\NormalTok{ message <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \CommentTok{# your logic}
\NormalTok{ )}
 
\NormalTok{ session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"notification"}\NormalTok{, message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

and the corresponding JavaScript piece in \texttt{notification.js},
derived from the \texttt{\{golem\}} \texttt{add\_js\_handler} function:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'notification'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
 
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

By default, the JS file is created in the \texttt{srcjs} directory. This is a special directory
where we store all JavaScript files that depend on the package author. For instance,
bulmaJS is an external dependency and is very unlikely to be edited by the package author. For that reason,
it remains in the \texttt{inst} folder like all other external dependencies.

\hypertarget{add-custom-inputoutput-bindings}{%
\subsection{Add custom input/output bindings}\label{add-custom-inputoutput-bindings}}

In part \ref{secondary-inputs}, we created better \texttt{\{shinydashboard\}} boxes that one
may programmatically collapse, close and restore. Until know, there was no way to
setup an input binding skeleton and one had to copy and paste each time the same
code. \texttt{\{charpente\}} has a \texttt{create\_input\_binding} and \texttt{create\_output\_binding} (functions that
you can also find in the development version of \texttt{\{golem\}}). Contrary to the custom handler case,
\texttt{create\_input\_binding} only generate the JavaScript piece since the R part is highly variable from
one input to another. To get a plug and play box input binding we call:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{create_input_binding}\NormalTok{(}\StringTok{"boxBinding"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

which gives the \texttt{input-boxBinding.js} script in the \texttt{srcjs} folder:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ boxBinding }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{InputBinding}\NormalTok{()}\OperatorTok{;}
\VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(boxBinding}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
    \CommentTok{// JS logic $(scope).find('whatever')}
  \OperatorTok{\},}
  \DataTypeTok{getValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
    \CommentTok{// JS code to get value}
  \OperatorTok{\},}
  \DataTypeTok{setValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ value) }\OperatorTok{\{}
    \CommentTok{// JS code to set value}
  \OperatorTok{\},}
  \DataTypeTok{receiveMessage}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
    \CommentTok{// this.setValue(el, data);}
  \OperatorTok{\},}
  \DataTypeTok{subscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ callback) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{on}\NormalTok{(}\StringTok{'click.boxBinding'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(e) }\OperatorTok{\{}
      \AttributeTok{callback}\NormalTok{()}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

  \OperatorTok{\},}
  \DataTypeTok{unsubscribe}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(el).}\AttributeTok{off}\NormalTok{(}\StringTok{'.boxBinding'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\VariableTok{Shiny}\NormalTok{.}\VariableTok{inputBindings}\NormalTok{.}\AttributeTok{register}\NormalTok{(boxBinding}\OperatorTok{,} \StringTok{'shiny.whatever'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This function has multiple options:

\begin{itemize}
\tightlist
\item
  \textbf{initialized} is FALSE by default. If TRUE, it adds an \texttt{initialized} method
  to the binding.
\item
  \textbf{dev} adds some \texttt{console.log} elements whenever relevant to help in the debugging
  process.
\item
  \textbf{event} is a list containing events related to the binding. By default, it generates
  a \texttt{click} event without any rate policy. To add extra events we do
  \texttt{list(name\ =\ c("click",\ "whatever"),\ rate\_policy\ =\ c(FALSE,\ TRUE))}.
\end{itemize}

Similarly, the \texttt{create\_output\_binding} function creates a ready to use output binding JS script,
in the \texttt{srcjs} folder (\texttt{create\_output\_binding("menuOutput")}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ menuOutput }\OperatorTok{=} \KeywordTok{new} \VariableTok{Shiny}\NormalTok{.}\AttributeTok{OutputBinding}\NormalTok{()}\OperatorTok{;}
\VariableTok{$}\NormalTok{.}\AttributeTok{extend}\NormalTok{(menuOutput}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{find}\OperatorTok{:} \KeywordTok{function}\NormalTok{(scope) }\OperatorTok{\{}
    \CommentTok{// JS logic $(scope).find('whatever')}
  \OperatorTok{\},}
  \DataTypeTok{renderValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ data) }\OperatorTok{\{}
    \CommentTok{// JS logic}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\VariableTok{Shiny}\NormalTok{.}\VariableTok{outputBindings}\NormalTok{.}\AttributeTok{register}\NormalTok{(menuOutput}\OperatorTok{,} \StringTok{'shiny.whatever'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{organize-your-js}{%
\subsection{Organize your JS code}\label{organize-your-js}}

This naturally leads us to this part which is about JS code organization. Shiny developers
may have a lot of custom JS scripts, and it is generally a bad idea to put them all
under \texttt{inst}. Instead, we store them in \texttt{srcjs}. \texttt{\{charpente\}} has a function providing
a tool to bundle the JS code for production or development, that is \texttt{build\_js()}:

\begin{itemize}
\tightlist
\item
  It compresses, mangles all JS files and concatenate them in one minified file called \texttt{mypkg.min.js}. If \textbf{mode} is \texttt{dev}, the files are not minified.
\item
  In production mode (\textbf{mode} is \texttt{prod}, by default), it additionally generates source maps.
\end{itemize}

\begin{noteblock}
esbuild concatenates file by the order provided in the \texttt{./srcjs/main.js} entry point, automatically generated by \texttt{create\_charpente()}. The configuration is provided by \texttt{\{charpente\}} in the \texttt{package.json} file.

\end{noteblock}

The script \texttt{mypkg.min.js} is not human readable but the generated source map
allows to reconstruct the original code, which location is under the web browser \texttt{srcjs} folder, like all Shiny JS files. From there, we can access any mapped script and start the debugging process like setting break points.

\begin{noteblock}
In production, the variable names, functions, are mangled. For instance, a variable
\texttt{config} could be called \texttt{t} in the minified file, which may lead to confusion.

\end{noteblock}

Additionally, \texttt{build\_js} creates the \texttt{mypkg-dependencies.R} file containing the HTML
dependency pointing to the newly generated JS file (below for production):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#' mypkg dependencies utils}
\CommentTok{#'}
\CommentTok{#' @description This function attaches mypkg dependencies to the given tag}
\CommentTok{#'}
\CommentTok{#' @param tag Element to attach the dependencies.}
\CommentTok{#'}
\CommentTok{#' @importFrom utils packageVersion}
\CommentTok{#' @importFrom htmltools tagList htmlDependency}
\CommentTok{#' @export}
\NormalTok{add_mypkg_deps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
\NormalTok{ mypkg_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"mypkg"}\NormalTok{,}
  \DataTypeTok{version =} \KeywordTok{packageVersion}\NormalTok{(}\StringTok{"mypkg"}\NormalTok{),}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{file =} \StringTok{"mypkg-0.0.0.9000"}\NormalTok{),}
  \DataTypeTok{script =} \StringTok{"js/mypkg.min.js"}\NormalTok{,}
  \DataTypeTok{package =} \StringTok{"mypkg"}\NormalTok{,}
\NormalTok{ )}
 \KeywordTok{tagList}\NormalTok{(tag, mypkg_deps)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Switching between \texttt{prod} and \texttt{dev} automatically updates the \texttt{mypkg-dependencies.R} JS files.

Finally, under the hood, \texttt{create\_js()}, \texttt{create\_input\_binding()}, \texttt{create\_output\_binding()} and \texttt{create\_custom\_handler()} add a reference to the newly created script in the \texttt{main.js} entry point, which may look like:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Gather all files to import here}
\ImportTok{import} \StringTok{'./init.js'}
\ImportTok{import} \StringTok{'./widgets.js'}
\ImportTok{import} \StringTok{'./test.js'}
\end{Highlighting}
\end{Shaded}

\begin{warningbox}
\texttt{export} and \texttt{import} must be called from the top level of a script. For instance,
an \texttt{export} statement cannot be inside the \texttt{\$(\ document\ ).ready(function(...)\});}, as this would trigger a build error.

\end{warningbox}

\texttt{\{charpente\}} currently does not provide similar process for CSS, as this is still work in progress. Other tools exist like \href{https://github.com/JohnCoene/packer}{\texttt{\{packer\}}} by \href{https://john-coene.com/}{John Coene}, which leverages \href{https://webpack.js.org/}{webpack} to handle JS code.

\hypertarget{combine-multiple-dependencies}{%
\subsection{Combine multiple dependencies}\label{combine-multiple-dependencies}}

\texttt{add\_dependencies} allows to select any dependency available in the \texttt{./R} folder,
provided that they follow the convention \texttt{\textless{}depName\textgreater{}\_dependencies.R}
(which is always the case if you use \texttt{\{charpente\}}):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#' Attach all created dependencies in the ./R directory to the provided tag}
\CommentTok{#'}
\CommentTok{#' This function only works if there are existing dependencies. Otherwise,}
\CommentTok{#' an error is raised.}
\CommentTok{#'}
\CommentTok{#' @param tag Tag to attach the dependencies.}
\CommentTok{#' @param deps Dependencies to add. Expect a vector of names. If NULL, all dependencies}
\CommentTok{#' are added.}
\CommentTok{#' @export}
\CommentTok{#'}
\CommentTok{#' @examples}
\CommentTok{#' \textbackslash{}dontrun\{}
\CommentTok{#'  library(htmltools)}
\CommentTok{#'  findDependencies(add_dependencies(div()))}
\CommentTok{#'  findDependencies(add_dependencies(div(), deps = "bulma"))}
\CommentTok{#' \}}
\NormalTok{add_dependencies <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, }\DataTypeTok{deps =} \OtherTok{NULL}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(deps)) \{}
\NormalTok{    temp_names <-}\StringTok{ }\KeywordTok{list.files}\NormalTok{(}\StringTok{"./R"}\NormalTok{, }\DataTypeTok{pattern =} \StringTok{"dependencies.R$"}\NormalTok{)}
\NormalTok{    deps <-}\StringTok{ }\KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(temp_names, strsplit, }\DataTypeTok{split =} \StringTok{"-dependencies.R"}\NormalTok{))}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(deps) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{stop}\NormalTok{(}\StringTok{"No dependencies found."}\NormalTok{)}

\NormalTok{  deps <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(deps, }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    temp <-}\StringTok{ }\KeywordTok{eval}\NormalTok{(}
      \KeywordTok{parse}\NormalTok{(}
        \DataTypeTok{text =} \KeywordTok{sprintf}\NormalTok{(}\StringTok{"htmltools::findDependencies(add_%s_deps(htmltools::div()))"}\NormalTok{, x)}
\NormalTok{      )}
\NormalTok{    )}
    \CommentTok{# this assumes all add_*_deps function only add 1 dependency}
\NormalTok{    temp[[}\DecValTok{1}\NormalTok{]]}
\NormalTok{  \})}

\NormalTok{  htmltools}\OperatorTok{::}\KeywordTok{tagList}\NormalTok{(tag, deps)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For instance \texttt{add\_dependencies(div(),\ deps\ =\ c("bulma",\ "bulmajs"))} adds bulma (first) and
bulmajs dependencies to a \texttt{div} tag. You may change the order as you want since most
of the time, the order matters. We update \texttt{bulma\_page} to benefit from that feature:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bulma_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{tagList}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{charset =} \StringTok{"utf-8"}\NormalTok{),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"viewport"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"width=device-width, initial-scale=1"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{title}\NormalTok{(title)}
\NormalTok{    ),}
    \KeywordTok{add_dependencies}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(...),}
      \DataTypeTok{deps =} \KeywordTok{c}\NormalTok{(}\StringTok{"bulma"}\NormalTok{, }\StringTok{"mypkg"}\NormalTok{)}
\NormalTok{    ) }
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As mentioned above, \texttt{add\_dependencies} belongs to the \texttt{mypkg-utils.R} script
so that you don't have to import charpente in the \texttt{DESCRIPTION} \texttt{Imports} field.

\hypertarget{other-charpente-helpers}{%
\subsection{\texorpdfstring{Other \texttt{\{charpente\}} helpers}{Other \{charpente\} helpers}}\label{other-charpente-helpers}}

Let's finish this section by listing other useful \texttt{\{charpente\}} tools.
We know \texttt{create\_dependency} to install an external dependency.
As shown earlier, this code installs bulma dependencies:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{create_dependency}\NormalTok{(}\StringTok{"bulma"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

However, we don't necessarily know all package versions and may need
\texttt{bulma\ 0.9.1} or \texttt{bulma\ 0.7.0}. \texttt{get\_dependency\_versions} allows to look for
all existing versions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get_dependency_versions}\NormalTok{(}\StringTok{"bulma"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## i Trying with https://data.jsdelivr.com/v1/package/npm/bulma
\end{verbatim}

\begin{verbatim}
## v Success!
\end{verbatim}

\begin{verbatim}
## --------------------------------------------------------------------------------
\end{verbatim}

\begin{verbatim}
##  [1] "0.9.2"  "0.9.1"  "0.9.0"  "0.8.2"  "0.8.1"  "0.8.0"  "0.7.5"  "0.7.4" 
##  [9] "0.7.3"  "0.7.2"  "0.7.1"  "0.7.0"  "0.6.2"  "0.6.1"  "0.6.0"  "0.5.3" 
## [17] "0.5.2"  "0.5.1"  "0.5.0"  "0.4.4"  "0.4.3"  "0.4.2"  "0.4.1"  "0.4.0" 
## [25] "0.3.2"  "0.3.1"  "0.3.0"  "0.2.3"  "0.2.1"  "0.2.0"  "0.1.2"  "0.1.1" 
## [33] "0.1.0"  "0.0.28" "0.0.27" "0.0.26" "0.0.25" "0.0.24" "0.0.23" "0.0.22"
## [41] "0.0.21" "0.0.20" "0.0.19" "0.0.18" "0.0.17" "0.0.16" "0.0.15" "0.0.14"
## [49] "0.0.13" "0.0.12" "0.0.11" "0.0.10" "0.0.9"  "0.0.8"  "0.0.7"  "0.0.6" 
## [57] "0.0.5"  "0.0.4"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get_dependency_versions}\NormalTok{(}\StringTok{"bulma"}\NormalTok{, }\DataTypeTok{latest =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## i Trying with https://data.jsdelivr.com/v1/package/npm/bulma
\end{verbatim}

\begin{verbatim}
## v Success!
\end{verbatim}

\begin{verbatim}
## --------------------------------------------------------------------------------
\end{verbatim}

\begin{verbatim}
## [1] "0.9.2"
\end{verbatim}

Specifying \texttt{latest\ =\ TRUE} ensures to recover the very last \textbf{stable} version
(it excludes alpha/beta versions).

You may explore also the dependency files with \texttt{get\_dependency\_assets}, even for
a specific version with \textbf{tag}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get_dependency_assets}\NormalTok{(}\StringTok{"bulma"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## i Trying with https://data.jsdelivr.com/v1/package/npm/bulma
\end{verbatim}

\begin{verbatim}
## v Success!
\end{verbatim}

\begin{verbatim}
## --------------------------------------------------------------------------------
\end{verbatim}

\begin{verbatim}
## $url
## [1] "https://cdn.jsdelivr.net/npm/bulma@0.9.2/"
## 
## $files
##                name                                         hash
## 1         bulma.css yImvCCH14bBb1CP+8UKH4Kq6Hd77ErtYaM4V+QSvPwc=
## 2     bulma.css.map i9ZST1s/+LQDGevUi1OlRnePnesjoYhW5PJvsUWDqok=
## 3     bulma.min.css O8SsQwDg1R10WnKJNyYgd9J3rlom+YSVcGbEF5RmfFk=
## 4     bulma-rtl.css xFqhlC3rz3OH0JlaGEBeiKIB2at5/ragR+ldLLYZzQU=
## 5 bulma-rtl.css.map Jd1QERJuvEGxAD1EPmyOdUOL7Omn2gaDx6KSgqTaIEI=
## 6 bulma-rtl.min.css OhJCKE0+noWSdE9YUEx+d+3/hdatRbf8nfFQGFCBVhU=
## 
## $hasSubfolders
## [1] TRUE
\end{verbatim}

This is helpful to further fine tune \texttt{charpente\_options}, as stated previously. It is indeed possible
that you don't want bundles, minified, lite or rtl versions of scripts. Internally, \texttt{create\_dependency}
relies on \texttt{get\_dependency\_assets}.

\texttt{get\_installed\_dependency} allows to inspect which dependencies are installed. It only works
if the dependencies were created locally, that is \texttt{charpente\_options(local\ =\ TRUE)}.

Finally, one may ask how to update a given dependency. \texttt{update\_dependency} does this, provided that
the dependency is installed locally. By default, it installs the latest version of the targeted dependency.
It gives a diagnosis comparing the current installed version
with the latest available version. The are 3 possible cases: dependencies are up to date
and \texttt{update\_dependency("bulma")} yields:

\begin{verbatim}
 Trying with https://data.jsdelivr.com/v1/package/npm/bulma
 Success!

Error in update_dependency("bulma") : Versions are identical
\end{verbatim}

The installed dependencies are outdated (we have 0.7.0 with \texttt{create\_dependency("bulma",\ tag\ =\ "0.7.0",\ options\ =\ charpente\_options(local\ =\ TRUE))}), the function shows the targeted version as well as
the last one:

\begin{verbatim}
 Trying with https://data.jsdelivr.com/v1/package/npm/bulma
 Success!

 current version: 0.7.0 ||
target version: 0.9.1 ||
latest version: 0.9.1
! Upgrading bulma to 0.9.1
 Directory inst/bulma-0.9.1/css successfully created
! Remove existing file R/bulma-dependencies.R
\end{verbatim}

The last use case is a downgrade, which may be possible if the package maintainer realizes
that the dependency version is too unstable. In the following, we have \texttt{bulma-0.9.1} installed
and downgrade to 0.7.0 with \texttt{update\_dependency("bulma",\ version\_target\ =\ "0.7.0")}:

\begin{verbatim}
 Trying with https://data.jsdelivr.com/v1/package/npm/bulma
 Success!

 current version: 0.9.1 ||
target version: 0.7.0 ||
latest version: 0.9.1
! Downgrading bulma to 0.7.0
 Directory inst/bulma-0.7.0/css successfully created
! Remove existing file R/bulma-dependencies.R
\end{verbatim}

\hypertarget{other-tips}{%
\section{Other tips}\label{other-tips}}

\hypertarget{validate-javascript}{%
\subsection{Validate JavaScript}\label{validate-javascript}}

We could not finish this chapter without mentioning tools to validate JavaScript code. \href{https://jshint.com}{JSHint}, which comes with \href{https://github.com/dreamRs/jstools}{\{jstools\}}. Below is an example of how to check all the \href{https://github.com/RinteRface/shinyMobile}{shinyMobile} JavaScript input bindings at once:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{shinyMobileJS <-}\StringTok{ }\KeywordTok{system.file}\NormalTok{(}\KeywordTok{sprintf}\NormalTok{(}\StringTok{"shinyMobile-%s/js/shinyMobile.js"}\NormalTok{, }\KeywordTok{packageVersion}\NormalTok{(}\StringTok{"shinyMobile"}\NormalTok{)), }\DataTypeTok{package =} \StringTok{"shinyMobile"}\NormalTok{)}
\KeywordTok{jshint_file}\NormalTok{(}\DataTypeTok{input =}\NormalTok{ shinyMobileJS, }\DataTypeTok{options =} \KeywordTok{jshint_options}\NormalTok{(}\DataTypeTok{jquery =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{globals =} \KeywordTok{list}\NormalTok{(}\StringTok{"Shiny"}\NormalTok{, }\StringTok{"app"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## -- Checking shinyMobile.js ----------------------------------------------------- 
## 51 errors found. 
##  - Line 34: 'template literal syntax' is only available in ES6 (use 'esversion: 6'). 
##  - Line 39: 'template literal syntax' is only available in ES6 (use 'esversion: 6'). 
##  - Line 43: 'template literal syntax' is only available in ES6 (use 'esversion: 6'). 
##  - Line 44: 'template literal syntax' is only available in ES6 (use 'esversion: 6'). 
##  - Line 123: 'const' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). 
##  - Line 124: 'const' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). 
##  - Line 137: 'const' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). 
##  - Line 138: 'const' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). 
##  - Line 139: 'const' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). 
##  - Line 179: 'template literal syntax' is only available in ES6 (use 'esversion: 6'). 
##  - Line 224: 'dialog' is defined but never used. 
##  - Line 228: 'confirm' is defined but never used. 
##  - Line 236: 'prompt' is defined but never used. 
##  - Line 260: The Function constructor is a form of eval. 
##  - Line 385: Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function. 
##  - Line 388: Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function. 
##  - Line 419: 'const' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). 
##  - Line 466: Missing '()' invoking a constructor. 
##  - Line 478: Missing '()' invoking a constructor. 
##  - Line 558: Missing '()' invoking a constructor. 
##  - Line 654: Missing '()' invoking a constructor. 
##  - Line 679: Missing '()' invoking a constructor. 
##  - Line 733: Missing '()' invoking a constructor. 
##  - Line 776: Missing '()' invoking a constructor. 
##  - Line 809: Missing '()' invoking a constructor. 
##  - Line 817: Missing '()' invoking a constructor. 
##  - Line 866: Missing '()' invoking a constructor. 
##  - Line 891: Missing '()' invoking a constructor. 
##  - Line 938: Missing '()' invoking a constructor. 
##  - Line 965: Missing '()' invoking a constructor. 
##  - Line 1026: Missing '()' invoking a constructor. 
##  - Line 1095: Missing '()' invoking a constructor. 
##  - Line 1131: Missing '()' invoking a constructor. 
##  - Line 1217: Missing '()' invoking a constructor. 
##  - Line 1229: 'p' is defined but never used. 
##  - Line 1257: 'let' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). 
##  - Line 1273: Missing '()' invoking a constructor. 
##  - Line 1345: Missing '()' invoking a constructor. 
##  - Line 1375: Missing '()' invoking a constructor. 
##  - Line 1396: 's' is defined but never used. 
##  - Line 1425: Missing '()' invoking a constructor. 
##  - Line 1445: 'r' is defined but never used. 
##  - Line 1516: Missing '()' invoking a constructor. 
##  - Line 1582: Missing '()' invoking a constructor. 
##  - Line 1602: 's' is defined but never used. 
##  - Line 1724: Missing '()' invoking a constructor. 
##  - Line 1762: Missing '()' invoking a constructor. 
##  - Line 1803: Missing '()' invoking a constructor. 
##  - Line 1816: 'for of' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). 
##  - Line 1856: 'template literal syntax' is only available in ES6 (use 'esversion: 6'). 
##  - Line 1856: Too many errors. (96% scanned).
\end{verbatim}

You may fine tune the \texttt{jshint\_file} behavior with the \href{https://jshint.com/docs/options/}{\texttt{jshint\_options}}. One is often tempted to call \texttt{eval} in JS code, which will result in a JSHint error. An option called \texttt{evil} exists to disable the corresponding test. However, we recommend to play the game, accept those error and try to fix them instead of cheating with options! An important remark about validation is that it does not check whether your code
does what it should do. It just focus on checking whether the code runs! To test
the JavaScript behavior, please refer to Chapter \ref{custom-templates-testing-js}.
Be extremely careful: if we consider the example mentioned in section \ref{broken-shiny-app-debug}, the
following code is valid JavaScript:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ sendNotif }\OperatorTok{=}\NormalTok{ (message}\OperatorTok{,}\NormalTok{ type}\OperatorTok{,}\NormalTok{ duration) }\KeywordTok{=>} \OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\VariableTok{notification}\NormalTok{.}\AttributeTok{show}\NormalTok{(}\OperatorTok{\{}
    \DataTypeTok{html}\OperatorTok{:} \VerbatimStringTok{`<strong>}\SpecialCharTok{$\{}\NormalTok{message}\SpecialCharTok{\}}\VerbatimStringTok{</strong>`}\OperatorTok{,}
    \DataTypeTok{type}\OperatorTok{:}\NormalTok{ type}\OperatorTok{,}
    \DataTypeTok{duration}\OperatorTok{:}\NormalTok{ duration}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\};}

\AttributeTok{sendNotif}\NormalTok{(}\StringTok{'Hello'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

and will pass the validation step without any error:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{jshint}\NormalTok{(}
  \StringTok{"const sendNotif = (message, type, duration) => \{}
\StringTok{  Shiny.notification.show(\{}
\StringTok{    html: `<strong>$\{message\}</strong>`,}
\StringTok{    type: type,}
\StringTok{    duration: duration}
\StringTok{  \});}
\StringTok{  \};}
\StringTok{  sendNotif('Hello');}
\StringTok{  "}\NormalTok{,}
  \DataTypeTok{options =} \KeywordTok{jshint_options}\NormalTok{(}
    \DataTypeTok{esversion =} \DecValTok{6}\NormalTok{,}
    \DataTypeTok{jquery =} \OtherTok{TRUE}\NormalTok{, }
    \DataTypeTok{globals =} \KeywordTok{list}\NormalTok{(}\StringTok{"Shiny"}\NormalTok{, }\StringTok{"app"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $functions
##      name                   param line character last lastcharacter
## 1 (empty) message, type, duration    1        27    7             4
##   metrics.complexity metrics.parameters metrics.statements
## 1                  1                  3                  1
## 
## $options
## $options$unstable
## named list()
## 
## $options$undef
## [1] TRUE
## 
## $options$unused
## [1] "vars"
## 
## $options$browser
## [1] TRUE
## 
## $options$jquery
## [1] TRUE
## 
## $options$devel
## [1] FALSE
## 
## $options$esversion
## [1] 6
## 
## $options$globals
## [1] "Shiny" "app"  
## 
## $options$indent
## [1] 4
## 
## $options$maxerr
## [1] 50
## 
## 
## $globals
## [1] "Shiny"
## 
## $member
## $member$notification
## [1] 1
## 
## $member$show
## [1] 1
## 
## $member$html
## [1] 1
## 
## $member$type
## [1] 1
## 
## $member$duration
## [1] 1
## 
## 
## attr(,"class")
## [1] "list"   "jshint"
\end{verbatim}

Yet the code won't work since \texttt{Shiny.notification} does not exist.

\hypertarget{beautify-js-code}{%
\subsection{Beautify JS code}\label{beautify-js-code}}

If you work with the RStudio IDE, your JS code maybe sometimes messy with bad indentation.
\texttt{\{jstools\}} also provides a function and addin to fix the problem. \texttt{prettier\_js(code)} and
\texttt{prettier\_file(input\ =\ "path/to/file.js",\ output\ =\ "path/to/reformated.js")} does this.
I often use the \texttt{Prettier} addin which is way faster than typing the function call (Figure \ref{fig:workflow-pretty-js}).

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/workflow/pretty-js} 

}

\caption{Better JS formatting}\label{fig:workflow-pretty-js}
\end{figure}

\hypertarget{test-js-code}{%
\subsection{Test JS code}\label{test-js-code}}

\texttt{\{charpente\}} provides a starting point to test the JS code with \texttt{test\_js()}, by leveraging the \href{https://mochajs.org/}{mocha} library. All tests are assumed to be contained within the \texttt{srcjs/test} folder. Inside, we find \texttt{test\_basic.js}, which was created upon package initialization, as a boilerplate:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{describe}\NormalTok{(}\StringTok{'Basic test'}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=>} \OperatorTok{\{}
  \AttributeTok{it}\NormalTok{(}\StringTok{'should not fail'}\OperatorTok{,}\NormalTok{ (done) }\KeywordTok{=>} \OperatorTok{\{}
    \AttributeTok{done}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This test starts with a \texttt{describe} function, similar to the \texttt{\{testthat\}} \texttt{context()} function, where you provide the general idea behind the test. \texttt{it} is equivalent to \texttt{test\_that()}, where we describe what specific feature is being tested. Inside, we write a series of instructions, some of them failing, others passing. Naturally, \texttt{mocha} works better with other assertions libraries like \href{https://github.com/Automattic/expect.js}{expect.js} or \href{http://shouldjs.github.io/}{should.js}, whose details are out of the scope of this book.

\hypertarget{workflow-rpg}{%
\chapter{A RPG game with Shiny}\label{workflow-rpg}}

COMING SOON!

\hypertarget{part-case-study-2-mobile-development-with-shiny}{%
\part*{Case study 2: Mobile development with Shiny}\label{part-case-study-2-mobile-development-with-shiny}}


\hypertarget{mobile-shiny-intro}{%
\chapter{Introduction}\label{mobile-shiny-intro}}

\hypertarget{case-study-objectives}{%
\section{Case study objectives}\label{case-study-objectives}}

All previously mentioned templates, except framework7, are dedicated to be used on desktop.
Even though most of them like \texttt{\{bs4Dash\}} work quite well on mobile platforms,
you don't get the native look and feel that you have with mobile apps like twitter,
as shown on Figure \ref{fig:mobile-twitter}.

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/mobile/mobile-twitter} 

}

\caption{Twitter design on mobile devices}\label{fig:mobile-twitter}
\end{figure}

The goal of this part is to introduce you to mobile development for Shiny. We are going to
reconstruct the \texttt{\{shinyMobile\}} package with the help of \texttt{\{charpente\}} and all what we
learnt since the beginning of the book.

\hypertarget{about-mobile-development}{%
\section{About mobile development}\label{about-mobile-development}}

Mobile app development consists in developing an application for mobile devices that is
tablets, phones (Android, ipadOS). We call a native app when it is dedicated for the specified
platform. For instance, iOS applications are developed using Objective-C or swift whereas android apps are mainly developed
with Java. Those apps are faster than web apps since they exploit the full capabilities of the platform. The UI is also
more consistent, they may be installed via a store (App store, google play) and work offline.
The main issue is the need to know multiple languages and maintain multiple code bases.

Isn't there something between pure web apps and native apps?

\hypertarget{progressive-web-apps}{%
\section{Progressive web apps}\label{progressive-web-apps}}

\hypertarget{introduction-4}{%
\subsection{Introduction}\label{introduction-4}}

Progressive web apps or (\href{https://web.dev/what-are-pwas/}{PWA}) improve classic web apps
capabilities by being able to have a full screen display, being installable, provide a launch screen,
like native apps with a consistent UI. They must obey to 3 rules:

\begin{itemize}
\tightlist
\item
  Being capable: media control, file system access, \ldots{}
\item
  Being reliable: fast and usable offline. Transparent failures.
\item
  Being installable: Standalone use, launch from user's home screen.
\end{itemize}

\hypertarget{what-does-installable-mean}{%
\subsection{What does ``installable'' mean?}\label{what-does-installable-mean}}

There are several criteria to meet the installable state:

\begin{itemize}
\tightlist
\item
  The app must be served over HTTPS.
\item
  Include a manifest: JSON file that specify app metadata like the name, short name (\texttt{short\_name}), icons to use
  for user's home screen and launch screen (displayed image before the first paint),
  the start url (\texttt{start\_url}), the display mode (generally standalone),
  the splash screen background color (\texttt{background\_color})\ldots{}
\item
  Have a registered service worker, which can cache the app content, thereby making sure to provide offline
  features.
\end{itemize}

Once all criteria are fulfilled, the web browser shows an installation toast to start the process.

\hypertarget{how-to-develop-a-pwa}{%
\subsection{How to develop a PWA?}\label{how-to-develop-a-pwa}}

Nowadays, there exist tools to develop native looking apps with a common language, JavaScript.
This is the case of \href{https://framework7.io/}{Framework7}. \texttt{\{shinyMobile\}} (Figure \ref{fig:mobile-shinyMobile}) was developed with this
template. Other tools like the Google PWA compatibility \href{https://github.com/GoogleChromeLabs/pwacompat}{script}
significantly reduces the pain to make your app installable on multiple platforms.

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-shinyMobile} \caption{Twitter design on mobile devices}\label{fig:mobile-shinyMobile}
\end{figure}

\hypertarget{mobile-shinyMobile}{%
\chapter{\texorpdfstring{Reconstruct \texttt{\{shinyMobile\}}}{Reconstruct \{shinyMobile\}}}\label{mobile-shinyMobile}}

\begin{importantblock}
This section has been written and tested with Framework7 \texttt{5.7.14}.
Some feature may change in future releases.
However, fear not, the process follows the same general principles.

\end{importantblock}

\begin{warningbox}
As a reminder, the code examples shown throughout this chapter are gathered in the \texttt{\{OSUICode\}} package accessible \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code}{here}.

\end{warningbox}

\hypertarget{introduction-to-framework7}{%
\section{Introduction to Framework7}\label{introduction-to-framework7}}

Framework7 is the HTML/CSS/JavaScript engine that fuels \texttt{\{shinyMobile\}}.
It is a flexible toolkit to build native looking web apps or progressive
web apps (PWA). It has an incredibly rich ecosystem:

\begin{itemize}
\tightlist
\item
  Provides a core JavaScript API, React API, Vue API, Svelte API.
\item
  A CLI to ease the creation of PWA, provide boilerplate and started templates.
\item
  A full set of native \href{https://framework7.io/icons/}{icons}.
\item
  Hundreds of components with different look for iOS and material design, even desktop.
\item
  A comprehensive set of \href{https://framework7.io/docs/}{documentation}.
\item
  A supportive \href{https://forum.framework7.io/}{community}.
\end{itemize}

\hypertarget{initiate-the-package}{%
\section{Initiate the package}\label{initiate-the-package}}

This is time to initialize the package structure and extract the Framework7 dependencies.
To get an idea of the package file structure, we run:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(charpente)}
\KeywordTok{get_dependency_assets}\NormalTok{(}\StringTok{"framework7"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## i Trying with https://data.jsdelivr.com/v1/package/npm/framework7
\end{verbatim}

\begin{verbatim}
## v Success!
\end{verbatim}

\begin{verbatim}
## --------------------------------------------------------------------------------
\end{verbatim}

\begin{verbatim}
## $url
## [1] "https://cdn.jsdelivr.net/npm/framework7@6.0.11/"
## 
## $files
##  [1] "esm"                           "core"                         
##  [3] "components"                    "cjs"                          
##  [5] "bundle"                        "less"                         
##  [7] "lite"                          "lite-bundle"                  
##  [9] "modules"                       "types"                        
## [11] "framework7.css"                "framework7.d.ts"              
## [13] "framework7.js"                 "framework7.js.map"            
## [15] "framework7.less"               "framework7.min.css"           
## [17] "framework7.min.js"             "framework7.min.js.map"        
## [19] "framework7-bundle.css"         "framework7-bundle.js"         
## [21] "framework7-bundle.js.map"      "framework7-bundle.less"       
## [23] "framework7-bundle.min.css"     "framework7-bundle.min.js"     
## [25] "framework7-bundle.min.js.map"  "framework7-bundle-rtl.css"    
## [27] "framework7-bundle-rtl.min.css" "framework7-rtl.css"           
## [29] "framework7-rtl.min.css"        "LICENSE"                      
## [31] "package.json"                  "postinstall.js"               
## [33] "README.md"                    
## 
## $hasSubfolders
## [1] FALSE
\end{verbatim}

We browse to the \href{https://framework7.io/docs/package.html}{package} structure page,
which provides details about necessary components. We are going to use the bundle version since
the lite approach is missing several components, particularly Framework7 widgets. We therefore only need \texttt{framework7.bundle.min.js} and \texttt{framework7.bundle.min.css}, which is the \texttt{create\_dependency} default options:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"shinyMobile"}\NormalTok{)}
\KeywordTok{create_charpente}\NormalTok{(path, }\DataTypeTok{license =} \StringTok{"mit"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Once the package created and opened, we download Framework7 dependencies, specifying
the latest stable version, that is \texttt{5.7.14}, and targeting \texttt{bundle.min} files:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{create_dependency}\NormalTok{(}\StringTok{"framework7"}\NormalTok{, }\DataTypeTok{tag =} \StringTok{"5.7.14"}\NormalTok{, }\DataTypeTok{options =} \KeywordTok{charpente_options}\NormalTok{(}\DataTypeTok{bundle =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Besides, this generates the \texttt{framework7-dependencies.R} script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add_framework7_deps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
\NormalTok{ framework7_deps <-}\StringTok{ }\NormalTok{htmltools}\OperatorTok{::}\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"framework7"}\NormalTok{,}
  \DataTypeTok{version =} \StringTok{"5.7.14"}\NormalTok{,}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{file =} \StringTok{"framework7-5.7.14"}\NormalTok{),}
  \DataTypeTok{script =} \StringTok{"js/framework7.bundle.min.js"}\NormalTok{,}
  \DataTypeTok{stylesheet =} \StringTok{"css/framework7.bundle.min.css"}\NormalTok{,}
  \DataTypeTok{package =} \StringTok{"shinyMobile"}\NormalTok{,}
\NormalTok{ )}
\NormalTok{ htmltools}\OperatorTok{::}\KeywordTok{tagList}\NormalTok{(tag, framework7_deps)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{framework7-layouts}{%
\section{Framework7 Layouts}\label{framework7-layouts}}

Framework7 has three predefined layouts (Figure \ref{fig:mobile-framework7-layouts}):

\begin{itemize}
\tightlist
\item
  \textbf{Single page} layout.
\item
  \textbf{Multi tabs} layout.
\item
  \textbf{Split} layout, targeting tablet/desktop. It is composed of a sidebar and a main panel.
\end{itemize}

\begin{figure}
\includegraphics[width=0.33\linewidth]{images/mobile/mobile-shinymobile-single-layout} \includegraphics[width=0.33\linewidth]{images/mobile/mobile-shinymobile-tabs-layout} \includegraphics[width=0.33\linewidth]{images/mobile/mobile-shinymobile-split-layout} \caption{Framework7 layouts}\label{fig:mobile-framework7-layouts}
\end{figure}

Let's start simple and choose the single page layout, whose corresponding HTML is
given by:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
    \CommentTok{<!-- Required meta tags-->}
    \KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"utf-8"}\KeywordTok{>}
    \KeywordTok{<meta}\OtherTok{ name=}\StringTok{"viewport"}\OtherTok{ content=}\StringTok{"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover"}\KeywordTok{>}
    \KeywordTok{<meta}\OtherTok{ name=}\StringTok{"apple-mobile-web-app-capable"}\OtherTok{ content=}\StringTok{"yes"}\KeywordTok{>}
    \CommentTok{<!-- Color theme for statusbar (Android only) -->}
    \KeywordTok{<meta}\OtherTok{ name=}\StringTok{"theme-color"}\OtherTok{ content=}\StringTok{"#2196f3"}\KeywordTok{>}
    \CommentTok{<!-- Your app title -->}
    \KeywordTok{<title>}\NormalTok{My App}\KeywordTok{</title>}
    \CommentTok{<!-- Path to Framework7 Library Bundle CSS -->}
    \KeywordTok{<link}\OtherTok{ rel=}\StringTok{"stylesheet"}\OtherTok{ href=}\StringTok{"path/to/framework7.bundle.min.css"}\KeywordTok{>}
    \CommentTok{<!-- Path to your custom app styles-->}
    \KeywordTok{<link}\OtherTok{ rel=}\StringTok{"stylesheet"}\OtherTok{ href=}\StringTok{"path/to/my-app.css"}\KeywordTok{>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \CommentTok{<!-- App root element -->}
    \KeywordTok{<div}\OtherTok{ id=}\StringTok{"app"}\KeywordTok{>}

      \CommentTok{<!-- Your main view, should have "view-main" class -->}
      \KeywordTok{<div}\OtherTok{ class=}\StringTok{"view view-main"}\KeywordTok{>}
        \CommentTok{<!-- Initial Page, "data-name" contains page name -->}
        \KeywordTok{<div}\OtherTok{ data-name=}\StringTok{"home"}\OtherTok{ class=}\StringTok{"page"}\KeywordTok{>}

          \CommentTok{<!-- Top Navbar -->}
          \KeywordTok{<div}\OtherTok{ class=}\StringTok{"navbar"}\KeywordTok{>}
            \KeywordTok{<div}\OtherTok{ class=}\StringTok{"navbar-bg"}\KeywordTok{></div>}
            \KeywordTok{<div}\OtherTok{ class=}\StringTok{"navbar-inner"}\KeywordTok{>}
              \KeywordTok{<div}\OtherTok{ class=}\StringTok{"title"}\KeywordTok{>}\NormalTok{Awesome App}\KeywordTok{</div>}
            \KeywordTok{</div>}
          \KeywordTok{</div>}

          \CommentTok{<!-- Bottom Toolbar -->}
          \KeywordTok{<div}\OtherTok{ class=}\StringTok{"toolbar toolbar-bottom"}\KeywordTok{>}
            \KeywordTok{<div}\OtherTok{ class=}\StringTok{"toolbar-inner"}\KeywordTok{>}
              \CommentTok{<!-- Toolbar links -->}
              \KeywordTok{<a}\OtherTok{ href=}\StringTok{"#"}\OtherTok{ class=}\StringTok{"link"}\KeywordTok{>}\NormalTok{Link 1}\KeywordTok{</a>}
              \KeywordTok{<a}\OtherTok{ href=}\StringTok{"#"}\OtherTok{ class=}\StringTok{"link"}\KeywordTok{>}\NormalTok{Link 2}\KeywordTok{</a>}
            \KeywordTok{</div>}
          \KeywordTok{</div>}

          \CommentTok{<!-- Scrollable page content -->}
          \KeywordTok{<div}\OtherTok{ class=}\StringTok{"page-content"}\KeywordTok{>}
            \KeywordTok{<p>}\NormalTok{Page content goes here}\KeywordTok{</p>}
            \CommentTok{<!-- Link to another page -->}
            \KeywordTok{<a}\OtherTok{ href=}\StringTok{"/about/"}\KeywordTok{>}\NormalTok{About app}\KeywordTok{</a>}
          \KeywordTok{</div>}
        \KeywordTok{</div>}
      \KeywordTok{</div>}
    \KeywordTok{</div>}
    \CommentTok{<!-- Path to Framework7 Library Bundle JS-->}
    \KeywordTok{<script}\OtherTok{ type=}\StringTok{"text/javascript"}\OtherTok{ src=}\StringTok{"path/to/framework7.bundle.min.js"}\KeywordTok{></script>}
    \CommentTok{<!-- Path to your app js-->}
    \KeywordTok{<script}\OtherTok{ type=}\StringTok{"text/javascript"}\OtherTok{ src=}\StringTok{"path/to/my-app.js"}\KeywordTok{></script>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

The \texttt{head} tag contains meta tags, some of them required for the PWA features, discussed in the next Chapter \ref{mobile-pwa}.
The most important part is the dependencies that will be included there. Note that
the order matters: Framework7 dependencies go first, other dependencies follow.
The \texttt{body} tag is composed of several layers. The first one is the \texttt{app} root element, which
is crucial to the template initialization. We'll come back on that point in the next section.
Then we find the \texttt{view\ view-main} component, inside which is located the \texttt{page}, containing
the \texttt{navbar}, \texttt{toolbar} (bottom bar) and the \texttt{page\ content}. Altough, Framework7 inserts JavaScript code
at the end of the body, we can include them in the \texttt{head} as well.

Leveraging \texttt{html\_2\_R}, we convert the above code to R and extract the \texttt{f7\_page} function. We replace
the title content by a title parameter, paying attention to remove all CSS and JS links, as they are already included with the \texttt{add\_dependencies} function applied to \texttt{body}. The page content is contained in a \texttt{...} parameter.
We also move the navbar and toolbar content to create 2 other layout functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f7_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., navbar, toolbar, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{tagList}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{charset =} \StringTok{"utf-8"}\NormalTok{),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"viewport"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"apple-mobile-web-app-capable"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"yes"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"theme-color"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"#2196f3"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{title}\NormalTok{(title)}
\NormalTok{    ),}
    \KeywordTok{add_dependencies}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
          \DataTypeTok{id =} \StringTok{"app"}\NormalTok{,}
\NormalTok{          tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
            \DataTypeTok{class =} \StringTok{"view view-main"}\NormalTok{,}
\NormalTok{            tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
              \DataTypeTok{class =} \StringTok{"page"}\NormalTok{,}
\NormalTok{              navbar,}
\NormalTok{              toolbar,}
\NormalTok{              tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
                \DataTypeTok{class =} \StringTok{"page-content"}\NormalTok{,}
\NormalTok{                ...}
\NormalTok{              )}
\NormalTok{            )}
\NormalTok{          )}
\NormalTok{        )}
\NormalTok{      ),}
      \DataTypeTok{deps =} \StringTok{"framework7"}\NormalTok{,}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Below are the \texttt{navbar} and \texttt{toolbar} components. The navbar has only a title parameter and
the toolbar may contain items in a \texttt{...} parameter. In practice they may contain more element,
but this is enough for now:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f7_navbar <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(title) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"navbar"}\NormalTok{,}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}\DataTypeTok{class =} \StringTok{"navbar-bg"}\NormalTok{),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"navbar-inner"}\NormalTok{,}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"title"}\NormalTok{,}
\NormalTok{        title}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{f7_toolbar <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"toolbar toolbar-bottom"}\NormalTok{,}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
      \DataTypeTok{class =} \StringTok{"toolbar-inner"}\NormalTok{,}
\NormalTok{      ...}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{noteblock}
Don't forget to regularly insert roxygen documentation with the insert roxygen skeleton
RStudio feature.

\end{noteblock}

At that point, we can try to run a simple shiny app. Best practice is to save the \texttt{app.R} file in
the \texttt{inst/examples} folder:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load_all}\NormalTok{()}
\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{f7_page}\NormalTok{(}
  \StringTok{"Test"}\NormalTok{,}
  \DataTypeTok{navbar =} \KeywordTok{f7_navbar}\NormalTok{(}\StringTok{"Title"}\NormalTok{),}
  \DataTypeTok{toolbar =} \KeywordTok{f7_toolbar}\NormalTok{(),}
  \DataTypeTok{title =} \StringTok{"shinyMobile"}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

which displays nothing, but returns no error. We actually forgot the app initialization step.

\hypertarget{app-initialization-1}{%
\section{App initialization}\label{app-initialization-1}}

This step is mandatory to activate all template components (router, panels, \ldots).
We create a custom script with \texttt{create\_js}, which automatically updates the \texttt{\{charpente\}} provided \texttt{main.js} entry point:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{create_js}\NormalTok{(}\StringTok{"init"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

and add the following piece of JS inside:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{( document ).}\AttributeTok{ready}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
\NormalTok{  app }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Framework7}\NormalTok{(}\OperatorTok{\{}
    \CommentTok{// App root element}
    \DataTypeTok{root}\OperatorTok{:} \StringTok{'#app'}\OperatorTok{,}
    \CommentTok{// App Name}
    \DataTypeTok{name}\OperatorTok{:} \StringTok{'My App'}\OperatorTok{,}
    \CommentTok{// other options}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Importantly, we made \texttt{app} global so as to access it in other scopes. There is currently
no easy way to workaround this issue.

\begin{warningbox}
Most of the code inside \texttt{init.js} is wrapped in a function that waits the document to be ready before interacting with the DOM. This is necessary since the configuration is retrieved from a \texttt{script} DOM element inserted when the application starts, thus not immediately available. If you try to remove the \texttt{\$(\ document\ ).ready(function(...)\});}, an error will be raised since the configuration cannot be properly retrieved (timing issue).

\end{warningbox}

This script creates the app instance necessary to leverage Framework7 \href{https://framework7.io/docs/app.html\#app-methods-properties}{methods},
initialize other widgets, interact with layout elements and listen to app events (offline, online, \ldots).
Since the root element is a direct child of the body, the \texttt{root} property is not
mandatory. The full configuration list may be found \href{https://framework7.io/docs/app.html}{here}.
The next step consists in initializing the main view, we add this line right after the app creation:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ mainView }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{views}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\StringTok{'.view-main'}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Once done, we compress the corresponding JS file to create the \texttt{shinyMobile.min.js} code
and update the \texttt{f7\_page} to include the new dependency, after the Framework7 one:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{build_js}\NormalTok{()}

\CommentTok{# updated f7_page}
\NormalTok{f7_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., navbar, toolbar, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{tagList}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{charset =} \StringTok{"utf-8"}\NormalTok{),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"viewport"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"apple-mobile-web-app-capable"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"yes"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"theme-color"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"#2196f3"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{title}\NormalTok{(title)}
\NormalTok{    ),}
    \KeywordTok{add_dependencies}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
          \DataTypeTok{id =} \StringTok{"app"}\NormalTok{,}
\NormalTok{          tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
            \DataTypeTok{class =} \StringTok{"view view-main"}\NormalTok{,}
\NormalTok{            tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
              \DataTypeTok{class =} \StringTok{"page"}\NormalTok{,}
\NormalTok{              navbar,}
\NormalTok{              toolbar,}
\NormalTok{              tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
                \DataTypeTok{class =} \StringTok{"page-content"}\NormalTok{,}
\NormalTok{                ...}
\NormalTok{              )}
\NormalTok{            )}
\NormalTok{          )}
\NormalTok{        )}
\NormalTok{      ),}
      \DataTypeTok{deps =} \KeywordTok{c}\NormalTok{(}\StringTok{"framework7"}\NormalTok{, }\StringTok{"shinyMobile"}\NormalTok{),}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load_all}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

The working app is shown on Figure \ref{fig:mobile-shinyMobile-firstapp}.
The right panel displays the developer tools inside which we can seamlessly debug the JS code, by
leveraging source maps.

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-shinyMobile-firstapp} \caption{First working {shinyMobile} app}\label{fig:mobile-shinyMobile-firstapp}
\end{figure}

From now, we can add a welcome notification message with the \href{https://framework7.io/docs/notification.html}{notification} API. There are 2 steps:

\begin{itemize}
\tightlist
\item
  Create the notification instance with \texttt{app.notification.create(parameters)}.
\item
  Tell the app to open the notification at start with \texttt{app.notification.open()}.
\end{itemize}

We add the following code to \texttt{init.js} and call \texttt{build\_js()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ notification }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{notification}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}
  \DataTypeTok{text}\OperatorTok{:} \StringTok{'Welcome to shinyMobile!'}\OperatorTok{,}
  \DataTypeTok{on}\OperatorTok{:} \OperatorTok{\{}
    \DataTypeTok{opened}\OperatorTok{:} \KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
      \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{'Notification opened'}\NormalTok{)}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{).}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

It opens at app start up and closes on swipe gesture. The Framework7 API is quite easy to
understand and extremely powerful. Chapter \ref{mobile-widgets} gives a better introduction to the main
Framework7 widgets.

\hypertarget{app-configuration}{%
\section{App configuration}\label{app-configuration}}

The \href{https://framework7.io/docs/app.html}{app} object has a tremendous amount of methods and parameters.
In this section, we briefly describe the most significant and how to set them up.
Among all parameters, there are metadata parameters like \textbf{name} and \textbf{version}. Once the app initialized, all
app parameters are accessible with the \texttt{.} notation. For instance, if you set a version number, it is accessible later
with \texttt{app.version}.

\hypertarget{global-theme}{%
\subsection{Global theme}\label{global-theme}}

One of the most important parameter is the \textbf{theme} that controls the overall app design (Figure \ref{fig:mobile-framework7-themes}):

\begin{itemize}
\tightlist
\item
  \texttt{ios} corresponds the iOS design.
\item
  \texttt{md} stands for material design.
\item
  \texttt{aurora} is a desktop optimized design.
\end{itemize}

As this parameter is set to \texttt{auto}, Framework7 detects the
current device stored in \texttt{app.device}, and accordingly adapt the design. Nothing prevents you from forcing the
iOS layout on android devices, even though being quite irrelevant. Here are many properties to \href{https://framework7.io/docs/device.html}{review}.

\begin{figure}
\includegraphics[width=0.5\linewidth]{images/mobile/mobile-shinymobile-slider-ios} \includegraphics[width=0.5\linewidth]{images/mobile/mobile-shinymobile-slider-md} \caption{Framework7 skins: iOS (left), md (right).}\label{fig:mobile-framework7-themes}
\end{figure}

\hypertarget{events-1}{%
\subsection{Events}\label{events-1}}

The app is able to emit events whenever relevant like \texttt{init}, \texttt{resize}, \texttt{online}, \texttt{offline}, which
allows to add interactivity:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Framework7}\NormalTok{(}\OperatorTok{\{}
  \DataTypeTok{on}\OperatorTok{:} \OperatorTok{\{}
    \DataTypeTok{init}\OperatorTok{:} \KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
      \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{'App initialized'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\},}
    \CommentTok{// other events}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{components-configuration}{%
\subsection{Components configuration}\label{components-configuration}}

All Framework7 components are highly customizable. Yet, if you know that some
parameters are not going to change, it is a good idea to make them global and share them
across all instances. For example, notifications have global options. Let's add this code
to the \texttt{init.js} script directly inside the \texttt{var\ app\ =\ new\ Framework7(\{\ ...\ \})}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{notification}\OperatorTok{:} \OperatorTok{\{}
  \DataTypeTok{title}\OperatorTok{:} \StringTok{'My App'}\OperatorTok{,}
  \DataTypeTok{closeTimeout}\OperatorTok{:} \DecValTok{3000}\OperatorTok{,}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This means all notifications will close after 3 seconds and have the \texttt{My\ App} title.
We add another notification to the \texttt{init.js} script with a delay of 1 second so as to
test this global feature. Note the use of the internal Framework7 \href{https://framework7.io/docs/utils.html\#nexttick}{utils} \texttt{app.utils.nextTick}, which is nothing more than a \texttt{setTimeout}. At this point, \texttt{init.js} should look like this:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{( document ).}\AttributeTok{ready}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
 \CommentTok{// create app instance}
\NormalTok{ app }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Framework7}\NormalTok{(}\OperatorTok{\{}
    \CommentTok{// App root element}
    \DataTypeTok{root}\OperatorTok{:} \StringTok{'#app'}\OperatorTok{,}
    \CommentTok{// App Name}
    \DataTypeTok{name}\OperatorTok{:} \StringTok{'My App'}\OperatorTok{,}
    \CommentTok{// other options}
    \DataTypeTok{notification}\OperatorTok{:} \OperatorTok{\{}
      \DataTypeTok{title}\OperatorTok{:} \StringTok{'My App'}\OperatorTok{,}
      \DataTypeTok{closeTimeout}\OperatorTok{:} \DecValTok{3000}\OperatorTok{,}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

  \CommentTok{// init main view}
  \KeywordTok{var}\NormalTok{ mainView }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{views}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\StringTok{'.view-main'}\NormalTok{)}\OperatorTok{;}


  \KeywordTok{var}\NormalTok{ notification }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{notification}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}
    \DataTypeTok{text}\OperatorTok{:} \StringTok{'Hello, how are you?'}\OperatorTok{,}
    \DataTypeTok{on}\OperatorTok{:} \OperatorTok{\{}
      \DataTypeTok{opened}\OperatorTok{:} \KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
        \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{'Notification opened'}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{).}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}
  
  
  \KeywordTok{var}\NormalTok{ otherMessage }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{notification}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}
    \DataTypeTok{text}\OperatorTok{:} \StringTok{'You look great!'}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  
  \CommentTok{// equivalent to setTimeout ...}
  \VariableTok{app}\NormalTok{.}\VariableTok{utils}\NormalTok{.}\AttributeTok{nextTick}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \VariableTok{otherMessage}\NormalTok{.}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\},} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}
  
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{other-elements}{%
\subsection{Other elements}\label{other-elements}}

Framework7 provides mobile specific modules like \texttt{touch}, which is a long press event (here 750 ms).
This is something you can usually do on many mobile apps. To activate that feature, we pass
the following configuration to the app parameters list, namely inside \texttt{app\ =\ new\ Framework7(\{...\});}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{touch}\OperatorTok{:} \OperatorTok{\{}
  \DataTypeTok{tapHold}\OperatorTok{:} \KeywordTok{true}\OperatorTok{,}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

We create a button element and add it the \texttt{taphold} event in \texttt{init.js}:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(}\StringTok{'#mybutton'}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'taphold'}\OperatorTok{,} \KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
  \VariableTok{app}\NormalTok{.}\VariableTok{dialog}\NormalTok{.}\AttributeTok{alert}\NormalTok{(}\StringTok{'Tap hold fired!'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{app.R} script should look like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{f7_page}\NormalTok{(}
  \StringTok{"Test"}\NormalTok{,}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"list inset"}\NormalTok{,}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{ul}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{a}\NormalTok{(}
          \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
          \DataTypeTok{id =} \StringTok{"mybutton"}\NormalTok{,}
          \DataTypeTok{class =} \StringTok{"list-button color-red"}\NormalTok{,}
          \StringTok{"Large Red Button"}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{navbar =} \KeywordTok{f7_navbar}\NormalTok{(}\StringTok{"Title"}\NormalTok{),}
  \DataTypeTok{toolbar =} \KeywordTok{f7_toolbar}\NormalTok{(),}
  \DataTypeTok{title =} \StringTok{"shinyMobile"}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{warningbox}
Once the app is running, don't forget to open the developer tools and
set the device on mobile mode (iPhone or android) since \texttt{taphold} does not fire
on desktop (Figure \ref{fig:mobile-shinyMobile-taphold}).

\end{warningbox}

\texttt{taphold} also triggers events related to the click like text selection, which
one may want to disable. If so, we have to add the following code to \texttt{init.js}, making sure
to check that \texttt{touch} exists:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// tapHold custom css}
\ControlFlowTok{if}\NormalTok{ (}\VariableTok{config}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{"touch"}\NormalTok{)) }\OperatorTok{\{}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{app}\NormalTok{.}\VariableTok{params}\NormalTok{.}\AttributeTok{tapHold}\NormalTok{) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\StringTok{"<style>"}\NormalTok{)}
\NormalTok{      .}\AttributeTok{prop}\NormalTok{(}\StringTok{"type"}\OperatorTok{,} \StringTok{"text/css"}\NormalTok{)}
\NormalTok{      .}\AttributeTok{html}\NormalTok{(}
        \VerbatimStringTok{`-moz-user-select: none;}
\VerbatimStringTok{        -webkit-user-select: none;}
\VerbatimStringTok{        user-select: none;`}
\NormalTok{      )}
\NormalTok{      .}\AttributeTok{appendTo}\NormalTok{(}\StringTok{"head"}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

It disables classic text selection after a long press in the window.

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-shinyMobile-taphold} \caption{Long press or taphold event}\label{fig:mobile-shinyMobile-taphold}
\end{figure}

An important remark is the click handling in Framework7. Framework7 has its own internal \href{https://framework7.io/docs/view.html}{router} that allows to pass data between pages and perform quite
advanced actions. Do you remember the \texttt{app.views.create(\textquotesingle{}.view-main\textquotesingle{});} step? This real purpose is actually to
activate the internal router. While extremely convenient for classic web apps,
this feature is not completely suited for Shiny that does not natively support multi pages apps.
The recent \href{https://github.com/ColinFay/brochure}{work} in the field is promising and plays well
with \texttt{\{shinyMobile\}} (see \href{https://github.com/RinteRface/shinyMobile/issues/136}{here}) but this is out of the scope of this chapter. The internal router has strong implications, for instance clicking on
\texttt{\textless{}a\ href="https://www.google.com/"\textgreater{}Click\ me\textless{}/a\textgreater{}} will fail (while it works like
a charm for a classic shiny app), as shown below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylink <-}\StringTok{ }\KeywordTok{a}\NormalTok{(}\DataTypeTok{href =} \StringTok{"https://www.google.com/"}\NormalTok{, }\StringTok{"Click me"}\NormalTok{)}

\CommentTok{# shinyMobile}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{f7_page}\NormalTok{(}
\NormalTok{  mylink,}
  \DataTypeTok{navbar =} \KeywordTok{f7_navbar}\NormalTok{(}\StringTok{"Title"}\NormalTok{),}
  \DataTypeTok{toolbar =} \KeywordTok{f7_toolbar}\NormalTok{(),}
  \DataTypeTok{title =} \StringTok{"shinyMobile"}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}

\CommentTok{# classic shiny}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(mylink)}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

To fix this issue, Framework7 has a \texttt{clicks} module options, accepting any valid CSS selector.
Below is the default configuration:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{clicks}\OperatorTok{:} \OperatorTok{\{}
  \DataTypeTok{externalLinks}\OperatorTok{:} \StringTok{'.external'}\OperatorTok{,}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Consequently, in order to skip the internal router, links must have the \texttt{.external} class.

\begin{importantblock}
One might be tempted to target all \texttt{a} elements: this is a bad idea,
as it also target tabs navigation, which eventually fails! Therefore, it is best
practice to add the \texttt{external} class to all the necessary links like \texttt{a(href\ =\ "https://www.google.com/",\ "Click\ me",\ class\ =\ "external")}

\end{importantblock}

\hypertarget{allow-end-user-configuration}{%
\subsection{Allow end-user configuration}\label{allow-end-user-configuration}}

In the above sections, we described some parameters to configure the app. Yet,
we did setup all values directly in JavaScript. How do we allow the end user to provide
his very own parameters?

The idea is the following:

\begin{itemize}
\tightlist
\item
  We create an options argument in the \texttt{f7\_page} function which accepts a list
  of parameters.
\item
  We convert it to the JSON format and store it in a tag, ideally next to the \texttt{body} element.
\item
  We recover those data on the JS side and update the app initialization method.
\end{itemize}

The \texttt{f7\_page} may be accordingly modified:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f7_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., navbar, toolbar, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{) \{}

\NormalTok{  config_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \DataTypeTok{type =} \StringTok{"application/json"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{data-for}\StringTok{`}\NormalTok{ =}\StringTok{ "app"}\NormalTok{,}
\NormalTok{    jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}
      \DataTypeTok{x =}\NormalTok{ options,}
      \DataTypeTok{auto_unbox =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{json_verbatim =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{  )}

  \CommentTok{# create body_tag}
\NormalTok{  body_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"app"}\NormalTok{,}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"view view-main"}\NormalTok{,}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
          \DataTypeTok{class =} \StringTok{"page"}\NormalTok{,}
\NormalTok{          navbar,}
\NormalTok{          toolbar,}
\NormalTok{          tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
            \DataTypeTok{class =} \StringTok{"page-content"}\NormalTok{,}
\NormalTok{            ...}
\NormalTok{          )}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    ),}
\NormalTok{    config_tag}
\NormalTok{  )}

  \KeywordTok{tagList}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{charset =} \StringTok{"utf-8"}\NormalTok{),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"viewport"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"apple-mobile-web-app-capable"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"yes"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"theme-color"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"#2196f3"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{title}\NormalTok{(title)}
\NormalTok{    ),}
    \KeywordTok{add_dependencies}\NormalTok{(}
\NormalTok{      body_tag,}
      \DataTypeTok{deps =} \KeywordTok{c}\NormalTok{(}\StringTok{"framework7"}\NormalTok{, }\StringTok{"shinyMobile"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The above code still deserves some explanations, even though we exploit a method already defined in section \ref{secondary-inputs}. We convert the options list to a JSON with \texttt{jsonlite::toJSON} and embed it in a script tag.
The \texttt{data-for} attribute with the \textbf{id} attribute guarantees the uniqueness of our configuration script.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{config_tag <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \DataTypeTok{type =} \StringTok{"application/json"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{data-for}\StringTok{`}\NormalTok{ =}\StringTok{ "app"}\NormalTok{,}
\NormalTok{    jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}
      \DataTypeTok{x =}\NormalTok{ options,}
      \DataTypeTok{auto_unbox =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{json_verbatim =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

We then create an intermediate \texttt{body\_tag} component where we insert the configuration tag.
On the JS side, the data collection must occur before the app initialization and is quite easy
with the jQuery \texttt{find} method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ config }\OperatorTok{=} \AttributeTok{$}\NormalTok{(document).}\AttributeTok{find}\NormalTok{(}\StringTok{"script[data-for='app']"}\NormalTok{)}\OperatorTok{;}
\NormalTok{config }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{config}\NormalTok{.}\AttributeTok{html}\NormalTok{())}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We can accordingly update the app initialization:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Framework7}\NormalTok{(}\OperatorTok{\{}
  \CommentTok{// App root element}
  \DataTypeTok{root}\OperatorTok{:} \StringTok{'#app'}\OperatorTok{,}
  \CommentTok{// App Name}
  \DataTypeTok{name}\OperatorTok{:} \StringTok{'My App'}\OperatorTok{,}
  \DataTypeTok{version}\OperatorTok{:} \VariableTok{config}\NormalTok{.}\AttributeTok{version}\OperatorTok{,}
  \CommentTok{// other options}
  \DataTypeTok{theme}\OperatorTok{:} \VariableTok{config}\NormalTok{.}\AttributeTok{theme}\OperatorTok{,}
  \DataTypeTok{notification}\OperatorTok{:} \OperatorTok{\{}
    \DataTypeTok{title}\OperatorTok{:} \StringTok{'My App'}\OperatorTok{,}
    \DataTypeTok{closeTimeout}\OperatorTok{:} \DecValTok{3000}\OperatorTok{,}
  \OperatorTok{\},}
  \DataTypeTok{touch}\OperatorTok{:} \OperatorTok{\{}
    \DataTypeTok{tapHold}\OperatorTok{:} \VariableTok{config}\NormalTok{.}\AttributeTok{taphold}\OperatorTok{,}
  \OperatorTok{\},}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

What happens if the user forgets to supply the version number? \texttt{data.version} is undefined
and the app still works! The biggest advantage of this approach is the fact that all \texttt{TRUE}
and \texttt{FALSE} (R) are converted to \texttt{true} and \texttt{false} (JS), which avoids unnecessary conversion steps.
However, we are still missing many potential configuration options. For instance, with the above code,
only \texttt{root}, \texttt{name}, \texttt{version}, \texttt{theme}, \texttt{notifications}, \texttt{touch} are considered. If the user
provides any other option, it is ignored.

In theory, this is what we could do to make sure that all elements are considered:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Framework7}\NormalTok{(config)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

It is assumed that the user exactly knows what to provide in the list, especially mandatory elements.
Knowing the tremendous number of options, it might be slightly too complex for a new user.
What we suggest is to extract the most important components as direct \texttt{f7\_page} parameters and
keep less important parameters in the options list. For example,
if you think that \textbf{theme} is crucial (and it truly is), you could do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f7_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., navbar, toolbar, }\DataTypeTok{theme =} \KeywordTok{c}\NormalTok{(}\StringTok{"ios"}\NormalTok{, }\StringTok{"md"}\NormalTok{, }\StringTok{"aurora"}\NormalTok{), }
                    \DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{) \{}

\NormalTok{  theme <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(theme)}
\NormalTok{  options}\OperatorTok{$}\NormalTok{theme <-}\StringTok{ }\NormalTok{theme}
  
\NormalTok{  config_tag <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \DataTypeTok{type =} \StringTok{"application/json"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{data-for}\StringTok{`}\NormalTok{ =}\StringTok{ "app"}\NormalTok{,}
\NormalTok{    jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}
      \DataTypeTok{x =}\NormalTok{ options,}
      \DataTypeTok{auto_unbox =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{json_verbatim =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{  )}
  
\CommentTok{# ...}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

which makes the API a bit more accessible (event though more complex to maintain)
and you only need to add one line of documentation in the roxygen part. Alternatively, you could also put all parameters in \textbf{options} and provide a default value for \texttt{f7Page} like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textbackslash{}itemize\{}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{theme\}: App skin: "ios", "md", "auto" or "aurora".}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{dark\}: Dark layout. TRUE or FALSE.}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{filled\}: Whether to fill the \textbackslash{}link\{f7Navbar\} and \textbackslash{}link\{f7Toolbar\} with}
\CommentTok{#'  the current selected color. FALSE by default.}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{color\}: Color theme: See \textbackslash{}url\{http://framework7.io/docs/color-themes.html\}.}
\CommentTok{#'  Expect a name like blue or red. If NULL, use the default color.}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{pullToRefresh\}: Whether to active the pull to refresh feature. Default to FALSE.}
\CommentTok{#'  See \textbackslash{}url\{https://v5.framework7.io/docs/pull-to-refresh.html#examples\}.}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{iosTranslucentBars\}: Enable translucent effect (blur background) on navigation bars for iOS theme (on iOS devices).}
\CommentTok{#'  FALSE by default.}
\CommentTok{#' \}}
\CommentTok{#' Touch module options \textbackslash{}url\{https://v5.framework7.io/docs/app.html#app-parameters\}:}
\CommentTok{#' \textbackslash{}itemize \{}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{tapHold\}:  It triggers (if enabled) after a sustained, complete touch event.}
\CommentTok{#'  By default it is disabled. Note, that Tap Hold is a part of built-in Fast Clicks library,}
\CommentTok{#'  so Fast Clicks should be also enabled.}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{tapHoldDelay\}: Determines how long (in ms) the user must hold their tap before the taphold event is fired on the target element.}
\CommentTok{#'  Default to 750 ms.}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{iosTouchRipple\}: Default to FALSE. Enables touch ripple effect for iOS theme.}
\CommentTok{#' \}}
\CommentTok{#' Navbar options \textbackslash{}url\{https://v5.framework7.io/docs/navbar.html#navbar-app-parameters\}:}
\CommentTok{#' \textbackslash{}itemize \{}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{iosCenterTitle\}: Default to TRUE. When enabled then it will try to position}
\CommentTok{#'  title at the center in iOS theme. Sometime (with some custom design) it may not needed.}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{hideOnPageScroll\}: Default to FALSE. Will hide Navbars on page scroll.}
\CommentTok{#' \}}
\CommentTok{#' Toolbar options \textbackslash{}url\{https://v5.framework7.io/docs/toolbar-tabbar.html#toolbar-app-parameters\}:}
\CommentTok{#' \textbackslash{}itemize \{}
\CommentTok{#'  \textbackslash{}item \textbackslash{}code\{hideOnPageScroll\}: Default to FALSE. Will hide tabs on page scroll.}
\CommentTok{#' \}}
\CommentTok{#'}
\CommentTok{#' In any case, you must follow the same structure as provided in the function arguments.}
\NormalTok{f7Page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}
  \CommentTok{# other parameters are not mentionned}
  \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{theme =} \KeywordTok{c}\NormalTok{(}\StringTok{"ios"}\NormalTok{, }\StringTok{"md"}\NormalTok{, }\StringTok{"auto"}\NormalTok{, }\StringTok{"aurora"}\NormalTok{),}
    \DataTypeTok{dark =} \OtherTok{TRUE}\NormalTok{,}
    \DataTypeTok{filled =} \OtherTok{FALSE}\NormalTok{,}
    \DataTypeTok{color =} \StringTok{"#007aff"}\NormalTok{,}
    \DataTypeTok{touch =} \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{tapHold =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{tapHoldDelay =} \DecValTok{750}\NormalTok{,}
      \DataTypeTok{iosTouchRipple =} \OtherTok{FALSE}
\NormalTok{    ),}
    \DataTypeTok{iosTranslucentBars =} \OtherTok{FALSE}\NormalTok{,}
    \DataTypeTok{navbar =} \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{iosCenterTitle =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{hideNavOnPageScroll =} \OtherTok{TRUE}
\NormalTok{    ),}
    \DataTypeTok{toolbar =} \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{hideNavOnPageScroll =} \OtherTok{FALSE}
\NormalTok{    ),}
    \CommentTok{# whatever option ...}
\NormalTok{  )}
\NormalTok{) \{}
  \CommentTok{# function body ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

and write \texttt{var\ app\ =\ new\ Framework7(config);} on the JS side.

This is a good compromise since it avoids to create too many parameters, without sacrificing the
documentation. Don't forget that since \texttt{config} is an object,
you may add any other properties, methods, on the fly with the \texttt{.} notation or \texttt{app.utils.extend}.

\begin{noteblock}
You finally may ask why we put \texttt{dark}, \texttt{color} and \texttt{filled} in the options list given they
are not part of the app API parameters. As any unknown parameter is not considered
by the \texttt{Framework7} class, we can definitely keep them here, which is easier to treat on the JS side.

\end{noteblock}

\hypertarget{modify-configuration}{%
\subsection{Modify configuration}\label{modify-configuration}}

As previously stated, the app configuration is passed during the initialization process, through
\texttt{new\ Framework7(config)}. What if the user wants to programmatically change these options
when the app is running?

Since app parameters are located in \texttt{app.params}, the idea would be to extend that list:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ newParams }\OperatorTok{=} \OperatorTok{\{}
  \DataTypeTok{dialog}\OperatorTok{:} \OperatorTok{\{}
    \DataTypeTok{buttonOk}\OperatorTok{:}  \StringTok{"Yeaaaah!"}\OperatorTok{,}
    \DataTypeTok{buttonCancel}\OperatorTok{:} \StringTok{"Ouuups!"}
  \OperatorTok{\}}
\OperatorTok{\}}
\VariableTok{app}\NormalTok{.}\VariableTok{utils}\NormalTok{.}\AttributeTok{extend}\NormalTok{(}\VariableTok{app}\NormalTok{.}\AttributeTok{params}\OperatorTok{,}\NormalTok{ newParams)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The above example changes the default buttons text for all modal dialog.

\begin{warningbox}
As far as we know, some options won't work like the \textbf{global theme}, which
would require to re-initialize the app and is obviously not possible.

\end{warningbox}

\hypertarget{mobile-global-data}{%
\subsection{Global data and methods}\label{mobile-global-data}}

The Framework7 \textbf{data} parameters allows to store global elements, data, and use them in different scripts.
To illustrate this feature, we consider the \texttt{tooltip} \href{https://v5.framework7.io/docs/tooltip.html}{example}.
A tooltip is a help text generally displayed on hover (or click) over a specific element.
They are commonly used to improve user experience in all websites.
Framework7 provides two tooltips APIs:

\begin{itemize}
\tightlist
\item
  A purely UI side API where the tooltip is attached to a tag.
\item
  A server side API where the tooltip is dynamically injected in the page content.
\end{itemize}

While the first approach is obviously not interesting for us since it does not involve any
single line of JS, the second approach heavily relies on the \texttt{app.data} object. This is the one
we choose to explain. On the R side, we consider two functions:

\begin{itemize}
\tightlist
\item
  \texttt{addF7Tooltip} that sends a custom message to JS called \texttt{add\_tooltip}. This
  message is composed of the tooltip options (content, \ldots), as well as the selector
  on which to apply the tooltip (\textbf{id} or \textbf{selector} for custom CSS selector).
\item
  \texttt{updateF7Tooltip} that sends a custom message to JS, \texttt{update\_tooltip} to change
  the tooltip state (active/inactive) and its content.
\end{itemize}

Their code is defined below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{validateSelector <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, selector) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(id) }\OperatorTok{&&}\StringTok{ }\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(selector)) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Please choose either target or selector!"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}


\NormalTok{sendCustomMessage <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(type, message, session) \{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}
\NormalTok{    type,}
\NormalTok{    jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}
\NormalTok{      message,}
      \DataTypeTok{auto_unbox =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{json_verbatim =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}

\StringTok{"%OR%"}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(a)) a }\ControlFlowTok{else}\NormalTok{ b}

\NormalTok{addF7Tooltip <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{selector =} \OtherTok{NULL}\NormalTok{, options,}
                         \DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
  \CommentTok{# We use already defined popover functions}
  \KeywordTok{validateSelector}\NormalTok{(id, selector)}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(id)) id <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(id))}
\NormalTok{  options}\OperatorTok{$}\NormalTok{targetEl <-}\StringTok{ }\NormalTok{id }\OperatorTok{%OR%}\StringTok{ }\NormalTok{selector}
  \KeywordTok{sendCustomMessage}\NormalTok{(}\StringTok{"add_tooltip"}\NormalTok{, options, session)}
\NormalTok{\}}


\NormalTok{updateF7Tooltip <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{selector =} \OtherTok{NULL}\NormalTok{,}
                            \DataTypeTok{action =} \KeywordTok{c}\NormalTok{(}\StringTok{"toggle"}\NormalTok{, }\StringTok{"update"}\NormalTok{), }\DataTypeTok{text =} \OtherTok{NULL}\NormalTok{,}
                            \DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}
  \KeywordTok{validateSelector}\NormalTok{(id, selector)}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(id)) id <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"#"}\NormalTok{, session}\OperatorTok{$}\KeywordTok{ns}\NormalTok{(id))}
\NormalTok{  targetEl <-}\StringTok{ }\NormalTok{id }\OperatorTok{%OR%}\StringTok{ }\NormalTok{selector}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{dropNulls}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{targetEl =}\NormalTok{ targetEl, }\DataTypeTok{action =}\NormalTok{ action, }\DataTypeTok{text =}\NormalTok{ text))}
  \KeywordTok{sendCustomMessage}\NormalTok{(}\StringTok{"update_tooltip"}\NormalTok{, message, session)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Framework7 does not provide any native \texttt{enable/disable} method, which means that once the
tooltip is activated on a given element, it is visible forever, unless destroyed.
The main purpose of \texttt{updateF7Tooltip} is to avoid this, by temporarily disabling any tooltip and
reactivating it later.

The JS part to activate the tooltip is \texttt{tooltips.js}:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'add_tooltip'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \VariableTok{app}\NormalTok{.}\VariableTok{tooltip}\NormalTok{.}\AttributeTok{create}\NormalTok{(message).}\AttributeTok{show}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

As mentioned earlier, this is fine since \texttt{message} is a JSON element. We can also chain methods
like \texttt{app.tooltip.create(message).show();}. There is however a problem: \texttt{add\_tooltip} is fired
each time the user triggers a specific element on the R side. It means the tooltip instance is
created each time, which is not optimal. To fix this issue, we create a tooltips cache in the \texttt{app.data}
object and accordingly modify \texttt{init.js}:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{config}\NormalTok{.}\AttributeTok{data} \OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \ControlFlowTok{return} \OperatorTok{\{}
    \DataTypeTok{tooltips}\OperatorTok{:}\NormalTok{ []}
  \OperatorTok{\};}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Importantly, \texttt{app.data} must be a function returning one or multiple elements. We first
return an empty \texttt{tooltips} array and update the \texttt{tooltips.js} file so that we:

\begin{itemize}
\tightlist
\item
  Check if the tooltip instance is already in the cached \texttt{app.data} before creating an instance.
  If is is already there, nothing has to be done.
\item
  Each time we create a new instance, we save it in the \texttt{app.data} cache to retrieve it later.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'add_tooltip'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \CommentTok{// We store all created instances in app data so that we don't}
  \CommentTok{// recreate them later if they exist ...}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{===} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
    \CommentTok{// create instance}
    \KeywordTok{var}\NormalTok{ t }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{tooltip}\NormalTok{.}\AttributeTok{create}\NormalTok{(message)}\OperatorTok{;}
    \CommentTok{// Open tooltip}
    \VariableTok{t}\NormalTok{.}\AttributeTok{show}\NormalTok{()}\OperatorTok{;}
    \CommentTok{// Storage in app data (tooltips array)}
    \VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{=}\NormalTok{ t}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Notice how we store the current instance: \texttt{app.data.tooltips{[}message.targetEl{]}\ =\ t;}.
The reference is given by \texttt{message.targetEl} that is the target to apply the tooltip on.
When multiple tooltips are created, we may search for them by target name, which is
a reasonable choice. For instance \texttt{app.data.tooltips{[}"\#mybutton"{]}} points to the
tooltip associated to the element having \texttt{\#mybutton} as id. So far so good!

How do we enable/disable tooltip then? This is the \texttt{updateF7Tooltip}
R function role. The corresponding JS handler:

\begin{itemize}
\tightlist
\item
  Checks if the specified tooltip instance exists and only update if it is the case.
\item
  Handles two situations: update the tooltip content or toggle the tooltip visibility (
  It is actually more than just showing/hiding the tooltip. Remember that each tooltip is shown
  on hover so applying hide on a visible tooltip will only have effect until the user
  hover again over the same tooltip, which is useless).
\end{itemize}

\texttt{updateF7Tooltip} sends three elements to JS: the tooltip target element \texttt{message.targetEl}, the optional new text, that is \texttt{message.text} and the action to perform \texttt{message.action} (either update or toggle state).
Let's first update the tooltip element. In \texttt{tooltip.js}, we add:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update_tooltip'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \CommentTok{// Don't do anything if the instance is not there in app data}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{!==} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ t }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{]}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{action} \OperatorTok{===} \StringTok{"update"}\NormalTok{) }\OperatorTok{\{}
      \VariableTok{t}\NormalTok{.}\AttributeTok{setText}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{text}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The corresponding tooltip instance is accessed in \texttt{app.data} with \texttt{app.data.tooltips{[}message.targetEl{]}}
and stored in a local variable, \texttt{t}. We apply \texttt{setText} only if the user action corresponds to \texttt{update}.

We handle the \texttt{toggle} case. The first thing to check is whether the current instance is active.
We do it with the \texttt{app.tooltip.get} method targeted on \texttt{message.targetEl}. If the instance is
alive, we get an object, while we obtain undefined if it does not exist. We then call the \texttt{app.tooltip.destroy} method
on the current instance:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update_tooltip'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \CommentTok{// Don't do anything if the instance is not there in app data}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{!==} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ t }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{tooltip}\NormalTok{.}\AttributeTok{get}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{)}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{action} \OperatorTok{===} \StringTok{"update"}\NormalTok{) }\OperatorTok{\{}
      \VariableTok{t}\NormalTok{.}\AttributeTok{setText}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{text}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{action} \OperatorTok{===} \StringTok{"toggle"}\NormalTok{) }\OperatorTok{\{}
      \CommentTok{// destroy}
      \ControlFlowTok{if}\NormalTok{ (t) }\OperatorTok{\{}
        \VariableTok{t}\NormalTok{.}\AttributeTok{destroy}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Wait a moment! There are 2 issues with this code. The first is that \texttt{t} is a variable pointing
to the current instance. If we destroy that instance, \texttt{t} will point to a destoyed element the next time it is called, and any action like \texttt{setText} will raise an error. The trick is to create a deep clone with \texttt{Object.assign} that won't be affected by the \texttt{destroy} method, save the deep clone in the \texttt{app.data} cache and destroy the old instance. Therefore we update the \texttt{tooltips.js} script:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update_tooltip'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{!==} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
    \CommentTok{// Try to get the instance}
    \KeywordTok{var}\NormalTok{ t }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{tooltip}\NormalTok{.}\AttributeTok{get}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{)}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{action} \OperatorTok{===} \StringTok{"update"}\NormalTok{) }\OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ (t) }\OperatorTok{\{}
        \VariableTok{t}\NormalTok{.}\AttributeTok{setText}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{text}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{action} \OperatorTok{===} \StringTok{"toggle"}\NormalTok{) }\OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ (t) }\OperatorTok{\{}
        \CommentTok{// create copy that won't be modified if t is destroyed!}
        \KeywordTok{var}\NormalTok{ cachedTooltip }\OperatorTok{=} \VariableTok{Object}\NormalTok{.}\AttributeTok{assign}\NormalTok{(}\OperatorTok{\{\},}\NormalTok{ t)}\OperatorTok{;}
        \CommentTok{// save copy to replace the deleted one in the app data}
        \VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{=}\NormalTok{ cachedTooltip}\OperatorTok{;}
        \CommentTok{// destroy current instance}
        \VariableTok{t}\NormalTok{.}\AttributeTok{destroy}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\}} 
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We also check whether the instance is alive before updating it. We are still missing the \texttt{re-activation} step that consists in rebuilding the tooltip instance based on the cached data \texttt{app.data.tooltips{[}message.targetEl{]}} previously saved. All parameters are contained in the \texttt{params} object (instance element):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Capture parameters}
\KeywordTok{var}\NormalTok{ pars }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{].}\AttributeTok{params}\OperatorTok{;}
\CommentTok{// Recreate the tooltip based on the copy configuration}
\NormalTok{t }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{tooltip}\NormalTok{.}\AttributeTok{create}\NormalTok{(pars)}\OperatorTok{;}
\CommentTok{// Replace the app data instance}
\VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{=}\NormalTok{ t}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The final JS code is:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update_tooltip'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{!==} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
    \CommentTok{// Try to get the instance}
    \KeywordTok{var}\NormalTok{ t }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{tooltip}\NormalTok{.}\AttributeTok{get}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{)}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{action} \OperatorTok{===} \StringTok{"update"}\NormalTok{) }\OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ (t) }\OperatorTok{\{}
        \VariableTok{t}\NormalTok{.}\AttributeTok{setText}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{text}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{action} \OperatorTok{===} \StringTok{"toggle"}\NormalTok{) }\OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ (t) }\OperatorTok{\{}
        \CommentTok{// create copy that won't be modified if t is destroyed!}
        \KeywordTok{var}\NormalTok{ cachedTooltip }\OperatorTok{=} \VariableTok{Object}\NormalTok{.}\AttributeTok{assign}\NormalTok{(}\OperatorTok{\{\},}\NormalTok{ t)}\OperatorTok{;}
        \CommentTok{// save copy to replace the deleted one in the app data}
        \VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{=}\NormalTok{ cachedTooltip}\OperatorTok{;}
        \CommentTok{// destroy current instance}
        \VariableTok{t}\NormalTok{.}\AttributeTok{destroy}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
        \CommentTok{// Parameters}
        \KeywordTok{var}\NormalTok{ pars }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{].}\AttributeTok{params}\OperatorTok{;}
        \CommentTok{// recreate the tooltip based on the copy configuration}
\NormalTok{        t }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{tooltip}\NormalTok{.}\AttributeTok{create}\NormalTok{(pars)}\OperatorTok{;}
        \VariableTok{app}\NormalTok{.}\VariableTok{data}\NormalTok{.}\AttributeTok{tooltips}\NormalTok{[}\VariableTok{message}\NormalTok{.}\AttributeTok{targetEl}\NormalTok{] }\OperatorTok{=}\NormalTok{ t}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Similarly \textbf{methods} hosts all global app methods. These are functions you may re-use in different parts. Like for \texttt{app.data}, we access them with \texttt{app.methods}.

\begin{importantblock}
\texttt{app.data} has been removed since Framework7 6.0.0!

\end{importantblock}

\hypertarget{theming-and-colors}{%
\section{Theming and colors}\label{theming-and-colors}}

Framework7 offers 15 color \href{https://framework7.io/docs/color-themes.html?theme=light\&bars=empty\&color=\%09+\%23673ab7}{themes} with a dark/light global appearance. To apply them, we add \texttt{color-theme-COLOR} to the
parent element. Best practice is to target the \texttt{body} since it is the parent of all the page
content, thereby ensuring global consistency. The dark theme is triggered by adding the
\texttt{theme-dark} class to \texttt{html}. Since \texttt{body} belongs to \texttt{f7\_page} but not \texttt{html} (added by
Shiny at startup), we can apply the color in R, while the dark mode has to be activated
from JS:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f7_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., navbar, toolbar, }\DataTypeTok{theme =} \KeywordTok{c}\NormalTok{(}\StringTok{"ios"}\NormalTok{, }\StringTok{"md"}\NormalTok{, }\StringTok{"aurora"}\NormalTok{), }
                    \DataTypeTok{color =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{) \{}
  
\NormalTok{  body_cl <-}\StringTok{ }\OtherTok{NULL}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(color)) body_cl <-}\StringTok{ }\KeywordTok{sprintf}\NormalTok{(}\StringTok{"color-theme-color"}\NormalTok{)}
  
  \CommentTok{# Modify the body tag to add a class}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(}
    \DataTypeTok{class =}\NormalTok{ body_cl,}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"app"}\NormalTok{,}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"view view-main"}\NormalTok{,}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
          \DataTypeTok{class =} \StringTok{"page"}\NormalTok{,}
\NormalTok{          navbar,}
\NormalTok{          toolbar,}
\NormalTok{          tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
            \DataTypeTok{class =} \StringTok{"page-content"}\NormalTok{,}
\NormalTok{            ...}
\NormalTok{          )}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    ),}
\NormalTok{    config_tag}
\NormalTok{  )}
  
  \CommentTok{# ...}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This approach assumes the user to pass the color name as parameter like \texttt{pink}, \texttt{yellow}.
What if we want to allow more flexibility and add any existing HEX color?
Framework7 has tools, namely \texttt{app.utils.colorThemeCSSProperties}, that is a JS method
creating the required CSS on the fly depending on the provided HEX color. For instance, if we select a
cyberpunk green color:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{app}\NormalTok{.}\VariableTok{utils}\NormalTok{.}\AttributeTok{colorThemeCSSProperties}\NormalTok{(}\StringTok{'#42f5a1'}\NormalTok{)}\OperatorTok{;}
\CommentTok{// /* Custom color theme */}
\CommentTok{// \{}
\CommentTok{//   "--f7-theme-color": "#42f5a1";}
\CommentTok{//   "--f7-theme-color-rgb": "66, 245, 161";}
\CommentTok{//   "--f7-theme-color-shade": "#1bf38e";}
\CommentTok{//   "--f7-theme-color-tint": "#69f7b4";}
\CommentTok{// \}}
\end{Highlighting}
\end{Shaded}

The commented code has to be injected in the app CSS. I personally don't think its a problem
to look for a specific HEX code, knowing that many tools can help. Therefore, I prefer the
second approach. We edit the \texttt{init.js} code by adding the following JS snippet:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\VariableTok{config}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{'color'}\NormalTok{)) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ colorCSS }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{utils}\NormalTok{.}\AttributeTok{colorThemeCSSProperties}\NormalTok{(}\VariableTok{config}\NormalTok{.}\AttributeTok{color}\NormalTok{)}\OperatorTok{;}
  \AttributeTok{$}\NormalTok{(}\StringTok{'<style>'}\NormalTok{)}
\NormalTok{    .}\AttributeTok{prop}\NormalTok{(}\StringTok{'type'}\OperatorTok{,} \StringTok{'text/css'}\NormalTok{)}
\NormalTok{    .}\AttributeTok{html}\NormalTok{(}\VerbatimStringTok{`:root \{}
\VerbatimStringTok{      --f7-theme-color: }\SpecialCharTok{$\{}\NormalTok{colorCSS[}\StringTok{"--f7-theme-color"}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{;}
\VerbatimStringTok{      --f7-theme-color-rgb: }\SpecialCharTok{$\{}\NormalTok{colorCSS[}\StringTok{"--f7-theme-color-rgb"}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{;}
\VerbatimStringTok{      --f7-theme-color-shade: }\SpecialCharTok{$\{}\NormalTok{colorCSS[}\StringTok{"--f7-theme-color-shade"}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{;}
\VerbatimStringTok{      --f7-theme-color-tint: }\SpecialCharTok{$\{}\NormalTok{colorCSS[}\StringTok{"--f7-theme-color-tint"}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{;}
\VerbatimStringTok{    \}`}\NormalTok{)}
\NormalTok{    .}\AttributeTok{appendTo}\NormalTok{(}\StringTok{"head"}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{config.hasOwnProperty(\textquotesingle{}color\textquotesingle{})} ensures that this code does not run if color is missing from the
provided config. Then, we generate an object containing the theme color properties with \texttt{app.utils.colorThemeCSSProperties(config.color)}.
Importantly, as this is an object, we can't insert it in a string. However, we can extract its
properties 1 by 1 to generate the relevant piece of CSS. Then we add a \texttt{style} tag to the \texttt{head}
containing the following CSS rule:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* Custom color theme */}
\InformationTok{:root}\NormalTok{ \{}
\NormalTok{  --f7-theme-color: }\ConstantTok{#42f5a1}\OperatorTok{;}
\NormalTok{  --f7-theme-color-rgb: }\DecValTok{66}\OperatorTok{,} \DecValTok{245}\OperatorTok{,} \DecValTok{161}\OperatorTok{;}
\NormalTok{  --f7-theme-color-shade: }\ConstantTok{#1bf38e}\OperatorTok{;}
\NormalTok{  --f7-theme-color-tint: }\ConstantTok{#69f7b4}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For each property like \texttt{-\/-f7-theme-color}, we recover the corresponding value in the
\texttt{colorCSS} object, that is \texttt{colorCSS{[}"-\/-f7-theme-color"{]}}. Once done, recompile the JS
with \texttt{build\_js} and try with the following app:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load_all}\NormalTok{()}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{f7_page}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"list inset"}\NormalTok{,}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{ul}\NormalTok{(}
\NormalTok{            tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
\NormalTok{                tags}\OperatorTok{$}\KeywordTok{a}\NormalTok{(}
                    \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
                    \DataTypeTok{id =} \StringTok{"mybutton"}\NormalTok{,}
                    \DataTypeTok{class =} \StringTok{"list-button"}\NormalTok{,}
                    \StringTok{"Large Green Button"}
\NormalTok{                )}
\NormalTok{            )}
\NormalTok{        )}
\NormalTok{    ),}
    \DataTypeTok{navbar =} \KeywordTok{f7_navbar}\NormalTok{(}\StringTok{"Title"}\NormalTok{),}
    \DataTypeTok{toolbar =} \KeywordTok{f7_toolbar}\NormalTok{(),}
    \DataTypeTok{title =} \StringTok{"shinyMobile"}\NormalTok{,}
    \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{theme =} \StringTok{"ios"}\NormalTok{, }\DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{, }\DataTypeTok{taphold =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{color =} \StringTok{"#42f5a1"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

We can go further and apply the \texttt{filled} theme, which is an alternative design where all
\texttt{navbar}, \texttt{toolbar}, \ldots{} are filled with the theme color. In that case, we add the following CSS:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* Invert navigation bars to fill style */}
\InformationTok{:root}\OperatorTok{,}
\InformationTok{:root}\FunctionTok{.theme-dark}\OperatorTok{,}
\InformationTok{:root} \FunctionTok{.theme-dark}\NormalTok{ \{}
\NormalTok{  --f7-bars-bg-color: }\FunctionTok{var(}\VariableTok{--f7-theme-color}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  --f7-bars-bg-color-rgb: }\FunctionTok{var(}\VariableTok{--f7-theme-color-rgb}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  --f7-bars-translucent-opacity: }\DecValTok{0.9}\OperatorTok{;}
\NormalTok{  --f7-bars-text-color: }\ConstantTok{#fff}\OperatorTok{;}
\NormalTok{  --f7-bars-link-color: }\ConstantTok{#fff}\OperatorTok{;}
\NormalTok{  --f7-navbar-subtitle-text-color: }\FunctionTok{rgba(}\DecValTok{255}\OperatorTok{,}\DecValTok{255}\OperatorTok{,}\DecValTok{255}\OperatorTok{,}\DecValTok{0.85}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  --f7-bars-border-color: }\DecValTok{transparent}\OperatorTok{;}
\NormalTok{  --f7-tabbar-link-active-color: }\ConstantTok{#fff}\OperatorTok{;}
\NormalTok{  --f7-tabbar-link-inactive-color: }\FunctionTok{rgba(}\DecValTok{255}\OperatorTok{,}\DecValTok{255}\OperatorTok{,}\DecValTok{255}\OperatorTok{,}\DecValTok{0.54}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  --f7-sheet-border-color: }\DecValTok{transparent}\OperatorTok{;}
\NormalTok{  --f7-tabbar-link-active-border-color: }\ConstantTok{#fff}\OperatorTok{;}
\NormalTok{\}}
\FunctionTok{.appbar}\OperatorTok{,}
\FunctionTok{.navbar}\OperatorTok{,}
\FunctionTok{.toolbar}\OperatorTok{,}
\FunctionTok{.subnavbar}\OperatorTok{,}
\FunctionTok{.calendar-header}\OperatorTok{,}
\FunctionTok{.calendar-footer}\NormalTok{ \{}
\NormalTok{  --f7-touch-ripple-color: }\FunctionTok{var(}\VariableTok{--f7-touch-ripple-white}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  --f7-link-highlight-color: }\FunctionTok{var(}\VariableTok{--f7-link-highlight-white}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  --f7-button-text-color: }\ConstantTok{#fff}\OperatorTok{;}
\NormalTok{  --f7-button-pressed-bg-color: }\FunctionTok{rgba(}\DecValTok{255}\OperatorTok{,}\DecValTok{255}\OperatorTok{,}\DecValTok{255}\OperatorTok{,}\DecValTok{0.1}\FunctionTok{)}\OperatorTok{;}
\NormalTok{\}}
\FunctionTok{.navbar-large-transparent}\OperatorTok{,}
\FunctionTok{.navbar-large.navbar-transparent}\NormalTok{ \{}
\NormalTok{  --f7-navbar-large-title-text-color: }\ConstantTok{#000}\OperatorTok{;}

  \VariableTok{--r}\NormalTok{: }\DecValTok{0}\OperatorTok{;}
  \VariableTok{--g}\NormalTok{: }\DecValTok{122}\OperatorTok{;}
  \VariableTok{--b}\NormalTok{: }\DecValTok{255}\OperatorTok{;}
  \VariableTok{--progress}\NormalTok{: }\FunctionTok{var(}\VariableTok{--f7-navbar-large-collapse-progress}\FunctionTok{)}\OperatorTok{;}
\NormalTok{  --f7-bars-link-color: }\FunctionTok{rgb(}
\NormalTok{    calc(var(--r}\FunctionTok{)}\NormalTok{ + (}\DecValTok{255}\NormalTok{ - }\FunctionTok{var(}\VariableTok{--r}\FunctionTok{)}\NormalTok{) * }\FunctionTok{var(}\VariableTok{--progress}\FunctionTok{)}\NormalTok{)}\OperatorTok{,}
    \FunctionTok{calc(var(}\VariableTok{--g}\FunctionTok{)} \OperatorTok{+}\NormalTok{ (}\DecValTok{255} \OperatorTok{-} \FunctionTok{var(}\VariableTok{--g}\FunctionTok{)}\NormalTok{) }\OperatorTok{*} \FunctionTok{var(}\VariableTok{--progress}\FunctionTok{))}\OperatorTok{,}
    \FunctionTok{calc(var(}\VariableTok{--b}\FunctionTok{)} \OperatorTok{+}\NormalTok{ (}\DecValTok{255} \OperatorTok{-} \FunctionTok{var(}\VariableTok{--b}\FunctionTok{)}\NormalTok{) }\OperatorTok{*} \FunctionTok{var(}\VariableTok{--progress}\FunctionTok{))}
\NormalTok{  )}\OperatorTok{;}
\NormalTok{\}}
\FunctionTok{.theme-dark} \FunctionTok{.navbar-large-transparent}\OperatorTok{,}
\FunctionTok{.theme-dark} \FunctionTok{.navbar-large.navbar-transparent}\NormalTok{ \{}
\NormalTok{  --f7-navbar-large-title-text-color: }\ConstantTok{#fff}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Like above, we do this on the JS side in \texttt{init.js}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\VariableTok{config}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{'filled'}\NormalTok{)) }\VariableTok{config}\NormalTok{.}\AttributeTok{filled} \OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
\ControlFlowTok{if}\NormalTok{ (}\VariableTok{config}\NormalTok{.}\AttributeTok{filled}\NormalTok{) }\OperatorTok{\{}
  \KeywordTok{var}\NormalTok{ filledCSS }\OperatorTok{=} \VerbatimStringTok{`}
\VerbatimStringTok{    :root,}
\VerbatimStringTok{    :root.theme-dark,}
\VerbatimStringTok{    :root .theme-dark \{}
\VerbatimStringTok{      --f7-bars-bg-color: var(--f7-theme-color);}
\VerbatimStringTok{      --f7-bars-bg-color-rgb: var(--f7-theme-color-rgb);}
\VerbatimStringTok{      --f7-bars-translucent-opacity: 0.9;}
\VerbatimStringTok{      --f7-bars-text-color: #fff;}
\VerbatimStringTok{      --f7-bars-link-color: #fff;}
\VerbatimStringTok{      --f7-navbar-subtitle-text-color: rgba(255,255,255,0.85);}
\VerbatimStringTok{      --f7-bars-border-color: transparent;}
\VerbatimStringTok{      --f7-tabbar-link-active-color: #fff;}
\VerbatimStringTok{      --f7-tabbar-link-inactive-color: rgba(255,255,255,0.54);}
\VerbatimStringTok{      --f7-sheet-border-color: transparent;}
\VerbatimStringTok{      --f7-tabbar-link-active-border-color: #fff;}
\VerbatimStringTok{    \}}
\VerbatimStringTok{    .appbar,}
\VerbatimStringTok{    .navbar,}
\VerbatimStringTok{    .toolbar,}
\VerbatimStringTok{    .subnavbar,}
\VerbatimStringTok{    .calendar-header,}
\VerbatimStringTok{    .calendar-footer \{}
\VerbatimStringTok{      --f7-touch-ripple-color: var(--f7-touch-ripple-white);}
\VerbatimStringTok{      --f7-link-highlight-color: var(--f7-link-highlight-white);}
\VerbatimStringTok{      --f7-button-text-color: #fff;}
\VerbatimStringTok{      --f7-button-pressed-bg-color: rgba(255,255,255,0.1);}
\VerbatimStringTok{    \}}
\VerbatimStringTok{    .navbar-large-transparent,}
\VerbatimStringTok{    .navbar-large.navbar-transparent \{}
\VerbatimStringTok{      --f7-navbar-large-title-text-color: #000;}
\VerbatimStringTok{    }
\VerbatimStringTok{      --r: 0;}
\VerbatimStringTok{      --g: 122;}
\VerbatimStringTok{      --b: 255;}
\VerbatimStringTok{      --progress: var(--f7-navbar-large-collapse-progress);}
\VerbatimStringTok{      --f7-bars-link-color: rgb(}
\VerbatimStringTok{        calc(var(--r) + (255 - var(--r)) * var(--progress)),}
\VerbatimStringTok{        calc(var(--g) + (255 - var(--g)) * var(--progress)),}
\VerbatimStringTok{        calc(var(--b) + (255 - var(--b)) * var(--progress))}
\VerbatimStringTok{      );}
\VerbatimStringTok{    \}}
\VerbatimStringTok{    .theme-dark .navbar-large-transparent,}
\VerbatimStringTok{    .theme-dark .navbar-large.navbar-transparent \{}
\VerbatimStringTok{      --f7-navbar-large-title-text-color: #fff;}
\VerbatimStringTok{  \}`}\OperatorTok{;}
  
  \AttributeTok{$}\NormalTok{(}\StringTok{'<style>'}\NormalTok{)}
\NormalTok{    .}\AttributeTok{prop}\NormalTok{(}\StringTok{'type'}\OperatorTok{,} \StringTok{'text/css'}\NormalTok{)}
\NormalTok{    .}\AttributeTok{html}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{filledCSS}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}
\NormalTok{    .}\AttributeTok{appendTo}\NormalTok{(}\StringTok{"head"}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The result is displayed on Figure \ref{fig:mobile-shinyMobile-theming}. Don't forget
to pass the \texttt{filled} property to the config list.

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-shinyMobile-theming} \caption{Filled green color theme}\label{fig:mobile-shinyMobile-theming}
\end{figure}

Let's finish this section with the dark mode. We leverage the Framework7 app method
element since we could also toggle the dark mode under other circumstances. We add a
\texttt{toggleDarkTheme} function to the methods object then trigger it depending on the value
of the config. If the user don't provide any value, we set \texttt{config.dark} to \texttt{false}:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{config}\NormalTok{.}\AttributeTok{methods} \OperatorTok{=} \OperatorTok{\{}
  \DataTypeTok{toggleDarkTheme}\OperatorTok{:} \KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ self }\OperatorTok{=} \KeywordTok{this}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ $html }\OperatorTok{=} \VariableTok{self}\NormalTok{.}\AttributeTok{$}\NormalTok{(}\StringTok{'html'}\NormalTok{)}\OperatorTok{;}
    \VariableTok{$html}\NormalTok{.}\AttributeTok{toggleClass}\NormalTok{(}\StringTok{'theme-dark'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}

\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\VariableTok{config}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{'dark'}\NormalTok{)) }\VariableTok{config}\NormalTok{.}\AttributeTok{dark} \OperatorTok{=} \KeywordTok{false}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\VariableTok{config}\NormalTok{.}\AttributeTok{dark}\NormalTok{) }\OperatorTok{\{}
  \VariableTok{app}\NormalTok{.}\VariableTok{methods}\NormalTok{.}\AttributeTok{toggleDarkTheme}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

At this point \texttt{init.js} should be:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{( document ).}\AttributeTok{ready}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// collect all data elements stored in body}
  \KeywordTok{var}\NormalTok{ config }\OperatorTok{=} \AttributeTok{$}\NormalTok{(document).}\AttributeTok{find}\NormalTok{(}\StringTok{"script[data-for='app']"}\NormalTok{)}\OperatorTok{;}
\NormalTok{  config }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{config}\NormalTok{.}\AttributeTok{html}\NormalTok{())}\OperatorTok{;}

  \CommentTok{// always erase existing root value just in case the user changes the root.}
  \CommentTok{// This may be harmful}
  \VariableTok{config}\NormalTok{.}\AttributeTok{root} \OperatorTok{=} \StringTok{"#app"}\OperatorTok{;}
  
  \CommentTok{// store app methods}
  \VariableTok{config}\NormalTok{.}\AttributeTok{methods} \OperatorTok{=}  \OperatorTok{\{}
      \DataTypeTok{toggleDarkTheme}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
        \KeywordTok{var}\NormalTok{ self }\OperatorTok{=} \KeywordTok{this}\OperatorTok{;}
        \KeywordTok{var}\NormalTok{ $html }\OperatorTok{=} \VariableTok{self}\NormalTok{.}\AttributeTok{$}\NormalTok{(}\StringTok{"html"}\NormalTok{)}\OperatorTok{;}
        \VariableTok{$html}\NormalTok{.}\AttributeTok{toggleClass}\NormalTok{(}\StringTok{"theme-dark"}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\};}

  \CommentTok{// create app instance}
\NormalTok{  app }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Framework7}\NormalTok{(config)}\OperatorTok{;}

  \CommentTok{// init main view}
  \KeywordTok{var}\NormalTok{ mainView }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{views}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\StringTok{'.view-main'}\NormalTok{)}\OperatorTok{;}
  
  \CommentTok{// tapHold custom css}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{config}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{"touch"}\NormalTok{)) }\OperatorTok{\{}
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{config}\NormalTok{.}\VariableTok{touch}\NormalTok{.}\AttributeTok{tapHold}\NormalTok{) }\OperatorTok{\{}
      \AttributeTok{$}\NormalTok{(}\StringTok{"<style>"}\NormalTok{)}
\NormalTok{        .}\AttributeTok{prop}\NormalTok{(}\StringTok{"type"}\OperatorTok{,} \StringTok{"text/css"}\NormalTok{)}
\NormalTok{        .}\AttributeTok{html}\NormalTok{(}
          \VerbatimStringTok{`}
\VerbatimStringTok{          -moz-user-select: none;}
\VerbatimStringTok{          -webkit-user-select: none;}
\VerbatimStringTok{          user-select: none;`}
\NormalTok{        )}
\NormalTok{        .}\AttributeTok{appendTo}\NormalTok{(}\StringTok{"head"}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}

  \KeywordTok{var}\NormalTok{ notification }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{notification}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}
    \DataTypeTok{text}\OperatorTok{:} \StringTok{'Hello, how are you?'}\OperatorTok{,}
    \DataTypeTok{on}\OperatorTok{:} \OperatorTok{\{}
      \DataTypeTok{opened}\OperatorTok{:} \KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
        \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{'Notification opened'}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{).}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}

  \KeywordTok{var}\NormalTok{ otherMessage }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{notification}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}
    \DataTypeTok{text}\OperatorTok{:} \StringTok{'You look great!'}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

  \CommentTok{// equivalent to setTimeout ...}
  \VariableTok{app}\NormalTok{.}\VariableTok{utils}\NormalTok{.}\AttributeTok{nextTick}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \VariableTok{otherMessage}\NormalTok{.}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\},} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}

  \CommentTok{// taphold test}
  \AttributeTok{$}\NormalTok{(}\StringTok{'#mybutton'}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'taphold'}\OperatorTok{,} \KeywordTok{function}\NormalTok{ () }\OperatorTok{\{}
    \VariableTok{app}\NormalTok{.}\VariableTok{dialog}\NormalTok{.}\AttributeTok{alert}\NormalTok{(}\StringTok{'Tap hold fired!'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

  \CommentTok{// Set color theme}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{config}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{'color'}\NormalTok{)) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ colorCSS }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{utils}\NormalTok{.}\AttributeTok{colorThemeCSSProperties}\NormalTok{(}\VariableTok{config}\NormalTok{.}\AttributeTok{color}\NormalTok{)}\OperatorTok{;}
    \AttributeTok{$}\NormalTok{(}\StringTok{'<style>'}\NormalTok{)}
\NormalTok{      .}\AttributeTok{prop}\NormalTok{(}\StringTok{'type'}\OperatorTok{,} \StringTok{'text/css'}\NormalTok{)}
\NormalTok{      .}\AttributeTok{html}\NormalTok{(}\VerbatimStringTok{`:root \{}
\VerbatimStringTok{        --f7-theme-color: }\SpecialCharTok{$\{}\NormalTok{colorCSS[}\StringTok{"--f7-theme-color"}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{;}
\VerbatimStringTok{        --f7-theme-color-rgb: }\SpecialCharTok{$\{}\NormalTok{colorCSS[}\StringTok{"--f7-theme-color-rgb"}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{;}
\VerbatimStringTok{        --f7-theme-color-shade: }\SpecialCharTok{$\{}\NormalTok{colorCSS[}\StringTok{"--f7-theme-color-shade"}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{;}
\VerbatimStringTok{        --f7-theme-color-tint: }\SpecialCharTok{$\{}\NormalTok{colorCSS[}\StringTok{"--f7-theme-color-tint"}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{;}
\VerbatimStringTok{      \}`}\NormalTok{)}
\NormalTok{      .}\AttributeTok{appendTo}\NormalTok{(}\StringTok{"head"}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}

  \CommentTok{// Filled theme}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\VariableTok{config}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{'filled'}\NormalTok{)) }\VariableTok{config}\NormalTok{.}\AttributeTok{filled} \OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{config}\NormalTok{.}\AttributeTok{filled}\NormalTok{) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ filledCSS }\OperatorTok{=} \VerbatimStringTok{`}
\VerbatimStringTok{      :root,}
\VerbatimStringTok{      :root.theme-dark,}
\VerbatimStringTok{      :root .theme-dark \{}
\VerbatimStringTok{        --f7-bars-bg-color: var(--f7-theme-color);}
\VerbatimStringTok{        --f7-bars-bg-color-rgb: var(--f7-theme-color-rgb);}
\VerbatimStringTok{        --f7-bars-translucent-opacity: 0.9;}
\VerbatimStringTok{        --f7-bars-text-color: #fff;}
\VerbatimStringTok{        --f7-bars-link-color: #fff;}
\VerbatimStringTok{        --f7-navbar-subtitle-text-color: rgba(255,255,255,0.85);}
\VerbatimStringTok{        --f7-bars-border-color: transparent;}
\VerbatimStringTok{        --f7-tabbar-link-active-color: #fff;}
\VerbatimStringTok{        --f7-tabbar-link-inactive-color: rgba(255,255,255,0.54);}
\VerbatimStringTok{        --f7-sheet-border-color: transparent;}
\VerbatimStringTok{        --f7-tabbar-link-active-border-color: #fff;}
\VerbatimStringTok{      \}}
\VerbatimStringTok{      .appbar,}
\VerbatimStringTok{      .navbar,}
\VerbatimStringTok{      .toolbar,}
\VerbatimStringTok{      .subnavbar,}
\VerbatimStringTok{      .calendar-header,}
\VerbatimStringTok{      .calendar-footer \{}
\VerbatimStringTok{        --f7-touch-ripple-color: var(--f7-touch-ripple-white);}
\VerbatimStringTok{        --f7-link-highlight-color: var(--f7-link-highlight-white);}
\VerbatimStringTok{        --f7-button-text-color: #fff;}
\VerbatimStringTok{        --f7-button-pressed-bg-color: rgba(255,255,255,0.1);}
\VerbatimStringTok{      \}}
\VerbatimStringTok{      .navbar-large-transparent,}
\VerbatimStringTok{      .navbar-large.navbar-transparent \{}
\VerbatimStringTok{        --f7-navbar-large-title-text-color: #000;}
\VerbatimStringTok{      }
\VerbatimStringTok{        --r: 0;}
\VerbatimStringTok{        --g: 122;}
\VerbatimStringTok{        --b: 255;}
\VerbatimStringTok{        --progress: var(--f7-navbar-large-collapse-progress);}
\VerbatimStringTok{        --f7-bars-link-color: rgb(}
\VerbatimStringTok{          calc(var(--r) + (255 - var(--r)) * var(--progress)),}
\VerbatimStringTok{          calc(var(--g) + (255 - var(--g)) * var(--progress)),}
\VerbatimStringTok{          calc(var(--b) + (255 - var(--b)) * var(--progress))}
\VerbatimStringTok{        );}
\VerbatimStringTok{      \}}
\VerbatimStringTok{      .theme-dark .navbar-large-transparent,}
\VerbatimStringTok{      .theme-dark .navbar-large.navbar-transparent \{}
\VerbatimStringTok{        --f7-navbar-large-title-text-color: #fff;}
\VerbatimStringTok{    \}`}\OperatorTok{;}
    
    \AttributeTok{$}\NormalTok{(}\StringTok{'<style>'}\NormalTok{)}
\NormalTok{      .}\AttributeTok{prop}\NormalTok{(}\StringTok{'type'}\OperatorTok{,} \StringTok{'text/css'}\NormalTok{)}
\NormalTok{      .}\AttributeTok{html}\NormalTok{(}\VerbatimStringTok{`}\SpecialCharTok{$\{}\NormalTok{filledCSS}\SpecialCharTok{\}}\VerbatimStringTok{`}\NormalTok{)}
\NormalTok{      .}\AttributeTok{appendTo}\NormalTok{(}\StringTok{"head"}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}

  \CommentTok{// dark mode}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\VariableTok{config}\NormalTok{.}\AttributeTok{hasOwnProperty}\NormalTok{(}\StringTok{'dark'}\NormalTok{)) }\VariableTok{config}\NormalTok{.}\AttributeTok{dark} \OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{config}\NormalTok{.}\AttributeTok{dark}\NormalTok{) }\OperatorTok{\{}
    \VariableTok{app}\NormalTok{.}\VariableTok{methods}\NormalTok{.}\AttributeTok{toggleDarkTheme}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

and the dark mode app example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{f7_page}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"list inset"}\NormalTok{,}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{ul}\NormalTok{(}
\NormalTok{            tags}\OperatorTok{$}\KeywordTok{li}\NormalTok{(}
\NormalTok{                tags}\OperatorTok{$}\KeywordTok{a}\NormalTok{(}
                    \DataTypeTok{href =} \StringTok{"#"}\NormalTok{,}
                    \DataTypeTok{id =} \StringTok{"mybutton"}\NormalTok{,}
                    \DataTypeTok{class =} \StringTok{"list-button"}\NormalTok{,}
                    \StringTok{"Large Green Button"}
\NormalTok{                )}
\NormalTok{            )}
\NormalTok{        )}
\NormalTok{    ),}
    \DataTypeTok{navbar =} \KeywordTok{f7_navbar}\NormalTok{(}\StringTok{"Title"}\NormalTok{),}
    \DataTypeTok{toolbar =} \KeywordTok{f7_toolbar}\NormalTok{(),}
    \DataTypeTok{title =} \StringTok{"shinyMobile"}\NormalTok{,}
    \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{theme =} \StringTok{"ios"}\NormalTok{, }
      \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{, }
      \DataTypeTok{taphold =} \OtherTok{TRUE}\NormalTok{, }
      \DataTypeTok{color =} \StringTok{"#42f5a1"}\NormalTok{, }
      \DataTypeTok{filled =} \OtherTok{TRUE}\NormalTok{, }
      \DataTypeTok{dark =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The overall expected result is shown Figure \ref{fig:mobile-shinyMobile-dark}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-shinymobile-dark} \caption{Dark mode in {shinyMobile}}\label{fig:mobile-shinyMobile-dark}
\end{figure}

You may run in the R console:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyAppDir}\NormalTok{(}\KeywordTok{system.file}\NormalTok{(}\StringTok{"shinyMobile/simple"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{modularize-js-code}{%
\section{Modularize JS code}\label{modularize-js-code}}

As shown above, the \texttt{init.js} code starts to grow and this is not a good sign.
In this section, we show how to utilize the \texttt{import} and \texttt{export} statements, possible
owing to the \texttt{esbuild} JS bundler. Note that this is a more modern version of writing equivalent to the \texttt{module.exports} and \texttt{require} shown in \ref{about-js-modules}.

In the R console, we run \texttt{create\_js("helpers\_config",\ reference\ =\ FALSE)}, which creates a new JS script but does not import it in the \texttt{main.js} \texttt{esbuild} entry point. Inside we extract a function containing all steps to set up the app configuration object:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{export} \KeywordTok{const}\NormalTok{ setConfig }\OperatorTok{=}\NormalTok{ () }\KeywordTok{=>} \OperatorTok{\{}
  \CommentTok{// collect all data elements stored in body}
 \KeywordTok{let}\NormalTok{ config }\OperatorTok{=} \AttributeTok{$}\NormalTok{(document).}\AttributeTok{find}\NormalTok{(}\StringTok{"script[data-for='app']"}\NormalTok{)}\OperatorTok{;}
\NormalTok{ config }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{config}\NormalTok{.}\AttributeTok{html}\NormalTok{())}\OperatorTok{;}

 \CommentTok{// always erase existing root value just in case the user changes the root.}
 \CommentTok{// This may be harmful}
 \VariableTok{config}\NormalTok{.}\AttributeTok{root} \OperatorTok{=} \StringTok{"#app"}\OperatorTok{;}

  \CommentTok{// store app methods}
  \VariableTok{config}\NormalTok{.}\AttributeTok{methods} \OperatorTok{=}  \OperatorTok{\{}
    \DataTypeTok{toggleDarkTheme}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
      \KeywordTok{let}\NormalTok{ self }\OperatorTok{=} \KeywordTok{this}\OperatorTok{;}
      \KeywordTok{let}\NormalTok{ $html }\OperatorTok{=} \VariableTok{self}\NormalTok{.}\AttributeTok{$}\NormalTok{(}\StringTok{"html"}\NormalTok{)}\OperatorTok{;}
      \VariableTok{$html}\NormalTok{.}\AttributeTok{toggleClass}\NormalTok{(}\StringTok{"theme-dark"}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\};}

  \CommentTok{// check if the app is intended to be a PWA}
  \KeywordTok{let}\NormalTok{ isPWA }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'body'}\NormalTok{).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-pwa'}\NormalTok{) }\OperatorTok{===} \StringTok{"true"}\OperatorTok{;}

  \ControlFlowTok{if}\NormalTok{ (isPWA) }\OperatorTok{\{}
    \VariableTok{config}\NormalTok{.}\AttributeTok{serviceWorker} \OperatorTok{=} \OperatorTok{\{}
      \DataTypeTok{path}\OperatorTok{:} \VariableTok{window}\NormalTok{.}\VariableTok{location}\NormalTok{.}\AttributeTok{pathname} \OperatorTok{+} \StringTok{"service-worker.js"}\OperatorTok{,}
      \DataTypeTok{scope}\OperatorTok{:} \VariableTok{window}\NormalTok{.}\VariableTok{location}\NormalTok{.}\AttributeTok{pathname}
    \OperatorTok{\};}
  \OperatorTok{\}}

  \CommentTok{// Widgets cache}
  \VariableTok{config}\NormalTok{.}\AttributeTok{data} \OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{\{}
      \CommentTok{// any other widget type to cache ...}
      \DataTypeTok{gauge}\OperatorTok{:}\NormalTok{ []}
    \OperatorTok{\};}
  \OperatorTok{\};}

  \ControlFlowTok{return}\NormalTok{ config}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This function does not have any argument and must return the \texttt{config} variable that will be subsequently injected in \texttt{new\ Framework7(config)} to initialize the app. In the \texttt{init.js} script, we import the \texttt{setConfig()} function and call it within \texttt{\$(\ document\ ).ready}:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \OperatorTok{\{}\NormalTok{ setConfig }\OperatorTok{\}} \ImportTok{from} \StringTok{'./helpers_config.js'}

\AttributeTok{$}\NormalTok{( document ).}\AttributeTok{ready}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ config }\OperatorTok{=} \AttributeTok{setConfig}\NormalTok{()}\OperatorTok{;}
  \CommentTok{// create app instance}
\NormalTok{  app }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Framework7}\NormalTok{(config)}\OperatorTok{;}
  \CommentTok{// ...}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We can bundle our code with \texttt{build\_js()}. We invite the reader to modularize the other features mentioned above, the final product being available \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code/tree/master/srcjs}{here}. Alternatively, you may run in the R console and open the HTML inspector to check the JS code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyAppDir}\NormalTok{(}\KeywordTok{system.file}\NormalTok{(}\StringTok{"shinyMobile/pwa"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{warningbox}
If the function has a side effect, for instance modify a variable located in another scope, it must return the transformed variable output, so that it can be tracked at the upper level.

\end{warningbox}

We have now set all foundations. In the next chapter, we see how to convert a \texttt{\{shinyMobile\}} app (and any vanilla shiny app) into a progressive web app.

\hypertarget{mobile-pwa}{%
\chapter{\texorpdfstring{\texttt{\{shinyMobile\}} and PWA}{\{shinyMobile\} and PWA}}\label{mobile-pwa}}

Transforming a classic Shiny app into a PWA is a game changer for end users.
The first step is to setup a valid web manifest with icons and favicon.

\begin{importantblock}
Some of the PWA features won't work with \href{https://medium.com/@firt/progressive-web-apps-on-ios-are-here-d00430dee3a7}{iOS}, like the
install prompt.

\end{importantblock}

\begin{warningbox}
As a reminder, the code examples shown throughout this chapter are gathered in the \texttt{\{OSUICode\}} package accessible \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code}{here}, specifically PWA apps are available \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code/tree/master/inst/shinyMobile/pwa}{here}.

\end{warningbox}

\hypertarget{introduction-5}{%
\section{Introduction}\label{introduction-5}}

Below, we review one by one the necessary steps to convert a shiny app to a PWA.
To get a good idea of what our mission exactly is, we leverage the \texttt{Application} tab of the
developer tools.

The overall expected result is shown Figure \ref{fig:mobile-pwa-1}. Alternatively, one
may use the Google Lighthouse utility to provide a general diagnosis to the app, as illustrated on Figure \ref{fig:mobile-pwa-2}. There are many categories like performance, accessibility. In our case, let's just select
the PWA category, select the mobile device radio and click on generate a report.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-application} 

}

\caption{Application tab of the developers tools}\label{fig:mobile-pwa-1}
\end{figure}

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-lighthouse} 

}

\caption{Google Lightouse utility}\label{fig:mobile-pwa-2}
\end{figure}

According to the diagnostic result displayed on Figure \ref{fig:mobile-pwa-lighthouse-result}, we don't meet all requirements, most importantly there is:

\begin{itemize}
\tightlist
\item
  No manifest.
\item
  No service worker.
\item
  No icons.
\end{itemize}

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-lighthouse-result} \caption{Lighthouse audit result}\label{fig:mobile-pwa-lighthouse-result}
\end{figure}

\hypertarget{charpente-and-pwa-tools}{%
\section{\texorpdfstring{\texttt{\{charpente\}} and PWA tools}{\{charpente\} and PWA tools}}\label{charpente-and-pwa-tools}}

\texttt{\{charpente\}} has tools to help designing a PWA, particularly the \texttt{set\_pwa} function, that does all the previously mentioned step in only one line of code. There are however few prerequisites:

\begin{itemize}
\tightlist
\item
  The app must \textbf{belong to a package}.
\item
  The function must target the app directory.
\end{itemize}

As a reminder, the demonstration apps are located within the \texttt{inst/examples} folder.
We create the \texttt{pwa-app} sub-folder and the \texttt{app.R} file:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{library}\NormalTok{(shinyMobile)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{f7_page}\NormalTok{(}
  \StringTok{"Test"}\NormalTok{,}
  \DataTypeTok{navbar =} \KeywordTok{f7_navbar}\NormalTok{(}\StringTok{"Title"}\NormalTok{),}
  \DataTypeTok{toolbar =} \KeywordTok{f7_toolbar}\NormalTok{(),}
  \DataTypeTok{title =} \StringTok{"shinyMobile"}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{\}}
\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Then we set the PWA configuration:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set_pwa}\NormalTok{(}\StringTok{"inst/examples/pwa-app"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This function generates a \texttt{manifest.webmanifest} file, downloads the Google PWA compatibility
script, adds a custom dependency pointing to the \texttt{manifest.webmanifest} file and a \texttt{144x144} icon file,
copies a boilerplate \texttt{service-worker.js} with its \texttt{offline.html} page and optionally registers the
service worker (whose code is borrowed from \href{https://web.dev/offline-fallback-page/\#registering-the-service-worker}{web.dev}:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{window}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{'load'}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=>} \OperatorTok{\{}
  \ControlFlowTok{if}\NormalTok{ (}\StringTok{'serviceWorker'} \KeywordTok{in}\NormalTok{ navigator) }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ pathname }\OperatorTok{=} \VariableTok{window}\NormalTok{.}\VariableTok{location}\NormalTok{.}\AttributeTok{pathname}\OperatorTok{;}
    \VariableTok{navigator}\NormalTok{.}\AttributeTok{serviceWorker}
\NormalTok{      .}\AttributeTok{register}\NormalTok{(pathname }\OperatorTok{+} \StringTok{'service-worker.js'}\OperatorTok{,} \OperatorTok{\{} \DataTypeTok{scope}\OperatorTok{:}\NormalTok{ pathname}\OperatorTok{\}}\NormalTok{)}
\NormalTok{      .}\AttributeTok{then}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{} \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{'Service Worker Registered'}\NormalTok{)}\OperatorTok{;} \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\};}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In the \texttt{\{shinyMobile\}} case, as Framework7 already registers any provided service
worker, we don't need that initialization script. Therefore, we actually call:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set_pwa}\NormalTok{(}\StringTok{"inst/examples/pwa-app"}\NormalTok{, }\DataTypeTok{register_service_worker =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Importantly, this functions does not handle icon creation. There are tools such as
\href{https://appsco.pe/developer/splash-screens}{appsco} and
\href{https://app-manifest.firebaseapp.com}{app-manifest}, to create
those custom icons and splash screens, if you need to.

In the following, we provide more detail about the mentioned steps.

\hypertarget{create-the-manifest}{%
\subsection{Create the manifest}\label{create-the-manifest}}

We would like to create a JSON configuration file like this:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
  \StringTok{"short_name"}\OperatorTok{:} \StringTok{"My App"}\OperatorTok{,}
  \StringTok{"name"}\OperatorTok{:} \StringTok{"Super amazing app"}\OperatorTok{,}
  \StringTok{"description"}\OperatorTok{:} \StringTok{"This app is just mind blowing"}\OperatorTok{,}
  \StringTok{"icons"}\OperatorTok{:}\NormalTok{ [}
    \OperatorTok{\{}
      \StringTok{"src"}\OperatorTok{:} \StringTok{"icons/icon.png"}\OperatorTok{,}
      \StringTok{"type"}\OperatorTok{:} \StringTok{"image/png"}\OperatorTok{,}
      \StringTok{"sizes"}\OperatorTok{:} \StringTok{"192x192"}
    \OperatorTok{\}}
    \CommentTok{// ...}
\NormalTok{  ]}\OperatorTok{,}
  \StringTok{"start_url"}\OperatorTok{:} \StringTok{"https://whatever-url.com/"}\OperatorTok{,}
  \StringTok{"background_color"}\OperatorTok{:} \StringTok{"#3367D6"}\OperatorTok{,}
  \StringTok{"display"}\OperatorTok{:} \StringTok{"standalone"}\OperatorTok{,}
  \StringTok{"scope"}\OperatorTok{:} \StringTok{"/"}\OperatorTok{,}
  \StringTok{"theme_color"}\OperatorTok{:} \StringTok{"#3367D6"}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This file has to be accessible by the app, hence best practice is to put it in the \texttt{/www} folder,
images being hosted in the \texttt{/www/icons} sub-directory.

The \texttt{create\_manifest} function writes a JSON file at the provided location:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{create_manifest <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(path, }\DataTypeTok{name =} \StringTok{"My Progressive Web App"}\NormalTok{, }\DataTypeTok{shortName =} \StringTok{"My App"}\NormalTok{,}
                            \DataTypeTok{description =} \StringTok{"What it does!"}\NormalTok{, }\DataTypeTok{lang =} \StringTok{"en-US"}\NormalTok{,}
                            \DataTypeTok{startUrl =} \StringTok{"/"}\NormalTok{, }\DataTypeTok{display =} \KeywordTok{c}\NormalTok{(}\StringTok{"minimal-ui"}\NormalTok{, }\StringTok{"standalone"}\NormalTok{, }\StringTok{"fullscreen"}\NormalTok{, }\StringTok{"browser"}\NormalTok{),}
                            \DataTypeTok{background_color =} \StringTok{"#ffffff"}\NormalTok{, }\DataTypeTok{theme_color =} \StringTok{"#ffffff"}\NormalTok{) \{}

\NormalTok{  display <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(display)}

\NormalTok{  manifest <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
    \DataTypeTok{name =}\NormalTok{ name,}
    \DataTypeTok{short_name =}\NormalTok{ shortName,}
    \DataTypeTok{description =}\NormalTok{ description,}
    \DataTypeTok{lang =}\NormalTok{ lang,}
    \DataTypeTok{start_url =}\NormalTok{ startUrl,}
    \DataTypeTok{display =}\NormalTok{ display,}
    \DataTypeTok{background_color =}\NormalTok{ background_color,}
    \DataTypeTok{theme_color =}\NormalTok{ theme_color,}
    \DataTypeTok{icons =} \KeywordTok{data.frame}\NormalTok{(}
      \DataTypeTok{src =} \StringTok{"icons/icon-144.png"}\NormalTok{,}
      \DataTypeTok{sizes =} \StringTok{"144x144"}
\NormalTok{    )}
\NormalTok{  )}

  \CommentTok{# create /www folder if does not exist yet}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{dir.exists}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(path, }\StringTok{"/www"}\NormalTok{))) \{}
    \KeywordTok{dir.create}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(path, }\StringTok{"/www/icons"}\NormalTok{), }\DataTypeTok{recursive =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{  jsonlite}\OperatorTok{::}\KeywordTok{write_json}\NormalTok{(}
\NormalTok{    manifest, }
    \DataTypeTok{path =} \KeywordTok{paste0}\NormalTok{(path, }\StringTok{"/www/manifest.webmanifest"}\NormalTok{),}
    \DataTypeTok{pretty =} \OtherTok{TRUE}\NormalTok{,}
    \DataTypeTok{auto_unbox =} \OtherTok{TRUE}
\NormalTok{  )}
  
  \KeywordTok{ui_done}\NormalTok{(}\StringTok{"Web manifest successfully created!"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The web manifest and icons have to be included in the \texttt{head} before the Google PWA compatibility
script:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<link}\OtherTok{ rel=}\StringTok{"manifest"}\OtherTok{ href=}\StringTok{"manifest.webmanifest"} \KeywordTok{/>}
\CommentTok{<!-- include icon also from manifest -->}
\KeywordTok{<link}\OtherTok{ rel=}\StringTok{"icon"}\OtherTok{ type=}\StringTok{"image/png"}\OtherTok{ href=}\StringTok{"icons/logo-144.png"}\OtherTok{ sizes=}\StringTok{"144x144"} \KeywordTok{/>}
\end{Highlighting}
\end{Shaded}

\texttt{set\_pwa} includes a \texttt{create\_pwa\_dependency} function that creates an HTML dependency
containing all necessary resources:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#' PWA dependencies utils}
\CommentTok{#'}
\CommentTok{#' @description This function attaches PWA manifest and icons to the given tag}
\CommentTok{#'}
\CommentTok{#' @param tag Element to attach the dependencies.}
\CommentTok{#'}
\CommentTok{#' @importFrom utils packageVersion}
\CommentTok{#' @importFrom htmltools tagList htmlDependency}
\CommentTok{#' @export}
\NormalTok{add_pwa_deps <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
\NormalTok{ pwa_deps <-}\StringTok{ }\KeywordTok{htmlDependency}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"pwa-utils"}\NormalTok{,}
  \DataTypeTok{version =} \KeywordTok{packageVersion}\NormalTok{(}\StringTok{"shinyMobile"}\NormalTok{),}
  \DataTypeTok{src =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{file =} \StringTok{"shinyMobile-0.0.0.9000"}\NormalTok{),}
  \DataTypeTok{head =} \StringTok{"<link rel=}\CharTok{\textbackslash{}"}\StringTok{manifest}\CharTok{\textbackslash{}"}\StringTok{ href=}\CharTok{\textbackslash{}"}\StringTok{manifest.webmanifest}\CharTok{\textbackslash{}"}\StringTok{  />}
\StringTok{<link rel=}\CharTok{\textbackslash{}"}\StringTok{icon}\CharTok{\textbackslash{}"}\StringTok{ type=}\CharTok{\textbackslash{}"}\StringTok{image/png}\CharTok{\textbackslash{}"}\StringTok{ href=}\CharTok{\textbackslash{}"}\StringTok{icons/icon-144.png}\CharTok{\textbackslash{}"}\StringTok{ sizes=}\CharTok{\textbackslash{}"}\StringTok{144x144}\CharTok{\textbackslash{}"}\StringTok{ />"}\NormalTok{,}
  \DataTypeTok{package =} \StringTok{"mypkg2"}\NormalTok{,}
\NormalTok{ )}
 \KeywordTok{tagList}\NormalTok{(tag, pwa_deps)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In practice, since the package already relies on other dependencies like Framework7, we will leverage the \texttt{charpente::add\_dependencies} function to add all dependencies at once.

\begin{noteblock}
Importantly, all provided icons must follow the convention \texttt{icon-\textless{}size\_in\_px\textgreater{}.png} like
\texttt{icon-144.png}, which is the default.

\end{noteblock}

\hypertarget{google-pwa-compatibility}{%
\subsection{Google PWA compatibility}\label{google-pwa-compatibility}}

As we use the Google PWA compatibility script, we have to include at least one icon
like \texttt{\textless{}link\ rel="icon"\ type="image/png"\ href="res/icon-128.png"\ sizes="128x128"\ /\textgreater{}}.
However, we found some discrepancies between the developer tools recommendations and the
PWA compatibility script. Therefore, we recommend to follow the developer tools prescriptions, that
is to include at least one icon of size 144x144. All other elements are generated by the script itself,
which is convenient. Indeed, having to handle all possible screen sizes and different OS is particularly
tricky, repetitive and not interesting.

The HTML dependency is downloaded with \texttt{create\_dependency("pwacompat",\ options\ =\ charpente\_options(bundle\ =\ FALSE))}.
Don't forget to update the \texttt{add\_dependencies} list by including the two new dependencies:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f7_page <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., navbar, toolbar, }\DataTypeTok{title =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{) \{}

\NormalTok{  config_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \DataTypeTok{type =} \StringTok{"application/json"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{data-for}\StringTok{`}\NormalTok{ =}\StringTok{ "app"}\NormalTok{,}
\NormalTok{    jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}
      \DataTypeTok{x =}\NormalTok{ options,}
      \DataTypeTok{auto_unbox =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{json_verbatim =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{  )}

  \CommentTok{# create body_tag}
\NormalTok{  body_tag <-}\StringTok{ }\NormalTok{tags}\OperatorTok{$}\KeywordTok{body}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
      \DataTypeTok{id =} \StringTok{"app"}\NormalTok{,}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
        \DataTypeTok{class =} \StringTok{"view view-main"}\NormalTok{,}
\NormalTok{        tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
          \DataTypeTok{class =} \StringTok{"page"}\NormalTok{,}
\NormalTok{          navbar,}
\NormalTok{          toolbar,}
\NormalTok{          tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
            \DataTypeTok{class =} \StringTok{"page-content"}\NormalTok{,}
\NormalTok{            ...}
\NormalTok{          )}
\NormalTok{        )}
\NormalTok{      )}
\NormalTok{    ),}
\NormalTok{    config_tag}
\NormalTok{  )}

  \KeywordTok{tagList}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}\DataTypeTok{charset =} \StringTok{"utf-8"}\NormalTok{),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"viewport"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"apple-mobile-web-app-capable"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"yes"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{meta}\NormalTok{(}
        \DataTypeTok{name =} \StringTok{"theme-color"}\NormalTok{,}
        \DataTypeTok{content =} \StringTok{"#2196f3"}
\NormalTok{      ),}
\NormalTok{      tags}\OperatorTok{$}\KeywordTok{title}\NormalTok{(title)}
\NormalTok{    ),}
    \KeywordTok{add_dependencies}\NormalTok{(}
\NormalTok{      body_tag,}
      \DataTypeTok{deps =} \KeywordTok{c}\NormalTok{(}\StringTok{"framework7"}\NormalTok{, }\StringTok{"shinyMobile"}\NormalTok{, }\StringTok{"pwa"}\NormalTok{, }\StringTok{"pwacompat"}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If you do \texttt{devtools::load\_all()} and run the app again, you should see the new dependencies
in the \texttt{head} (Figure \ref{fig:mobile-pwa-deps}).

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-deps} \caption{New PWA dependencies in the head tag.}\label{fig:mobile-pwa-deps}
\end{figure}

Yet, according to Figure \ref{fig:mobile-pwa-missing-sw}, we still miss the service worker,
as shown in the manifest diagnostic. This demonstrates how powerful are the developer tools as
the end user is always guided step by step.

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-missing-sw} \caption{Missing service worker registration.}\label{fig:mobile-pwa-missing-sw}
\end{figure}

\hypertarget{service-worker-and-offline-page}{%
\subsection{Service worker and offline page}\label{service-worker-and-offline-page}}

The second mandatory step to make our app installable is the service worker.
We borrowed the code from \href{https://web.dev/offline-fallback-page/}{web.dev}. \texttt{set\_pwa} copies
this code in the the provided app \texttt{www} folder:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/*}
\CommentTok{Copyright 2015, 2019, 2020 Google LLC. All Rights Reserved.}
\CommentTok{ Licensed under the Apache License, Version 2.0 (the "License");}
\CommentTok{ you may not use this file except in compliance with the License.}
\CommentTok{ You may obtain a copy of the License at}
\CommentTok{ http://www.apache.org/licenses/LICENSE-2.0}
\CommentTok{ Unless required by applicable law or agreed to in writing, software}
\CommentTok{ distributed under the License is distributed on an "AS IS" BASIS,}
\CommentTok{ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}
\CommentTok{ See the License for the specific language governing permissions and}
\CommentTok{ limitations under the License.}
\CommentTok{*/}

\CommentTok{// Incrementing OFFLINE_VERSION will kick off the install event and force}
\CommentTok{// previously cached resources to be updated from the network.}
\KeywordTok{const}\NormalTok{ OFFLINE_VERSION }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ CACHE_NAME }\OperatorTok{=} \StringTok{"offline"}\OperatorTok{;}
\CommentTok{// Customize this with a different URL if needed.}
\KeywordTok{const}\NormalTok{ OFFLINE_URL }\OperatorTok{=} \StringTok{"offline.html"}\OperatorTok{;}

\VariableTok{self}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{"install"}\OperatorTok{,}\NormalTok{ (event) }\KeywordTok{=>} \OperatorTok{\{}
  \VariableTok{event}\NormalTok{.}\AttributeTok{waitUntil}\NormalTok{(}
\NormalTok{    (}\KeywordTok{async}\NormalTok{ () }\KeywordTok{=>} \OperatorTok{\{}
      \KeywordTok{const}\NormalTok{ cache }\OperatorTok{=} \ControlFlowTok{await} \VariableTok{caches}\NormalTok{.}\AttributeTok{open}\NormalTok{(CACHE_NAME)}\OperatorTok{;}
      \CommentTok{// Setting \{cache: 'reload'\} in the new request will ensure that the}
      \CommentTok{// response isn't fulfilled from the HTTP cache; i.e., it will be from}
      \CommentTok{// the network.}
      \ControlFlowTok{await} \VariableTok{cache}\NormalTok{.}\AttributeTok{add}\NormalTok{(}\KeywordTok{new} \AttributeTok{Request}\NormalTok{(OFFLINE_URL}\OperatorTok{,} \OperatorTok{\{} \DataTypeTok{cache}\OperatorTok{:} \StringTok{"reload"} \OperatorTok{\}}\NormalTok{))}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)()}
\NormalTok{  )}\OperatorTok{;}
  \CommentTok{// Force the waiting service worker to become the active service worker.}
  \VariableTok{self}\NormalTok{.}\AttributeTok{skipWaiting}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\VariableTok{self}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{"activate"}\OperatorTok{,}\NormalTok{ (event) }\KeywordTok{=>} \OperatorTok{\{}
  \VariableTok{event}\NormalTok{.}\AttributeTok{waitUntil}\NormalTok{(}
\NormalTok{    (}\KeywordTok{async}\NormalTok{ () }\KeywordTok{=>} \OperatorTok{\{}
      \CommentTok{// Enable navigation preload if it's supported.}
      \CommentTok{// See https://developers.google.com/web/updates/2017/02/navigation-preload}
      \ControlFlowTok{if}\NormalTok{ (}\StringTok{"navigationPreload"} \KeywordTok{in} \VariableTok{self}\NormalTok{.}\AttributeTok{registration}\NormalTok{) }\OperatorTok{\{}
        \ControlFlowTok{await} \VariableTok{self}\NormalTok{.}\VariableTok{registration}\NormalTok{.}\VariableTok{navigationPreload}\NormalTok{.}\AttributeTok{enable}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}\NormalTok{)()}
\NormalTok{  )}\OperatorTok{;}

  \CommentTok{// Tell the active service worker to take control of the page immediately.}
  \VariableTok{self}\NormalTok{.}\VariableTok{clients}\NormalTok{.}\AttributeTok{claim}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\VariableTok{self}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{"fetch"}\OperatorTok{,}\NormalTok{ (event) }\KeywordTok{=>} \OperatorTok{\{}
  \CommentTok{// We only want to call event.respondWith() if this is a navigation request}
  \CommentTok{// for an HTML page.}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{event}\NormalTok{.}\VariableTok{request}\NormalTok{.}\AttributeTok{mode} \OperatorTok{===} \StringTok{"navigate"}\NormalTok{) }\OperatorTok{\{}
    \VariableTok{event}\NormalTok{.}\AttributeTok{respondWith}\NormalTok{(}
\NormalTok{      (}\KeywordTok{async}\NormalTok{ () }\KeywordTok{=>} \OperatorTok{\{}
        \ControlFlowTok{try} \OperatorTok{\{}
          \CommentTok{// First, try to use the navigation preload response if it's supported.}
          \KeywordTok{const}\NormalTok{ preloadResponse }\OperatorTok{=} \ControlFlowTok{await} \VariableTok{event}\NormalTok{.}\AttributeTok{preloadResponse}\OperatorTok{;}
          \ControlFlowTok{if}\NormalTok{ (preloadResponse) }\OperatorTok{\{}
            \ControlFlowTok{return}\NormalTok{ preloadResponse}\OperatorTok{;}
          \OperatorTok{\}}

          \CommentTok{// Always try the network first.}
          \KeywordTok{const}\NormalTok{ networkResponse }\OperatorTok{=} \ControlFlowTok{await} \AttributeTok{fetch}\NormalTok{(}\VariableTok{event}\NormalTok{.}\AttributeTok{request}\NormalTok{)}\OperatorTok{;}
          \ControlFlowTok{return}\NormalTok{ networkResponse}\OperatorTok{;}
        \OperatorTok{\}} \ControlFlowTok{catch}\NormalTok{ (error) }\OperatorTok{\{}
          \CommentTok{// catch is only triggered if an exception is thrown, which is likely}
          \CommentTok{// due to a network error.}
          \CommentTok{// If fetch() returns a valid HTTP response with a response code in}
          \CommentTok{// the 4xx or 5xx range, the catch() will NOT be called.}
          \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{"Fetch failed; returning offline page instead."}\OperatorTok{,}\NormalTok{ error)}\OperatorTok{;}

          \KeywordTok{const}\NormalTok{ cache }\OperatorTok{=} \ControlFlowTok{await} \VariableTok{caches}\NormalTok{.}\AttributeTok{open}\NormalTok{(CACHE_NAME)}\OperatorTok{;}
          \KeywordTok{const}\NormalTok{ cachedResponse }\OperatorTok{=} \ControlFlowTok{await} \VariableTok{cache}\NormalTok{.}\AttributeTok{match}\NormalTok{(OFFLINE_URL)}\OperatorTok{;}
          \ControlFlowTok{return}\NormalTok{ cachedResponse}\OperatorTok{;}
        \OperatorTok{\}}
      \OperatorTok{\}}\NormalTok{)()}
\NormalTok{    )}\OperatorTok{;}
  \OperatorTok{\}}

  \CommentTok{// If our if() condition is false, then this fetch handler won't intercept the}
  \CommentTok{// request. If there are any other fetch handlers registered, they will get a}
  \CommentTok{// chance to call event.respondWith(). If no fetch handlers call}
  \CommentTok{// event.respondWith(), the request will be handled by the browser as if there}
  \CommentTok{// were no service worker involvement.}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This service worker redirects the end user to the offline cached page (\texttt{offline.html}) whenever
the app is offline, thereby offering a better user experience.

\begin{importantblock}
We strongly advise to keep the same file names.

\end{importantblock}

The next step involves the service worker registration. Framework7 has a dedicated module in the
app configuration. We modify \texttt{init.js} and run \texttt{build\_js()} to update the minified file:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{serviceWorker}\OperatorTok{:} \OperatorTok{\{}
  \DataTypeTok{path}\OperatorTok{:} \VariableTok{window}\NormalTok{.}\VariableTok{location}\NormalTok{.}\AttributeTok{pathname} \OperatorTok{+} \StringTok{'service-worker.js'}\OperatorTok{,}
  \DataTypeTok{scope}\OperatorTok{:} \VariableTok{window}\NormalTok{.}\VariableTok{location}\NormalTok{.}\AttributeTok{pathname}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If the process is successful, you get the result shown in Figure \ref{fig:mobile-pwa-registered-sw}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-registered-sw} \caption{Registered service worker.}\label{fig:mobile-pwa-registered-sw}
\end{figure}

The new standard imposes to return a valid response when the app is offline. The offline page is
also copied from \texttt{\{charpente\}}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ lang=}\StringTok{"en"}\KeywordTok{>}
  \KeywordTok{<head>}
    \KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"utf-8"} \KeywordTok{/>}
    \KeywordTok{<meta}\OtherTok{ http-equiv=}\StringTok{"X-UA-Compatible"}\OtherTok{ content=}\StringTok{"IE=edge"} \KeywordTok{/>}
    \KeywordTok{<meta}\OtherTok{ name=}\StringTok{"viewport"}\OtherTok{ content=}\StringTok{"width=device-width, initial-scale=1"} \KeywordTok{/>}

    \KeywordTok{<title>}\NormalTok{You are offline}\KeywordTok{</title>}

    \CommentTok{<!-- inline the webpage's stylesheet -->}
    \KeywordTok{<style>}
\NormalTok{      body \{}
        \KeywordTok{font-family}\NormalTok{: helvetica}\OperatorTok{,}\NormalTok{ arial}\OperatorTok{,} \DecValTok{sans-serif}\OperatorTok{;}
        \KeywordTok{margin}\NormalTok{: }\DecValTok{2}\DataTypeTok{em}\OperatorTok{;}
\NormalTok{      \}}

\NormalTok{      h1 \{}
        \KeywordTok{font-style}\NormalTok{: }\DecValTok{italic}\OperatorTok{;}
        \KeywordTok{color}\NormalTok{: }\ConstantTok{#373fff}\OperatorTok{;}
\NormalTok{      \}}

\NormalTok{      p \{}
        \KeywordTok{margin-block}\NormalTok{: }\DecValTok{1}\DataTypeTok{rem}\OperatorTok{;}
\NormalTok{      \}}

\NormalTok{      button \{}
        \KeywordTok{display}\NormalTok{: }\DecValTok{block}\OperatorTok{;}
\NormalTok{      \}}
    \KeywordTok{</style>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<h1>}\NormalTok{You are offline}\KeywordTok{</h1>}

    \KeywordTok{<p>}\NormalTok{Click the button below to try reloading.}\KeywordTok{</p>}
    \KeywordTok{<button}\OtherTok{ type=}\StringTok{"button"}\KeywordTok{>}\NormalTok{ Reload}\KeywordTok{</button>}

    \CommentTok{<!-- inline the webpage's javascript file -->}
    \KeywordTok{<script>}
      \VariableTok{document}\NormalTok{.}\AttributeTok{querySelector}\NormalTok{(}\StringTok{"button"}\NormalTok{).}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{"click"}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=>} \OperatorTok{\{}
        \VariableTok{window}\NormalTok{.}\VariableTok{location}\NormalTok{.}\AttributeTok{reload}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{</script>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

Now, let's audit our app again: congrats! Our app is installable, reliable, although
further PWA optimization may be provided.

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-audit-final} \caption{Installable shinyMobile app.}\label{fig:mobile-pwa-audit-final}
\end{figure}

\begin{importantblock}
A common source of error is the browser cache. It is best practice to regularly empty the cache.
Alternatively, one may runs in incognito mode, which does not cache files.

\end{importantblock}

\hypertarget{disable-pwa-for-the-end-user}{%
\subsection{Disable PWA for the end user}\label{disable-pwa-for-the-end-user}}

With the above approach, \texttt{\{shinyMobile\}} will always look for a service worker to register.
Particularly, this would raise an error in case no service worker is found on the server.
What if the user don't want to create a PWA, let's say for less important applications?
We may add a parameter to the \texttt{f7Page}, for instance \texttt{allowPWA}, that is either \texttt{TRUE} or \texttt{FALSE},
store its value in the \texttt{body} \texttt{data-pwa} attribute and recover it on the JS side within \texttt{init.js}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// check if the app is intended to be a PWA}
\KeywordTok{var}\NormalTok{ isPWA }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'body'}\NormalTok{).}\AttributeTok{attr}\NormalTok{(}\StringTok{'data-pwa'}\NormalTok{) }\OperatorTok{===} \StringTok{"true"}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (isPWA) }\OperatorTok{\{}
  \VariableTok{config}\NormalTok{.}\AttributeTok{serviceWorker} \OperatorTok{=} \OperatorTok{\{}
    \DataTypeTok{path}\OperatorTok{:} \VariableTok{window}\NormalTok{.}\VariableTok{location}\NormalTok{.}\AttributeTok{pathname} \OperatorTok{+} \StringTok{"service-worker.js"}\OperatorTok{,}
    \DataTypeTok{scope}\OperatorTok{:} \VariableTok{window}\NormalTok{.}\VariableTok{location}\NormalTok{.}\AttributeTok{pathname}
  \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

It \textbf{only} creates \texttt{config.serviceWorker} if the user specified \texttt{allowPWA\ =\ TRUE}.

\hypertarget{handle-the-installation}{%
\section{Handle the installation}\label{handle-the-installation}}

It is a great opportunity to propose a \href{https://developers.google.com/web/fundamentals/app-install-banners/native}{custom} installation experience.

\begin{warningbox}
To be able to install the app, make sure to replace \texttt{start\_url} by the url
where the app is deployed like \texttt{https://dgranjon.shinyapps.io/installable-pwa-app/} for instance.
Missing that step would cause an issue during the service worker registration.

\end{warningbox}

Once the installation criteria are met, the web browser raises the \texttt{beforeinstallprompt} event, except
on the iOS platform, that is not yet compatible. We edit the \texttt{init.js} script and write:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ deferredPrompt}\OperatorTok{;}
\VariableTok{window}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{'beforeinstallprompt'}\OperatorTok{,}\NormalTok{ (e) }\KeywordTok{=>} \OperatorTok{\{}
  \CommentTok{// Prevent the mini-infobar from appearing on mobile}
  \VariableTok{e}\NormalTok{.}\AttributeTok{preventDefault}\NormalTok{()}\OperatorTok{;}
  \CommentTok{// Stash the event so it can be triggered later.}
\NormalTok{  deferredPrompt }\OperatorTok{=}\NormalTok{ e}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This code adds an event listener to the window, prevents it from showing at start with \texttt{e.preventDefault} and
captures it in an external variable called \texttt{deferredPrompt}. The next step comprises the design of our custom piece of UI that will trigger the \texttt{prompt} install. We can benefit from the rich Framework7 interface and display
a \href{https://framework7.io/docs/toast.html}{toast} containing an install button. The initialization
is fairly simple, following the pattern \texttt{app.\textless{}COMPONENT\textgreater{}.create(parameters)}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Create custom install UI}
\KeywordTok{var}\NormalTok{ installToast }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{toast}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}
  \DataTypeTok{position}\OperatorTok{:} \StringTok{'center'}\OperatorTok{,}
  \DataTypeTok{text}\OperatorTok{:} \StringTok{'<button id="install-button" class="toast-button button color-green">Install</button>'}\OperatorTok{,}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We give it an id so as to call it later and edit the \texttt{beforeinstallprompt} event listener to show
the toast:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ deferredPrompt}\OperatorTok{;}
\VariableTok{window}\NormalTok{.}\AttributeTok{addEventListener}\NormalTok{(}\StringTok{'beforeinstallprompt'}\OperatorTok{,}\NormalTok{ (e) }\KeywordTok{=>} \OperatorTok{\{}
  \CommentTok{// Prevent the mini-infobar from appearing on mobile}
  \VariableTok{e}\NormalTok{.}\AttributeTok{preventDefault}\NormalTok{()}\OperatorTok{;}
  \CommentTok{// Stash the event so it can be triggered later.}
\NormalTok{  deferredPrompt }\OperatorTok{=}\NormalTok{ e}\OperatorTok{;}
  \CommentTok{// Show install trigger}
  \VariableTok{installToast}\NormalTok{.}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{noteblock}
With jQuery like \texttt{\$(window).on(\textquotesingle{}beforeinstallprompt\textquotesingle{},\ ...)}, we would capture the event with \texttt{e.originalEvent}!

\end{noteblock}

We register a second event listener, which fires on the toast button click.
We should wait a bit of time so that the toast exists with \texttt{app.utils.nextTick},
which is, as a reminder, an Framework7 internal equivalent to \texttt{setTimeout}. We first close the
toast, call the prompt method on the deferred event and log the result:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{app}\NormalTok{.}\VariableTok{utils}\NormalTok{.}\AttributeTok{nextTick}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(}\StringTok{'#install-button'}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{'click'}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \CommentTok{// close install toast}
    \VariableTok{installToast}\NormalTok{.}\AttributeTok{close}\NormalTok{()}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{deferredPrompt) }\OperatorTok{\{}
      \CommentTok{// The deferred prompt isn't available.}
      \ControlFlowTok{return}\OperatorTok{;}
    \OperatorTok{\}}
    \CommentTok{// Show the install prompt.}
    \VariableTok{deferredPrompt}\NormalTok{.}\AttributeTok{prompt}\NormalTok{()}\OperatorTok{;}
    \CommentTok{// Log the result}
    \VariableTok{deferredPrompt}\NormalTok{.}\VariableTok{userChoice}\NormalTok{.}\AttributeTok{then}\NormalTok{((result) }\KeywordTok{=>} \OperatorTok{\{}
      \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{''}\OperatorTok{,} \StringTok{'userChoice'}\OperatorTok{,}\NormalTok{ result)}\OperatorTok{;}
      \CommentTok{// Reset the deferred prompt variable, since}
      \CommentTok{// prompt() can only be called once.}
\NormalTok{      deferredPrompt }\OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\},} \DecValTok{500}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We run \texttt{build\_js()} and deploy the app to shinyapps.io. Figure \ref{fig:mobile-pwa-installable}
illustrates the install prompt window that appears to install the app. Once installed, the \texttt{beforeinstallprompt}
event does not fire anymore and the app may be launched as a standalone app, for instance on macOSX (Figure \ref{fig:mobile-pwa-installed}).

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-installable} \caption{Install prompt window.}\label{fig:mobile-pwa-installable}
\end{figure}

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-installed} \caption{Installed PWA on macOSX.}\label{fig:mobile-pwa-installed}
\end{figure}

On Figure \ref{fig:mobile-pwa-installed}, the blue window color corresponds to the \texttt{tags\$meta(name\ =\ "theme-color",\ content\ =\ "\#2196f3")}, passed in the \texttt{f7\_page} layout element. Whenever the connection is lost, the redirection occurs to
the \texttt{offline.html} page, as shown on Figure \ref{fig:mobile-pwa-offline}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/mobile/mobile-pwa-offline} \caption{Offline HTML template.}\label{fig:mobile-pwa-offline}
\end{figure}

The final product may be run with:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyAppDir}\NormalTok{(}\KeywordTok{system.file}\NormalTok{(}\StringTok{"shinyMobile/pwa"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{workbox}{%
\section{Workbox}\label{workbox}}

\href{https://developers.google.com/web/tools/workbox}{Workbox} is a more robust alternative
to the approach described above. Interestingly, Framework7
uses Workbox as a service worker generator by default. It does:

\begin{itemize}
\tightlist
\item
  pre-caching of dependencies like CSS and JS but also images and Google fonts
  to improve performances.
\item
  Improve offline experience.
\item
  \ldots{}
\end{itemize}

TO FINISH (it currently does not work).

\hypertarget{other-resources}{%
\section{Other resources}\label{other-resources}}

The process described above works perfectly for any Shiny template. The reader may also consider other packages like
\href{https://github.com/pedrocoutinhosilva/shiny.pwa}{\{shiny.pwa\}}, that creates a PWA compatible structure
at run time, within the app \texttt{/www} folder.

\hypertarget{mobile-widgets}{%
\chapter{Design widgets}\label{mobile-widgets}}

Framework7 brings dozen of different widgets like a photo browser, virtual lists (high performance lists),
messages, notifications, toasts. Figure \ref{fig:mobile-widgets-examples} shows from left to right the chat widget, the floating action buttons and the gauges.

\includegraphics[width=0.33\linewidth]{images/mobile/mobile-widget-chat} \includegraphics[width=0.33\linewidth]{images/mobile/mobile-widget-fab} \includegraphics[width=0.33\linewidth]{images/mobile/mobile-widget-gauges}

Looking at the \href{https://v5.framework7.io/docs/}{documentation}, the API is most of the time
always the same that is, we create the widget:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{app}\NormalTok{.}\VariableTok{widget}\NormalTok{.}\AttributeTok{create}\NormalTok{(parameters)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

and we update, open or close it later:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{app}\NormalTok{.}\VariableTok{widget}\NormalTok{.}\AttributeTok{update}\NormalTok{(newParameters)}\OperatorTok{;}
\VariableTok{app}\NormalTok{.}\VariableTok{widget}\NormalTok{.}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}
\VariableTok{app}\NormalTok{.}\VariableTok{widget}\NormalTok{.}\AttributeTok{close}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

I must admit, there are few deviations like the navbar (\texttt{app.navbar.show()}) or the dialog but we have enough common points to design a main wrapper that creates any widget and update/open/close it.

What we do below significantly simplifies the R/JS API by providing a general method to
initialize and update some of those widgets.

\begin{warningbox}
As a reminder, the code examples shown throughout this chapter are gathered in the \texttt{\{OSUICode\}} package accessible \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code}{here}, specifically \href{https://github.com/DivadNojnarg/outstanding-shiny-ui-code/blob/master/R/shinyMobile.R\#L122}{here} for widgets.

\end{warningbox}

\hypertarget{build-the-ui}{%
\section{Build the UI}\label{build-the-ui}}

We know that JavaScript must receive a configuration object to create the widget instance.
As shown earlier in this book, there is a simple way to achieve this. Let's consider the \href{https://v5.framework7.io/docs/gauge.html}{gauge} example.

On the UI side, we expect to have:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ class=}\StringTok{"gauge"}\KeywordTok{></div>}
\end{Highlighting}
\end{Shaded}

Upon instantiating, Framework7 populates this container with the relevant tags.
The \texttt{f7\_gauge} function creates a \texttt{div} tag with the \texttt{gauge} class as well as a configuration
tag:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f7_gauge <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, value, }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{) \{}

  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(options[[}\StringTok{"valueText"}\NormalTok{]])) options[[}\StringTok{"valueText"}\NormalTok{]] <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(value }\OperatorTok{*}\StringTok{ }\DecValTok{100}\NormalTok{, }\StringTok{"%"}\NormalTok{)}

\NormalTok{  gaugeProps <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{value =}\NormalTok{ value), options)}

\NormalTok{  gaugeConfig <-}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \DataTypeTok{type =} \StringTok{"application/json"}\NormalTok{,}
    \StringTok{`}\DataTypeTok{data-for}\StringTok{`}\NormalTok{ =}\StringTok{ }\NormalTok{id,}
\NormalTok{    jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}
      \DataTypeTok{x =}\NormalTok{ gaugeProps,}
      \DataTypeTok{auto_unbox =} \OtherTok{TRUE}\NormalTok{,}
      \DataTypeTok{json_verbatim =} \OtherTok{TRUE}
\NormalTok{    )}
\NormalTok{  )}

\NormalTok{  shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{div}\NormalTok{(}
    \DataTypeTok{class =} \StringTok{"gauge"}\NormalTok{,}
    \DataTypeTok{id =}\NormalTok{ id,}
\NormalTok{    gaugeConfig}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We provide a default for the \texttt{valueText} option that should display the current
value followed by a \texttt{\%} symbol. Note that the class is crucial to target the relevant tag on the JS side.
All other widgets more or less follow the same scheme. Be careful about partial matching
with the \texttt{\$} operator. This is the reason why we used \texttt{{[}{[}} instead: with \texttt{\$}, \texttt{valueText} could be
matched with \texttt{valueTextColor}, leading to unexpected behavior.

\hypertarget{widgets-without-preexisting-ui}{%
\section{Widgets without preexisting UI}\label{widgets-without-preexisting-ui}}

There are few widgets like toasts, notifications that don't have any predefined UI
element when the app starts. In this case, we simply send the configuration to JS, through
the \texttt{session}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f7_notif <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{id =} \OtherTok{NULL}\NormalTok{, text, }\DataTypeTok{options =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}

  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(options}\OperatorTok{$}\NormalTok{icon)) options}\OperatorTok{$}\NormalTok{icon <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(options}\OperatorTok{$}\NormalTok{icon)}

\NormalTok{  message <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\KeywordTok{dropNulls}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ id, }\DataTypeTok{text =}\NormalTok{ text)), options)}
  \CommentTok{# see my-app.js function}
  \KeywordTok{sendCustomMessage}\NormalTok{(}\StringTok{"notification"}\NormalTok{, message, session)}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Pay attention to the \texttt{options\$icon} element. As we can't convert shiny tags to JSON, it
must be converted to character first. If multiple parameters should contain tags,
you must treat them accordingly!

\hypertarget{initialize-the-widget}{%
\section{Initialize the widget}\label{initialize-the-widget}}

On the JS side, we create a new script, \texttt{widgets.js}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(charpente)}
\KeywordTok{create_js}\NormalTok{(}\StringTok{"widgets"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We set an array containing all compatible widget names in two categories and concatenate
in a \texttt{widgets} element:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ uiWidgets }\OperatorTok{=}\NormalTok{ [}\StringTok{"gauge"}\OperatorTok{,} \StringTok{"swiper"}\OperatorTok{,} \StringTok{"searchbar"}\NormalTok{]}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ serverWidgets }\OperatorTok{=}\NormalTok{ [}\StringTok{"toast"}\OperatorTok{,} \StringTok{"photoBrowser"}\OperatorTok{,} \StringTok{"notification"}\NormalTok{]}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ widgets }\OperatorTok{=} \VariableTok{uiWidgets}\NormalTok{.}\AttributeTok{concat}\NormalTok{(serverWidgets)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Notice that as we are going to use the \texttt{app} object, we import them from the \texttt{init.js} script, located
in the same \texttt{/srcjs} folder.

We then define the \texttt{activateWidget} function, only considering UI widgets.
Since we have two widgets categories, this function first checks whether the widget is part of the \texttt{uiWidgets} array with \texttt{indexOf}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\VariableTok{uiWidgets}\NormalTok{.}\AttributeTok{indexOf}\NormalTok{(widget) }\OperatorTok{>} \DecValTok{-1}\NormalTok{) }\OperatorTok{\{}
  \CommentTok{// Do things}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

As there may be multiple widgets of the same type, we must loop through all
possible elements. This is where the class is important and must match the widget generic name.
For instance, the gauge has the \texttt{gauge} class and the methods are always \texttt{app.gauge.}.
How do we loop through multiple widgets? We use the jQuery \texttt{each} method:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\VariableTok{uiWidgets}\NormalTok{.}\AttributeTok{indexOf}\NormalTok{(widget) }\OperatorTok{>} \DecValTok{-1}\NormalTok{) }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(}\StringTok{"."} \OperatorTok{+}\NormalTok{ widget).}\AttributeTok{each}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \CommentTok{// Do things}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

We see that \texttt{\$("."\ +\ widget)} gives \texttt{\$(".gauge)} when the widget is a gauge, which
targets all gauges one by one. Then for each gauge, we extract the configuration containing
all options passed by the end user. Remember that each element has a unique id.
We extract the current element \texttt{\$(this)} in the \texttt{\$el} variable and search for a
script tag pointing to the unique tag having \texttt{\$el.attr("id")} as id. The configuration is parsed
and converted to an object. Note that most of the time, Framework7 expects to have a \texttt{el}
attributes which simply contains the CSS selector of the current element,
in other words its unique id \texttt{\textquotesingle{}\#\textquotesingle{}\ +\ \$el.attr("id")}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\VariableTok{uiWidgets}\NormalTok{.}\AttributeTok{indexOf}\NormalTok{(widget) }\OperatorTok{>} \DecValTok{-1}\NormalTok{) }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(}\StringTok{"."} \OperatorTok{+}\NormalTok{ widget).}\AttributeTok{each}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ $el }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\KeywordTok{this}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ config }\OperatorTok{=} \AttributeTok{$}\NormalTok{(document).}\AttributeTok{find}\NormalTok{(}
      \StringTok{"script[data-for='"} \OperatorTok{+} \VariableTok{$el}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{"id"}\NormalTok{) }\OperatorTok{+} \StringTok{"']"}
\NormalTok{    )}\OperatorTok{;}
\NormalTok{    config }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{config}\NormalTok{.}\AttributeTok{html}\NormalTok{())}\OperatorTok{;}
    \CommentTok{// add the id}
    \VariableTok{config}\NormalTok{.}\AttributeTok{el} \OperatorTok{=} \StringTok{'#'} \OperatorTok{+} \VariableTok{$el}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{"id"}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The final step consists in initializing the widget, which is quite straightforward if we notice that
\texttt{app.gauge} is the same as \texttt{app{[}"gauge"{]}}. We obtain the general code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app[widget].}\AttributeTok{create}\NormalTok{(config)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

For the server widgets, it is even simpler. We recover the message with a \texttt{Shiny.addCustomMessageHandler("type",\ callback)} and
initialize it. The only possible source of problem is the custom message \texttt{type} that must be the same
as the one specified in the R function with \texttt{session\$sendCustomMessage("type",\ message)}. We create
an \texttt{else} statement following the \texttt{if} condition and put the below code inside:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(widget}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{id} \OperatorTok{!==} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
    \VariableTok{message}\NormalTok{.}\AttributeTok{on} \OperatorTok{=} \OperatorTok{\{}
      \DataTypeTok{opened}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
        \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \KeywordTok{true}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\},}
      \DataTypeTok{closed}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
        \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \KeywordTok{false}\NormalTok{)}\OperatorTok{;}
        \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[widget][}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{].}\AttributeTok{destroy}\NormalTok{()}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\};} 
  \OperatorTok{\}}

\NormalTok{  app[widget].}\AttributeTok{create}\NormalTok{(message).}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

As shown in the above code, we can chain methods and immediately open the widget, right after its creation. Moreover, it
is always good practice to let Shiny know about the widget state, that is whether it is currently
opened. This is the reason why we added an \texttt{on} property to the message. All widgets trigger \href{https://v5.framework7.io/docs/notification.html\#dom-events}{events},
for instance notifications have the \texttt{notification:opened} and \texttt{notification:closed}. For each event,
we set an input value on the fly, with \texttt{Shiny.setInputValue} as explained in Chapter \ref(quick-inputs). This way, our future users are able to know exactly when the widget is closed or opened, thereby being able to trigger any subsequent action. This obviously requires the widget to pass an optional \texttt{id} attribute to ensure the uniqueness!

The full JavaScript code may be found here:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Instantiate a widget}
\NormalTok{activateWidget }\OperatorTok{=} \KeywordTok{function}\NormalTok{(widget) }\OperatorTok{\{}
  \CommentTok{// Handle ui side widgets}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{uiWidgets}\NormalTok{.}\AttributeTok{indexOf}\NormalTok{(widget) }\OperatorTok{>} \DecValTok{-1}\NormalTok{) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\StringTok{"."} \OperatorTok{+}\NormalTok{ widget).}\AttributeTok{each}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
      \KeywordTok{var}\NormalTok{ $el }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\KeywordTok{this}\NormalTok{)}\OperatorTok{;}
      \KeywordTok{var}\NormalTok{ config }\OperatorTok{=} \AttributeTok{$}\NormalTok{(document).}\AttributeTok{find}\NormalTok{(}
        \StringTok{"script[data-for='"} \OperatorTok{+} \VariableTok{$el}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{"id"}\NormalTok{) }\OperatorTok{+} \StringTok{"']"}
\NormalTok{      )}\OperatorTok{;}
\NormalTok{      config }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{config}\NormalTok{.}\AttributeTok{html}\NormalTok{())}\OperatorTok{;}
      \CommentTok{// add the id}
      \VariableTok{config}\NormalTok{.}\AttributeTok{el} \OperatorTok{=} \StringTok{'#'} \OperatorTok{+} \VariableTok{$el}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{"id"}\NormalTok{)}\OperatorTok{;}

      \CommentTok{// feed the create method}
\NormalTok{      app[widget].}\AttributeTok{create}\NormalTok{(config)}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \CommentTok{// This concerns toasts, notifications, photoBrowser, ...}
    \CommentTok{// that don't have any UI element in the DOM before creating}
    \CommentTok{// the widget instance.}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(widget}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{id} \OperatorTok{!==} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
        \VariableTok{message}\NormalTok{.}\AttributeTok{on} \OperatorTok{=} \OperatorTok{\{}
          \DataTypeTok{opened}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
            \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \KeywordTok{true}\NormalTok{)}\OperatorTok{;}
          \OperatorTok{\},}
          \DataTypeTok{closed}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
            \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \KeywordTok{false}\NormalTok{)}\OperatorTok{;}
            \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[widget][}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{].}\AttributeTok{destroy}\NormalTok{()}\OperatorTok{;}
          \OperatorTok{\}}
        \OperatorTok{\};} 
      \OperatorTok{\}}
\NormalTok{      app[widget].}\AttributeTok{create}\NormalTok{(message).}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

The final step aims at activating all widgets. We proceed with a \texttt{forEach} loop:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Loop over all widgets to activate them}
\VariableTok{widgets}\NormalTok{.}\AttributeTok{forEach}\NormalTok{(}\KeywordTok{function}\NormalTok{(w) }\OperatorTok{\{}
  \AttributeTok{activateWidget}\NormalTok{(w)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Let's try below with a notification example, where we capture the state of the notification
in an input element:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{f7_page}\NormalTok{(}
  \DataTypeTok{navbar =} \KeywordTok{f7_navbar}\NormalTok{(}\StringTok{"Title"}\NormalTok{),}
  \DataTypeTok{toolbar =} \KeywordTok{f7_toolbar}\NormalTok{(),}
  \DataTypeTok{title =} \StringTok{"shinyMobile"}\NormalTok{,}
  \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{theme =} \StringTok{"ios"}\NormalTok{,}
    \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{,}
    \DataTypeTok{taphold =} \OtherTok{TRUE}\NormalTok{,}
    \DataTypeTok{color =} \StringTok{"#42f5a1"}\NormalTok{,}
    \DataTypeTok{filled =} \OtherTok{TRUE}\NormalTok{,}
    \DataTypeTok{dark =} \OtherTok{TRUE}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(\{}
    \KeywordTok{f7_notif}\NormalTok{(}\DataTypeTok{id =} \StringTok{"welcome"}\NormalTok{, }\StringTok{"Helloooooo"}\NormalTok{, }\DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{closeTimeout =} \DecValTok{2000}\NormalTok{))}
\NormalTok{  \})}
  
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{welcome, \{}
\NormalTok{    shiny}\OperatorTok{::}\KeywordTok{showNotification}\NormalTok{(}\KeywordTok{sprintf}\NormalTok{(}\StringTok{"Notification is %s"}\NormalTok{, input}\OperatorTok{$}\NormalTok{welcome))}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Alternatively you may run in the R console:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyAppDir}\NormalTok{(}\KeywordTok{system.file}\NormalTok{(}\StringTok{"shinyMobile/notification"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{update-widgets}{%
\section{Update widgets}\label{update-widgets}}

We would like to develop a similar generalized interface to update any element in the DOM.
Instead of having \texttt{update\_f7\_gauge} or \texttt{update\_f7\_swiper}, we want an \texttt{update\_f7\_instance} function.

We leverage the \texttt{app.data} element that stores all instances by widget type. In Chapter \ref{mobile-global-data},
we already created a cache for tooltips, so let's do it for gauges:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{config}\NormalTok{.}\AttributeTok{data} \OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \ControlFlowTok{return} \OperatorTok{\{}
    \CommentTok{// any other widget type to cache ...}
    \DataTypeTok{gauge}\OperatorTok{:}\NormalTok{ []}
  \OperatorTok{\};}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

At that stage, the array name must be the same as the app method. For instance,
we have \texttt{app.gauge}, which means that we should create \texttt{config.data.gauge} and not \texttt{config.data.gauges},
as it would lead to errors later.

Once the cache is available, we have to modify the JavaScript that creates the widget instance,
to store the new instance in the cache, as shown Figure \ref{fig:mobile-widget-store}. We add the following code, where \texttt{w} refers to the widget instance:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// ui widgets}
\VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[widget][}\VariableTok{$el}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{"id"}\NormalTok{)] }\OperatorTok{=}\NormalTok{ w}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{noteblock}
This manipulation does not make sense for server widgets as they are already generated by the server.

\end{noteblock}

The \texttt{activateWidget} function should be:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Instantiate a widget}
\NormalTok{activateWidget }\OperatorTok{=} \KeywordTok{function}\NormalTok{(widget) }\OperatorTok{\{}
  \CommentTok{// Handle ui side widgets}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{uiWidgets}\NormalTok{.}\AttributeTok{indexOf}\NormalTok{(widget) }\OperatorTok{>} \DecValTok{-1}\NormalTok{) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\StringTok{"."} \OperatorTok{+}\NormalTok{ widget).}\AttributeTok{each}\NormalTok{(}\KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
      \KeywordTok{var}\NormalTok{ $el }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\KeywordTok{this}\NormalTok{)}\OperatorTok{;}
      \KeywordTok{var}\NormalTok{ config }\OperatorTok{=} \AttributeTok{$}\NormalTok{(document).}\AttributeTok{find}\NormalTok{(}
        \StringTok{"script[data-for='"} \OperatorTok{+} \VariableTok{$el}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{"id"}\NormalTok{) }\OperatorTok{+} \StringTok{"']"}
\NormalTok{      )}\OperatorTok{;}
\NormalTok{      config }\OperatorTok{=} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\VariableTok{config}\NormalTok{.}\AttributeTok{html}\NormalTok{())}\OperatorTok{;}
      \CommentTok{// add the id}
      \VariableTok{config}\NormalTok{.}\AttributeTok{el} \OperatorTok{=} \StringTok{'#'} \OperatorTok{+} \VariableTok{$el}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{"id"}\NormalTok{)}\OperatorTok{;}

      \CommentTok{// feed the create method}
      \KeywordTok{var}\NormalTok{ w }\OperatorTok{=}\NormalTok{ app[widget].}\AttributeTok{create}\NormalTok{(config)}\OperatorTok{;}
      \CommentTok{// Store the widget instance in the app data cache}
      \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[widget][}\VariableTok{$el}\NormalTok{.}\AttributeTok{attr}\NormalTok{(}\StringTok{"id"}\NormalTok{)] }\OperatorTok{=}\NormalTok{ w}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \CommentTok{// This concerns toasts, notifications, photoBrowser, ...}
    \CommentTok{// that don't have any UI element in the DOM before creating}
    \CommentTok{// the widget instance.}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(widget}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ (}\VariableTok{message}\NormalTok{.}\AttributeTok{id} \OperatorTok{!==} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
        \VariableTok{message}\NormalTok{.}\AttributeTok{on} \OperatorTok{=} \OperatorTok{\{}
          \DataTypeTok{opened}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
            \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \KeywordTok{true}\NormalTok{)}\OperatorTok{;}
          \OperatorTok{\},}
          \DataTypeTok{closed}\OperatorTok{:} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
            \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \KeywordTok{false}\NormalTok{)}\OperatorTok{;}
            \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[widget][}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{].}\AttributeTok{destroy}\NormalTok{()}\OperatorTok{;}
          \OperatorTok{\}}
        \OperatorTok{\};} 
      \OperatorTok{\}}
      \KeywordTok{var}\NormalTok{ w }\OperatorTok{=}\NormalTok{ app[widget].}\AttributeTok{create}\NormalTok{(message)}\OperatorTok{;}
      \VariableTok{w}\NormalTok{.}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Once done, this is time to design \texttt{update\_f7\_instance}. The R code sends a message to
the current session containing:

\begin{itemize}
\tightlist
\item
  The \textbf{id} of the element to update.
\item
  The new \textbf{configuration}.
\end{itemize}

Since we send a JSON, the hardest part is to correctly process shiny tags. How do we
track shiny tags? As a reminder, let's run the code below:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(shiny}\OperatorTok{::}\KeywordTok{div}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "shiny.tag"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(shiny}\OperatorTok{::}\KeywordTok{tagList}\NormalTok{(shiny}\OperatorTok{::}\KeywordTok{div}\NormalTok{(), shiny}\OperatorTok{::}\KeywordTok{h1}\NormalTok{()))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "shiny.tag.list" "list"
\end{verbatim}

For each configuration element, we must check whether its class contains \texttt{shiny.tag} or \texttt{shiny.tag.list} and convert it to a character. Moreover, it may contain a nested list, like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{options =}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{buttons =} \KeywordTok{list}\NormalTok{(}
   \KeywordTok{list}\NormalTok{(}
     \DataTypeTok{text =} \StringTok{"Some text"}\NormalTok{,}
     \DataTypeTok{icon =} \KeywordTok{f7Icon}\NormalTok{(}\StringTok{"info"}\NormalTok{),}
     \DataTypeTok{color =} \StringTok{"pink"}
\NormalTok{   )}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In that case, our function must be recursive to handle any item having the \texttt{list} class. If the element is simple text or numeric, we return it as is.

We finally get:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{update_f7_instance <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, options, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{()) \{}

  \CommentTok{# Convert any shiny tag into character so that toJSON does not cry}
\NormalTok{  listRenderTags <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(l) \{}
    \KeywordTok{lapply}\NormalTok{(}
      \DataTypeTok{X =}\NormalTok{ l,}
      \ControlFlowTok{function}\NormalTok{(x) \{}
        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(x, }\KeywordTok{c}\NormalTok{(}\StringTok{"shiny.tag"}\NormalTok{, }\StringTok{"shiny.tag.list"}\NormalTok{))) \{}
          \KeywordTok{as.character}\NormalTok{(x)}
\NormalTok{        \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(x, }\StringTok{"list"}\NormalTok{)) \{}
          \CommentTok{# Recursive part}
          \KeywordTok{listRenderTags}\NormalTok{(x)}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{          x}
\NormalTok{        \}}
\NormalTok{      \}}
\NormalTok{    )}
\NormalTok{  \}}
\NormalTok{  options <-}\StringTok{ }\KeywordTok{listRenderTags}\NormalTok{(options)}

\NormalTok{  message <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ id, }\DataTypeTok{options =}\NormalTok{ options)}
  \KeywordTok{sendCustomMessage}\NormalTok{(}\StringTok{"update-instance"}\NormalTok{, message, session)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

On the JS side, we receive the message, still in the \texttt{widget.js} script:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update-instance'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \CommentTok{// Treat message ...}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

All widgets are stored by type in the app data, for instance, the element having for unique id
\texttt{mygauge} is located in \texttt{app.data{[}"gauge"{]}{[}"mygauge"{]}}. As there is no easy way to recover the widget type
given its id, the first step of the message handler is to find where our instance is located. We design a
nested for loop. The outer loop scans all \texttt{app.data} properties (ie widget categories), while the inner loop
scans all existing instances for each category. Whenever, the \texttt{message.id} matches the instance
name, we store the corresponding widget category in a variable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ instanceFamily}\OperatorTok{;}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ property }\KeywordTok{in} \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{) }\OperatorTok{\{}
  \ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ e }\KeywordTok{in} \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[property]) }\OperatorTok{\{}
    \ControlFlowTok{if}\NormalTok{ (e }\OperatorTok{===} \VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{) }\OperatorTok{\{}
\NormalTok{      instanceFamily }\OperatorTok{=}\NormalTok{ property}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

We then access the old instance using the newly defined variable and the \texttt{message.id}.
We capture its parameters located in \texttt{oldInstance.params}. From there, multiple options are available:

\begin{itemize}
\tightlist
\item
  We extend the old configuration with the new one.
\item
  We entirely overwrite the existing options.
\end{itemize}

In what follows, we decided to merge the old and new configurations using \texttt{app.utils.extend}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ oldInstance }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[instanceFamily][}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{]}\OperatorTok{;}
\KeywordTok{var}\NormalTok{ oldConfig }\OperatorTok{=} \VariableTok{oldInstance}\NormalTok{.}\AttributeTok{params}\OperatorTok{;}
\KeywordTok{var}\NormalTok{ newConfig }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{utils}\NormalTok{.}\AttributeTok{extend}\NormalTok{(oldConfig}\OperatorTok{,}  \VariableTok{message}\NormalTok{.}\AttributeTok{options}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The next step consists in destroying the old instance, initializing the new instance and refreshing
the \texttt{app.data} cache:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Destroy old instance}
\VariableTok{oldInstance}\NormalTok{.}\AttributeTok{destroy}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Create new config}
\KeywordTok{var}\NormalTok{ newInstance }\OperatorTok{=}\NormalTok{ app[instanceFamily].}\AttributeTok{create}\NormalTok{(newConfig)}\OperatorTok{;}
\CommentTok{// Update app data}
\VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[instanceFamily][}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{] }\OperatorTok{=}\NormalTok{ newInstance}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The whole code is found below:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(}\StringTok{'update-instance'}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \CommentTok{// Recover in which array is stored the given instance.}
  \CommentTok{// Uniqueness is ensured since HTML id are supposed to be unique.}
  \KeywordTok{var}\NormalTok{ instanceFamily}\OperatorTok{;}
  \ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ property }\KeywordTok{in} \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{) }\OperatorTok{\{}
    \ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ e }\KeywordTok{in} \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[property]) }\OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ (e }\OperatorTok{===} \VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{) }\OperatorTok{\{}
\NormalTok{        instanceFamily }\OperatorTok{=}\NormalTok{ property}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}

  \KeywordTok{var}\NormalTok{ oldInstance }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[instanceFamily][}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{]}\OperatorTok{;}
  \KeywordTok{var}\NormalTok{ oldConfig }\OperatorTok{=} \VariableTok{oldInstance}\NormalTok{.}\AttributeTok{params}\OperatorTok{;}
  \KeywordTok{var}\NormalTok{ newConfig }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\VariableTok{utils}\NormalTok{.}\AttributeTok{extend}\NormalTok{(oldConfig}\OperatorTok{,}  \VariableTok{message}\NormalTok{.}\AttributeTok{options}\NormalTok{)}\OperatorTok{;}

  \CommentTok{// Destroy old instance}
  \VariableTok{oldInstance}\NormalTok{.}\AttributeTok{destroy}\NormalTok{()}\OperatorTok{;}
  \CommentTok{// Create new config}
  \KeywordTok{var}\NormalTok{ newInstance }\OperatorTok{=}\NormalTok{ app[instanceFamily].}\AttributeTok{create}\NormalTok{(newConfig)}\OperatorTok{;}
  \CommentTok{// Update app data}
  \VariableTok{app}\NormalTok{.}\AttributeTok{data}\NormalTok{[instanceFamily][}\VariableTok{message}\NormalTok{.}\AttributeTok{id}\NormalTok{] }\OperatorTok{=}\NormalTok{ newInstance}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The update concept is illustrated Figure \ref{fig:mobile-widget-store}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/mobile/mobile-widget-store} 

}

\caption{Initializing and updating widgets in the app.data store}\label{fig:mobile-widget-store}
\end{figure}

Below is an example showing how to update a gauge from the server. As you may notice, this
approach is not perfect as the user has to explicitly update the \texttt{valueText} field so that
it reflects the new value. Similarly, you may ask why the gauge value has to be between 0 and 1,
instead of 0 and 100. The reason comes from the Framework7 API. One might be tempted to convert the value inside \texttt{f7\_gauge} (so that the user only provides number between 0 and 100), but
this would also mean to manually convert the value in the \texttt{update\_f7\_instance} function later. As stated in previous chapters, there is always a compromise to do between a simple API easy to maintain (for the developer) and user experience. This issue may/should be solved by a comprehensive documentation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{f7_page}\NormalTok{(}
  \KeywordTok{f7_gauge}\NormalTok{(}
    \StringTok{"mygauge"}\NormalTok{, }
    \DataTypeTok{value =} \FloatTok{0.1}\NormalTok{,}
    \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{type  =} \StringTok{"semicircle"}\NormalTok{,}
      \DataTypeTok{borderColor =} \StringTok{"#2196f3"}\NormalTok{,}
      \DataTypeTok{borderWidth =} \DecValTok{10}\NormalTok{,}
      \DataTypeTok{valueFontSize =} \DecValTok{41}\NormalTok{,}
      \DataTypeTok{valueTextColor =} \StringTok{"#2196f3"}\NormalTok{,}
      \DataTypeTok{labelText =} \StringTok{"amount of something"}
\NormalTok{    )}
\NormalTok{  ),}
  \DataTypeTok{navbar =} \KeywordTok{f7_navbar}\NormalTok{(}\StringTok{"Title"}\NormalTok{),}
  \DataTypeTok{toolbar =} \KeywordTok{f7_toolbar}\NormalTok{(),}
  \DataTypeTok{title =} \StringTok{"shinyMobile"}\NormalTok{,}
  \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{theme =} \StringTok{"ios"}\NormalTok{,}
    \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{,}
    \DataTypeTok{taphold =} \OtherTok{TRUE}\NormalTok{,}
    \DataTypeTok{color =} \StringTok{"#42f5a1"}\NormalTok{,}
    \DataTypeTok{filled =} \OtherTok{TRUE}\NormalTok{,}
    \DataTypeTok{dark =} \OtherTok{TRUE}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(\{}
    \KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{2}\NormalTok{)}
    \KeywordTok{update_f7_instance}\NormalTok{(}
      \StringTok{"mygauge"}\NormalTok{, }
      \DataTypeTok{options =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{value =} \FloatTok{0.75}\NormalTok{, }
        \DataTypeTok{valueText =} \StringTok{"75 %"}\NormalTok{, }
        \DataTypeTok{labelText =} \StringTok{"New label!"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

Alternatively you may run in the R console:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{shinyAppDir}\NormalTok{(}\KeywordTok{system.file}\NormalTok{(}\StringTok{"shinyMobile/pwa"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"OSUICode"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{mobile-going-further}{%
\chapter{Going further}\label{mobile-going-further}}

\hypertarget{improved-disconnect-screen}{%
\section{Improved disconnect screen}\label{improved-disconnect-screen}}

As depicted on Figure \ref{fig:mobile-disconnect}, having the classic Shiny disconnect
screen in a mobile device is not that beautiful, especially knowing about all the Framework7
capabilities.

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/mobile/mobile-disconnect} 

}

\caption{Vanilla Shiny disconnect screen.}\label{fig:mobile-disconnect}
\end{figure}

Let's do better. Upon disconnection, we want to display a toast with 2 buttons:

\begin{itemize}
\tightlist
\item
  A reload button that reloads the window and re-initialize the app. This button
  calls \texttt{location.reload()} upon click.
\item
  A reconnect button, that tries to reconnect with the server websocket, so that
  we don't lose any input, output elements. This button calls \texttt{Shiny.shinyapp.reconnect()} upon click.
\end{itemize}

How do we know when shiny is disconnected? As described in Chapter \ref{shiny-intro},
whenever the client socket connection is closed, for any reason, the \texttt{shiny:disconnected} \href{https://shiny.rstudio.com/articles/js-events.html}{event} is raised:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{socket}\NormalTok{.}\AttributeTok{onclose} \OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// These things are needed only if we've successfully opened the}
  \CommentTok{// websocket.}
  \ControlFlowTok{if}\NormalTok{ (hasOpened) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(document).}\AttributeTok{trigger}\NormalTok{(}\OperatorTok{\{}
      \DataTypeTok{type}\OperatorTok{:} \StringTok{'shiny:disconnected'}\OperatorTok{,}
      \DataTypeTok{socket}\OperatorTok{:}\NormalTok{ socket}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

    \VariableTok{self}\NormalTok{.}\AttributeTok{$notifyDisconnected}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}

  \VariableTok{self}\NormalTok{.}\AttributeTok{onDisconnected}\NormalTok{()}\OperatorTok{;} \CommentTok{// Must be run before self.$removeSocket()}
  \VariableTok{self}\NormalTok{.}\AttributeTok{$removeSocket}\NormalTok{()}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This allows us to listen to that event on the JS side:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{on}\NormalTok{(}\StringTok{"shiny:disconnected"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \CommentTok{// Do things}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In the next step, we to remove the default shiny reconnect elements. They are inserted by the \texttt{onDisconnected} method, that adds a disconnect overlay (gray-out screen) and optionally a reconnect notification:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{this}\NormalTok{.}\AttributeTok{onDisconnected} \OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
  \CommentTok{// Add gray-out overlay, if not already present}
  \KeywordTok{var}\NormalTok{ $overlay }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#shiny-disconnected-overlay'}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (}\VariableTok{$overlay}\NormalTok{.}\AttributeTok{length} \OperatorTok{===} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
    \AttributeTok{$}\NormalTok{(}\VariableTok{document}\NormalTok{.}\AttributeTok{body}\NormalTok{).}\AttributeTok{append}\NormalTok{(}\StringTok{'<div id="shiny-disconnected-overlay"></div>'}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}

  \CommentTok{// To try a reconnect, both the app (this.$allowReconnect) and the}
  \CommentTok{// server (this.$socket.allowReconnect) must allow reconnections, or}
  \CommentTok{// session$allowReconnect("force") was called. The "force" option should}
  \CommentTok{// only be used for testing.}
  \ControlFlowTok{if}\NormalTok{ ((}\KeywordTok{this}\NormalTok{.}\AttributeTok{$allowReconnect} \OperatorTok{===} \KeywordTok{true} \OperatorTok{&&} \KeywordTok{this}\NormalTok{.}\VariableTok{$socket}\NormalTok{.}\AttributeTok{allowReconnect} \OperatorTok{===} \KeywordTok{true}\NormalTok{) }\OperatorTok{||}
      \KeywordTok{this}\NormalTok{.}\AttributeTok{$allowReconnect} \OperatorTok{===} \StringTok{"force"}\NormalTok{)}
  \OperatorTok{\{}
    \KeywordTok{var}\NormalTok{ delay }\OperatorTok{=} \VariableTok{reconnectDelay}\NormalTok{.}\AttributeTok{next}\NormalTok{()}\OperatorTok{;}
    \VariableTok{exports}\NormalTok{.}\AttributeTok{showReconnectDialog}\NormalTok{(delay)}\OperatorTok{;}
    \KeywordTok{this}\NormalTok{.}\AttributeTok{$scheduleReconnect}\NormalTok{(delay)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

To remove them, there are multiple alternatives. The easiest way is to wait
for the client to be connected, that is listening to \texttt{shiny:connected}, and set the \texttt{Shiny.shinyapp.onDisconnected} method to only add the gray overlay.

\begin{importantblock}
Before modifying any vanilla shiny elements, make sure to check all the possible
side effects!

\end{importantblock}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// remove shiny reconnect stuff;}
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{on}\NormalTok{(}\StringTok{"shiny:connected"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}
  \VariableTok{Shiny}\NormalTok{.}\VariableTok{shinyapp}\NormalTok{.}\AttributeTok{onDisconnected} \OperatorTok{=} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \CommentTok{// Add gray-out overlay, if not already present}
    \KeywordTok{let}\NormalTok{ $overlay }\OperatorTok{=} \AttributeTok{$}\NormalTok{(}\StringTok{'#shiny-disconnected-overlay'}\NormalTok{)}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (}\VariableTok{$overlay}\NormalTok{.}\AttributeTok{length} \OperatorTok{===} \DecValTok{0}\NormalTok{) }\OperatorTok{\{}
      \AttributeTok{$}\NormalTok{(}\VariableTok{document}\NormalTok{.}\AttributeTok{body}\NormalTok{).}\AttributeTok{append}\NormalTok{(}\StringTok{'<div id="shiny-disconnected-overlay"></div>'}\NormalTok{)}\OperatorTok{;}
    \OperatorTok{\}}
  \OperatorTok{\};}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We edit the previous disconnected event listener to add a custom Framework7 toast, which closes upon click:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(document).}\AttributeTok{on}\NormalTok{(}\StringTok{"shiny:disconnected"}\OperatorTok{,} \KeywordTok{function}\NormalTok{(event) }\OperatorTok{\{}    
  \KeywordTok{let}\NormalTok{ reconnectToast }\OperatorTok{=} \VariableTok{app}\NormalTok{.}\AttributeTok{toast}
\NormalTok{    .}\AttributeTok{create}\NormalTok{(}\OperatorTok{\{}
      \DataTypeTok{icon}\OperatorTok{:} \StringTok{'<i class="icon f7-icons">bolt_fill</i>'}\OperatorTok{,}
      \DataTypeTok{position}\OperatorTok{:} \StringTok{"center"}\OperatorTok{,}
      \DataTypeTok{text}\OperatorTok{:}
        \StringTok{'Oups... disconnected </br> </br> <div class="row"><button onclick="Shiny.shinyapp.reconnect();" class="toast-button button color-green col">Reconnect</button><button onclick="location.reload();" class="toast-button button color-red col">Reload</button></div>'}
    \OperatorTok{\}}\NormalTok{)}
\NormalTok{    .}\AttributeTok{open}\NormalTok{()}\OperatorTok{;}

  \CommentTok{// close toast whenever a choice is made ...}
  \AttributeTok{$}\NormalTok{(}\StringTok{".toast-button"}\NormalTok{).}\AttributeTok{on}\NormalTok{(}\StringTok{"click"}\OperatorTok{,} \KeywordTok{function}\NormalTok{() }\OperatorTok{\{}
    \VariableTok{reconnectToast}\NormalTok{.}\AttributeTok{close}\NormalTok{()}\OperatorTok{;}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Result is shown Figure \ref{fig:mobile-disconnect-custom}.

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/mobile/mobile-disconnect-custom} 

}

\caption{Vanilla Shiny disconnect screen.}\label{fig:mobile-disconnect-custom}
\end{figure}

The above JS code ignores the user reconnect \href{https://shiny.rstudio.com/articles/reconnecting.html}{setup} and proposes
to reconnect regardless of the \texttt{session\$allowReconnect} configuration. If you want to keep the original behavior, you may include the following condition before showing the toast:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ ((}\VariableTok{Shiny}\NormalTok{.}\VariableTok{shinyapp}\NormalTok{.}\AttributeTok{$allowReconnect} \OperatorTok{===} \KeywordTok{true} \OperatorTok{&&} \VariableTok{Shiny}\NormalTok{.}\VariableTok{shinyapp}\NormalTok{.}\VariableTok{$socket}\NormalTok{.}\AttributeTok{allowReconnect} \OperatorTok{===} \KeywordTok{true}\NormalTok{) }\OperatorTok{||}
      \VariableTok{Shiny}\NormalTok{.}\VariableTok{shinyapp}\NormalTok{.}\AttributeTok{$allowReconnect} \OperatorTok{===} \StringTok{"force"}\NormalTok{) }\OperatorTok{\{}
  \CommentTok{// Toast logic}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{part-going-further}{%
\part*{Going further}\label{part-going-further}}


In this part, we expose some tools to go even further.

\hypertarget{going-further-reactR}{%
\chapter{\texorpdfstring{R + Shiny + React: welcome \texttt{\{reactR\}}}{R + Shiny + React: welcome \{reactR\}}}\label{going-further-reactR}}

\href{https://reactjs.org/}{React} is an open source library designed to quickly develop user interfaces or UI components, on the front end.
It has been developed by \href{https://github.com/facebook/react}{Facebook} and the community (more than 1500 contributors)
and made public in May 29 2013. It is currently used worldwide and has around 163k stars on the
Github ranking and widely impacts the mobile market, through the \href{https://reactnative.dev/}{React Native} library.\\
React is also really convenient to develop attractive documentations with \href{https://v2.docusaurus.io/}{docusaurus}.
If you ever have built user interfaces with pure JS, you might like React!

Below, we give a short introduction to the React ecosystem and see how we can benefit from it from the
R Shiny side.

\hypertarget{quick-introduction-to-react}{%
\section{Quick introduction to React}\label{quick-introduction-to-react}}

To understand React there are few prerequisites notably basic HTML/CSS/JS knowledge, especially JS modules (see
section \ref{about-js-modules}). However, if you managed to reach this chapter, you should not worry too much.

\hypertarget{setup-1}{%
\subsection{Setup}\label{setup-1}}

\texttt{Node} and \texttt{npm} are required. If you are not sure, run:

\begin{verbatim}
node -v
npm -v
\end{verbatim}

At that stage it is also good to have \href{https://classic.yarnpkg.com/en/docs/install\#mac-stable}{\texttt{yarn}} as we'll need it for \texttt{\{reactR\}}.

If nothing is returned, please refer to section \ref{install-node}. To initiate a React \href{https://create-react-app.dev/}{project},
we leverage the \texttt{npx} command:

\begin{verbatim}
npx create-react-app <PROJECT_NAME>
\end{verbatim}

Replace \texttt{\textless{}PROJECT\_NAME\textgreater{}} by the real name of your project. If this seems intimidating,
keep in mind this is the same concept has using the \texttt{\{golem\}} \href{https://github.com/ThinkR-open/golem}{package}
to initiate the creation of robust shiny projects, except that we work from the terminal.

Once done (the package initialization takes some time),
move to the project folder and launch the demo app:

\begin{verbatim}
cd <PROJECT_NAME> && npm start
\end{verbatim}

If you have yarn, \texttt{yarn\ start} also works.

You should see something similar to Figure \ref{fig:basic-react-app}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/going-further/basic-react-app} \caption{npm start opens the react app}\label{fig:basic-react-app}
\end{figure}

\hypertarget{basics-1}{%
\subsection{Basics}\label{basics-1}}

We are now all set up to start learning the basics of React. Among all created files,
notice the \texttt{/src/app.js} file. Inside the \texttt{App} function, we remove all the content inside
the \texttt{return} statement to put a simple \texttt{\textless{}h1\textgreater{}Hello,\ world!\textless{}/h1\textgreater{}} HTML title. We also clean the imports
as we don't need any CSS and logo anymore. We obtain:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{App}\NormalTok{() }\OperatorTok{\{}
  \ControlFlowTok{return}\NormalTok{ (}
    \KeywordTok{<h1>}\NormalTok{Hello, world!}\KeywordTok{</h1>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}

\ImportTok{export} \ImportTok{default}\NormalTok{ App}\OperatorTok{;} \CommentTok{// don't remove, this is needed by index.js}
\end{Highlighting}
\end{Shaded}

Once done, we run \texttt{npm\ build} (or \texttt{yarn\ build}), to rebuild the JS code and \texttt{npm\ start} to
restart the server and preview the app. In practice, once the server is launched, there is
no need to restart it whenever the code is updated. A simple save will refresh the interface!

The code you see above is a React component. The definition is rather simple: it is a function that returns
a moreless complex piece of UI. How are components rendered by React?

So far, we didn't have a look at the \texttt{/src/index.js} script. Inside we find:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{ReactDOM}\NormalTok{.}\AttributeTok{render}\NormalTok{(}
\NormalTok{  App}\OperatorTok{,}
  \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{'root'}\NormalTok{)}
\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\textbf{Note}: recent version of \texttt{npx\ create-react-app} have \texttt{\textless{}React.StrictMode\textgreater{}\textless{}App\ /\textgreater{}\textless{}/React.StrictMode\textgreater{}} instead
of \texttt{App}, which does the same thing. You may also find \texttt{\textless{}App\ /\textgreater{}}. In practice, we rarely modify this part.

In short, this inserts the \texttt{App} component inside the element having \texttt{root} as id in the main
HTML page. This HTML skeleton may be found in the \texttt{public/index.html} folder. You may guess that at the end
of the day, our app will be composed of multiple bricks and called \texttt{ReactDOM.render} on the top level component.

\hypertarget{about-jsx}{%
\subsubsection{About JSX}\label{about-jsx}}

We just wrote our first React component. Didn't you notice something weird in that code?
JS and HTML are mixed, in what we called JSX, that is a syntax extension to JS. JSX makes the code
less verbose, for instance:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{React}\NormalTok{.}\AttributeTok{createElement}\NormalTok{(}
  \StringTok{'h1'}\OperatorTok{,}
  \StringTok{'Hello, world!'}
\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

does exactly the same thing as above but when the code becomes more complex, it is nearly
impossible to read.

Let's see how to pass variables into JSX. We want to show \texttt{Hello,\ \textless{}Your\ Name\textgreater{}}, we store
the name in a variable and modify the \texttt{app.js} code accordingly:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{App}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ name }\OperatorTok{=} \StringTok{"David"}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ (}
    \KeywordTok{<h1>}\NormalTok{Hello, }\VariableTok{\{}\NormalTok{name}\VariableTok{\}}\KeywordTok{</h1>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Expressions are passed within curly brackets \texttt{\{expression\}} and you may even call functions inside.

Tag attributes also require curly brackets. Let's modify the title tag to give it a color and
a size.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{App}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ name }\OperatorTok{=} \StringTok{"David"}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ (}
    \KeywordTok{<h1} \OtherTok{style}\OperatorTok{=}\VariableTok{\{}\NormalTok{color}\OperatorTok{:} \StringTok{"red"}\OperatorTok{,}\NormalTok{ fontSize}\OperatorTok{:} \DecValTok{40}\VariableTok{\}}\KeywordTok{>}\NormalTok{Hello, }\VariableTok{\{}\NormalTok{name}\VariableTok{\}}\KeywordTok{</h1>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try to save. Why does this fail? We can't pass multiple object properties inside a single \texttt{\{\}}.
We need either double brackets like \texttt{\{\{object\ properties:\ values,\ ...\}\}} or to store the object in
a variable before:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{App}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ name }\OperatorTok{=} \StringTok{"David"}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ (}
    \KeywordTok{<h1} \OtherTok{style}\OperatorTok{=}\VariableTok{\{}\OperatorTok{\{}\DataTypeTok{color}\OperatorTok{:} \StringTok{"red"}\OperatorTok{,} \DataTypeTok{fontSize}\OperatorTok{:} \DecValTok{40}\OperatorTok{\}}\VariableTok{\}}\KeywordTok{>}\NormalTok{Hello, }\VariableTok{\{}\NormalTok{name}\VariableTok{\}}\KeywordTok{</h1>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// OR}

\KeywordTok{function} \AttributeTok{App}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ name }\OperatorTok{=} \StringTok{"David"}\OperatorTok{;}
  \KeywordTok{const}\NormalTok{ myStyle }\OperatorTok{=} \OperatorTok{\{}
    \DataTypeTok{color}\OperatorTok{:} \StringTok{"red"}\OperatorTok{,} 
    \DataTypeTok{fontSize}\OperatorTok{:} \DecValTok{40}
  \OperatorTok{\}}
  \ControlFlowTok{return}\NormalTok{ (}
    \KeywordTok{<h1} \OtherTok{style}\OperatorTok{=}\VariableTok{\{}\NormalTok{myStyle}\VariableTok{\}}\KeywordTok{>}\NormalTok{Hello, }\VariableTok{\{}\NormalTok{name}\VariableTok{\}}\KeywordTok{</h1>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Notice that we write CSS properties following the camelCase syntax, \texttt{font-size} being equivalent to \texttt{fontSize}.

\hypertarget{combining-components}{%
\subsubsection{Combining components}\label{combining-components}}

The whole interest is to combine multiple components to create reusable pieces. We edit the above code
to create a \texttt{SayHello} component. Notice the \texttt{props} parameter. It is a way to pass configuration from the
parent component. In that case, we want to display the person name, that is \texttt{props.name}. In the meantime,
we edit the \texttt{App} parent component and call \texttt{SayHello} three times, passing a different name like \texttt{\textless{}SayHello\ name="David"\ /\textgreater{}} (this is the reason why we recover \texttt{props.name} in the lower level component):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{SayHello}\NormalTok{(props) }\OperatorTok{\{}
  \ControlFlowTok{return}\NormalTok{ (}
    \KeywordTok{<h1>}\NormalTok{Hello, }\VariableTok{\{props}\NormalTok{.}\AttributeTok{name}\VariableTok{\}}\KeywordTok{</h1>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}


\KeywordTok{function} \AttributeTok{App}\NormalTok{() }\OperatorTok{\{}
  \ControlFlowTok{return}\NormalTok{(}
  \KeywordTok{<>}
    \FunctionTok{<SayHello} \OtherTok{name}\OperatorTok{=}\StringTok{"David"} \FunctionTok{/>}
    \FunctionTok{<SayHello} \OtherTok{name}\OperatorTok{=}\StringTok{"Lisa"} \FunctionTok{/>}
    \FunctionTok{<SayHello} \OtherTok{name}\OperatorTok{=}\StringTok{"Simon"} \FunctionTok{/>}
  \KeywordTok{</>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Notice the enclosing \texttt{\textless{}\textgreater{}...\textless{}/\textgreater{}}. This is called a React fragment and useful if we don't want to
insert any extra \texttt{\textless{}div\textgreater{}} in the DOM.

We could be even more efficient by leveraging the lists capabilities. We create an array
of names and apply the \texttt{map} method to return the corresponding \texttt{\textless{}SayHello\ /\textgreater{}} sub-component:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ names }\OperatorTok{=}\NormalTok{ [}\StringTok{"David"}\OperatorTok{,} \StringTok{"Lisa"}\OperatorTok{,} \StringTok{"Simon"}\NormalTok{]}\OperatorTok{;}
\KeywordTok{function} \AttributeTok{App}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ sayHelloToAll }\OperatorTok{=} \VariableTok{names}\NormalTok{.}\AttributeTok{map}\NormalTok{((name) }\KeywordTok{=> }\FunctionTok{<SayHello} \OtherTok{key}\OperatorTok{=}\VariableTok{\{}\NormalTok{name}\VariableTok{\}} \OtherTok{name}\OperatorTok{=}\VariableTok{\{}\NormalTok{name}\VariableTok{\}} \FunctionTok{/>}\NormalTok{)}\OperatorTok{;} 
  \ControlFlowTok{return}\NormalTok{(sayHelloToAll)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

By convention, all elements inside a \texttt{map} require keys.

Props are \textbf{read-only} and must not be modified withing their own component.
How do we update components?

\hypertarget{component-state}{%
\subsubsection{Component state}\label{component-state}}

A component state is private and controlled by this same component. Since React 16.8 and the introduction of \textbf{hooks}, this is not necessary to convert the component function to a \href{https://reactjs.org/docs/components-and-props.html\#function-and-class-components}{class}.
The easiest example to illustrate hooks capabilities is the button. Each time, we click on a button,
we want to keep the current number of clicks in a state, like the \texttt{shiny::actionButton}. We start by
importing the \texttt{useState} function from \texttt{react} and create a new \texttt{ActionButton} component.
Inside, we set the state with \texttt{useState} that create the state variable \texttt{count} as well as the function to
update it, namely \texttt{setCount}. This way to create 2 variables at once is called array destructuring.
We set the initial number of counts to 0:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \OperatorTok{\{}\NormalTok{useState}\OperatorTok{\}} \ImportTok{from} \StringTok{'react'}\OperatorTok{;}

\KeywordTok{function} \AttributeTok{ActionButton}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ [count}\OperatorTok{,}\NormalTok{ setCount] }\OperatorTok{=} \AttributeTok{useState}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Next step is to create the button skeleton. We provide an \texttt{onClick} property that updates
the button state.Inside, we write an anonymous function which calls \texttt{setCount} and increment
the count value by 1. At this point, you may replace the \texttt{app.js} content by:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \OperatorTok{\{}\NormalTok{useState}\OperatorTok{\}} \ImportTok{from} \StringTok{'react'}\OperatorTok{;}

\KeywordTok{function} \AttributeTok{ActionButton}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ [count}\OperatorTok{,}\NormalTok{ setCount] }\OperatorTok{=} \AttributeTok{useState}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{(}
    \KeywordTok{<button} \OtherTok{onClick}\OperatorTok{=}\VariableTok{\{}\NormalTok{() }\KeywordTok{=>} \AttributeTok{setCount}\NormalTok{(count }\OperatorTok{+} \DecValTok{1}\NormalTok{)}\VariableTok{\}}\KeywordTok{>}
\NormalTok{      Number of clicks: }\VariableTok{\{}\NormalTok{count}\VariableTok{\}}
    \KeywordTok{</button} \KeywordTok{>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{function} \AttributeTok{App}\NormalTok{() }\OperatorTok{\{}
  \ControlFlowTok{return}\NormalTok{ (}
    \FunctionTok{<ActionButton} \FunctionTok{/>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}

\ImportTok{export} \ImportTok{default}\NormalTok{ App}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We may improve the previous app and add a reset button within the \texttt{ActionButton} component that
sets the count back to 0:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{ActionButton}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ [count}\OperatorTok{,}\NormalTok{ setCount] }\OperatorTok{=} \AttributeTok{useState}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{(}
    \KeywordTok{<>}
    \KeywordTok{<button} \OtherTok{onClick}\OperatorTok{=}\VariableTok{\{}\NormalTok{() }\KeywordTok{=>} \AttributeTok{setCount}\NormalTok{(count }\OperatorTok{+} \DecValTok{1}\NormalTok{)}\VariableTok{\}}\KeywordTok{>}
\NormalTok{      Number of clicks: }\VariableTok{\{}\NormalTok{count}\VariableTok{\}}
    \KeywordTok{</button} \KeywordTok{>}
    \KeywordTok{<button} \OtherTok{onClick}\OperatorTok{=}\VariableTok{\{}\NormalTok{() }\KeywordTok{=>} \AttributeTok{setCount}\NormalTok{(}\DecValTok{0}\NormalTok{)}\VariableTok{\}}\KeywordTok{>}
\NormalTok{      Reset}
    \KeywordTok{</button} \KeywordTok{>}
    \KeywordTok{</>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

It would make more sense to only show the reset button once the button has been clicked,
at least once. We define the \texttt{isResetVisible} variable which is \texttt{true} whenever the
count is higher than 0 and \texttt{false} if the count is 0. We store the reset button in a variable
and only return something if \texttt{isResetVisible} is \texttt{true}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{ActionButton}\NormalTok{() }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ [count}\OperatorTok{,}\NormalTok{ setCount] }\OperatorTok{=} \AttributeTok{useState}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{const}\NormalTok{ isResetVisible }\OperatorTok{=}\NormalTok{ count }\OperatorTok{>} \DecValTok{0} \OperatorTok{?} \DataTypeTok{true }\OperatorTok{:} \KeywordTok{false}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ resetButton}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (isResetVisible) }\OperatorTok{\{}
\NormalTok{    resetButton }\OperatorTok{= }\KeywordTok{<button} \OtherTok{onClick}\OperatorTok{=}\VariableTok{\{}\NormalTok{() }\KeywordTok{=>} \AttributeTok{setCount}\NormalTok{(}\DecValTok{0}\NormalTok{)}\VariableTok{\}}\KeywordTok{>}
\NormalTok{      Reset}
    \KeywordTok{</button} \KeywordTok{>}
  \OperatorTok{\}}
  \ControlFlowTok{return}\NormalTok{ (}
    \KeywordTok{<>}
      \KeywordTok{<button} \OtherTok{onClick}\OperatorTok{=}\VariableTok{\{}\NormalTok{() }\KeywordTok{=>} \AttributeTok{setCount}\NormalTok{(count }\OperatorTok{+} \DecValTok{1}\NormalTok{)}\VariableTok{\}}\KeywordTok{>}
\NormalTok{        Number of clicks: }\VariableTok{\{}\NormalTok{count}\VariableTok{\}}
      \KeywordTok{</button} \KeywordTok{>}
      \VariableTok{\{}\NormalTok{resetButton}\VariableTok{\}}
    \KeywordTok{</>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now that you get a better understanding of how React works, let's see how to use it with
Shiny.

\hypertarget{introduction-to-reactr}{%
\section{\texorpdfstring{Introduction to \texttt{\{reactR\}}}{Introduction to \{reactR\}}}\label{introduction-to-reactr}}

The React ecosystem is rich and provides many plug and play boilerplate. For instance,
\texttt{\{reactable\}} is an HTML widget developed on top of the \href{https://github.com/tannerlinsley/react-table}{\texttt{react-table}} library. What about the modern React Argon design \href{https://demos.creative-tim.com/argon-design-system-react/?_ga=2.179634850.760978196.1612189904-282783983.1612189904\#/}{system}, shown Figure \ref{fig:argon-design-react}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/going-further/argon-design-react} \caption{Argon design template with React}\label{fig:argon-design-react}
\end{figure}

In this part, we see how to leverage \texttt{\{reactR\}} to bring Argon design React to Shiny.

To install \texttt{\{reactR\}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"reactR"}\NormalTok{)}
\NormalTok{remotes}\OperatorTok{::}\KeywordTok{install_github}\NormalTok{(}\StringTok{"react-R/reactR"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{scaffold-inputs}{%
\subsection{Scaffold inputs}\label{scaffold-inputs}}

\hypertarget{setup-2}{%
\subsubsection{Setup}\label{setup-2}}

\texttt{\{reactR\}} exposes the \texttt{scaffoldReactShinyInput} that creates the necessary pieces of code
to get started with the input development (see Figure \ref{fig:reactR-init-input}):

\begin{itemize}
\tightlist
\item
  An \texttt{\textless{}input\_name\textgreater{}.R} file containing the input skeleton as well as its related update function.
  It also creates a custom HTML dependency pointing to the input JS logic.
\item
  A \texttt{jsx} file with a boilerplate to start developing the input JS logic.
\item
  A \texttt{package.json} file containing dependencies.
\end{itemize}

Besides, providing an optional dependency with a name and version taken from npm installs
all necessary dependencies in the \texttt{package.json} file.

In our case, we want to build on top of Argon from \href{https://www.npmjs.com/package/argon-design-system-react}{here}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{path <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"mypkg"}\NormalTok{)}
\NormalTok{usethis}\OperatorTok{::}\KeywordTok{create_package}\NormalTok{(path, }\DataTypeTok{rstudio =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{reactR}\OperatorTok{::}\KeywordTok{scaffoldReactShinyInput}\NormalTok{(}\StringTok{"argon_action_button"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}\DataTypeTok{name =} \StringTok{"argon-design-system-react"}\NormalTok{, }\DataTypeTok{version =} \StringTok{"1.1.0"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=1\linewidth]{images/going-further/reactR-init-input} \caption{Package initialization with {reactR}}\label{fig:reactR-init-input}
\end{figure}

Note that \texttt{\{reactR\}} provides \texttt{webpack} as JS manager. To build the JS code we go to the RStudio
terminal tab (or any terminal) and run at the package root:

\begin{verbatim}
yarn install
yarn run webpack
\end{verbatim}

This installs all dependencies listed in the \texttt{package.json} file and create a \texttt{package-lock.json} file. If you ever used \texttt{\{renv\}}, this is very similar and guarantees isolation of your package. All dependencies are stored in the \texttt{node\_modules} folder.

\textbf{Note}: I encountered few cases where the \texttt{yarn\ install} failed. In that case, you may
try \texttt{npm\ i\ argon-design-system-react} and also check your VPN settings.

The \texttt{run\ webpack} command triggers compiles the JS in production ready code. Should you need to customize the build pipeline, the webpack configuration is located in \texttt{webpack.config.js}. On the R side, the generated JS file is referenced in an HTML dependencies, located in the \texttt{\textless{}input\_name\textgreater{}.R} file.

\hypertarget{implement-the-input-js-logic}{%
\subsubsection{Implement the input JS logic}\label{implement-the-input-js-logic}}

It's time to develop the logic. The Argon documentation provides a \href{https://demos.creative-tim.com/argon-design-system-react/?_ga=2.179634850.760978196.1612189904-282783983.1612189904\#/documentation/buttons}{boilerplate}, which we slightly simplified, as show below:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \OperatorTok{\{}\NormalTok{ reactShinyInput }\OperatorTok{\}} \ImportTok{from} \StringTok{'reactR'}\OperatorTok{;}
\CommentTok{// reactstrap components}
\ImportTok{import} \OperatorTok{\{}\NormalTok{ Button }\OperatorTok{\}} \ImportTok{from} \StringTok{"reactstrap"}\OperatorTok{;}

\KeywordTok{function} \AttributeTok{ArgonButton}\NormalTok{() }\OperatorTok{\{}
  \ControlFlowTok{return}\NormalTok{ (}
    \FunctionTok{<Button} \OtherTok{color}\OperatorTok{=}\StringTok{"primary"} \OtherTok{type}\OperatorTok{=}\StringTok{"button"}\FunctionTok{>}
\NormalTok{      Button}
    \FunctionTok{</Button>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}

\AttributeTok{reactShinyInput}\NormalTok{(}\StringTok{'.argon_action_button'}\OperatorTok{,} \StringTok{'mypkg.argon_action_button'}\OperatorTok{,}\NormalTok{ ArgonButton)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Notice the first two lines where we import the \texttt{reactShinyInput} function from the \texttt{\{reactR\}} JS core and \href{https://reactstrap.github.io/}{\texttt{reactstrap}}, a React powered Bootstrap 4 library. \texttt{reactShinyInput} provides
a wrapper to automatically bind the input element. This is extremely convenient as it allows to solely focus on the component logic rather than binding it to the shiny system. It takes three parameters:

\begin{itemize}
\tightlist
\item
  The element class which is obtained from the R side by \texttt{createReactShinyInput}.
\item
  The input binding name which is useful to store a reference in the \texttt{Shiny.InputBindings} registry.
\item
  The React component function.
\item
  There is an optional fourth parameter allowing to pass custom options like
  rate \href{https://github.com/react-R/reactR/blob/master/srcjs/input.js\#L137}{policies}.
\end{itemize}

Overall, \href{https://github.com/react-R/reactR/blob/master/srcjs/input.js\#L72}{\texttt{reactShinyInput}} extends the \texttt{Shiny.InputBinding} class by providing extra methods like:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{getInputConfiguration}\NormalTok{(el) }\OperatorTok{\{}
  \ControlFlowTok{return} \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'configuration'}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\AttributeTok{setInputConfiguration}\NormalTok{(el}\OperatorTok{,}\NormalTok{ configuration) }\OperatorTok{\{}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'configuration'}\OperatorTok{,}\NormalTok{ configuration)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{getInputConfiguration} and \texttt{setInputConfiguration}, respectively get and set the user provided configuration,
passed in the \texttt{createReactShinyInput} R side function. Under the hood, in addition to ship the \texttt{\{reactR\}}, React, ReactTools HTML dependencies (and any user defined custom dependency), \texttt{createReactShinyInput} does generate
three tag elements:

\begin{itemize}
\tightlist
\item
  The first tag is the element placeholder containing the unique id. React will insert
  the component inside this target with \texttt{ReactDOM.render}.
\item
  The second tag is a script containing the value passed as JSON.
\item
  The second tag is a script containing the configuration, also passed as JSON.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reactR}\OperatorTok{::}\KeywordTok{createReactShinyInput}\NormalTok{(}
  \DataTypeTok{inputId =} \StringTok{"plop"}\NormalTok{, }
  \DataTypeTok{class =} \StringTok{"myinput"}\NormalTok{, }
  \DataTypeTok{dependencies =}\NormalTok{ htmltools}\OperatorTok{::}\KeywordTok{findDependencies}\NormalTok{(}\KeywordTok{icon}\NormalTok{(}\StringTok{"bicycle"}\NormalTok{)), }
  \DataTypeTok{default =} \DecValTok{0}\NormalTok{, }
  \DataTypeTok{configuration =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \StringTok{"test"}\NormalTok{), }
  \DataTypeTok{container =}\NormalTok{ div}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The configuration and values are processed in the \texttt{initialize} method, which is a great place since it is
called before the input is bound:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'value'}\OperatorTok{,} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\AttributeTok{$}\NormalTok{(el).}\AttributeTok{next}\NormalTok{().}\AttributeTok{text}\NormalTok{()))}\OperatorTok{;}
\AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'configuration'}\OperatorTok{,} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\AttributeTok{$}\NormalTok{(el).}\AttributeTok{next}\NormalTok{().}\AttributeTok{next}\NormalTok{().}\AttributeTok{text}\NormalTok{()))}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

They are stored in the corresponding data attributes. The most important part is the \texttt{render} method that
creates the React element , based upon its configuration, value and renders it in the DOM:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{render}\NormalTok{(el) }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ element }\OperatorTok{=} \VariableTok{React}\NormalTok{.}\AttributeTok{createElement}\NormalTok{(component}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{configuration}\OperatorTok{:} \KeywordTok{this}\NormalTok{.}\AttributeTok{getInputConfiguration}\NormalTok{(el)}\OperatorTok{,}
    \DataTypeTok{value}\OperatorTok{:} \KeywordTok{this}\NormalTok{.}\AttributeTok{getValue}\NormalTok{(el)}\OperatorTok{,}
    \DataTypeTok{setValue}\OperatorTok{:} \KeywordTok{this}\NormalTok{.}\VariableTok{setValue}\NormalTok{.}\AttributeTok{bind}\NormalTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ el)}\OperatorTok{,}
    \DataTypeTok{el}\OperatorTok{:}\NormalTok{ el}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \VariableTok{ReactDOM}\NormalTok{.}\AttributeTok{render}\NormalTok{(element}\OperatorTok{,}\NormalTok{ el)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{render} method is called once inside \texttt{subscribe} and also each time the element is updated
with \texttt{receiveMessage}.

Interestingly, \texttt{setValue} is made available to the React component. For the action button case, it is called each time the \texttt{onClick} event is triggered, that is each time the user clicks on the button. This is the only way to update its value since it is not accessible to the user through \texttt{update\_argon\_action\_button}. Other inputs like \texttt{textInput} have the \texttt{onChange} event, triggered each time the text field is updated. The value may also be updated
by the user with \texttt{updateTextInput}. Consequently, there is no general rule and the situation may
vary from an input to another!

For now, let's just erase the \texttt{\{creatR\}} boilerplate (\texttt{argon\_action\_button.jsx}) with the above code an recompile with \texttt{yarn\ run\ webpack}. We also have to tell Shiny we want to
use Bootstrap 4 instead of Bootstrap 3, through the \texttt{bslib::bs\_theme} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{document}\NormalTok{()}
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load_all}\NormalTok{()}
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{library}\NormalTok{(mypkg)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{theme =}\NormalTok{ bslib}\OperatorTok{::}\KeywordTok{bs_theme}\NormalTok{(}\DataTypeTok{version =} \StringTok{"4"}\NormalTok{),}
  \KeywordTok{argon_action_button}\NormalTok{(}\StringTok{"plop"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The button is looking good but not really like in the Argon design system. Indeed, we forgot to import
the argon CSS assets. Add this code to the \texttt{argon\_action\_button.jsx}:

\begin{verbatim}
import "argon-design-system-react/src/assets/css/argon-design-system-react.min.css";
\end{verbatim}

We have to tell webpack how to load the CSS by adding a missing rule to the provided
\texttt{webpack.config.js}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rules}\OperatorTok{:}\NormalTok{ [}
  \OperatorTok{\{}
      \DataTypeTok{test}\OperatorTok{:} \SpecialStringTok{/}\SpecialCharTok{\textbackslash{}.}\SpecialStringTok{jsx}\SpecialCharTok{?$}\SpecialStringTok{/}\OperatorTok{,}
      \DataTypeTok{loader}\OperatorTok{:} \StringTok{'babel-loader'}\OperatorTok{,}
      \DataTypeTok{options}\OperatorTok{:} \OperatorTok{\{}
          \DataTypeTok{presets}\OperatorTok{:}\NormalTok{ [}\StringTok{'@babel/preset-env'}\OperatorTok{,} \StringTok{'@babel/preset-react'}\NormalTok{]}
      \OperatorTok{\}}
  \OperatorTok{\},}
  \CommentTok{// For CSS so that import "path/style.css"; works}
  \OperatorTok{\{}
      \DataTypeTok{test}\OperatorTok{:} \SpecialStringTok{/}\SpecialCharTok{\textbackslash{}.}\SpecialStringTok{css}\SpecialCharTok{$}\SpecialStringTok{/}\OperatorTok{,}
      \DataTypeTok{use}\OperatorTok{:}\NormalTok{ [}\StringTok{'style-loader'}\OperatorTok{,} \StringTok{'css-loader'}\NormalTok{]}
  \OperatorTok{\}}
\NormalTok{]}
\end{Highlighting}
\end{Shaded}

It is possible that you don't have the corresponding node modules. In that case,
you can install them with:

\begin{verbatim}
npm install style-loader css-loader --save-dev
\end{verbatim}

which will also update the \texttt{package.json} file.

Once updated, we recompile the code. The next part of this tutorial consists in making the button interactive.
We edit the \texttt{argon\_action\_button.jsx} code to add three input parameters in the
\texttt{ArgonButton} component:

\begin{itemize}
\tightlist
\item
  \textbf{value} is the button count. The initial value is provided by the \texttt{default} slot on the R side (see below).
\item
  \textbf{configuration} contains various user provided properties like the color status, outline style, \ldots{}
\item
  \textbf{setValue} is a way to increment the button value. Letting \texttt{setValue(value\ +\ 1)},
  ensures to increment the button value by 1 unit each click.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \OperatorTok{\{}\NormalTok{ reactShinyInput }\OperatorTok{\}} \ImportTok{from} \StringTok{'reactR'}\OperatorTok{;}
\CommentTok{// reactstrap components}
\ImportTok{import} \OperatorTok{\{}\NormalTok{ Button }\OperatorTok{\}} \ImportTok{from} \StringTok{"reactstrap"}\OperatorTok{;}
\CommentTok{// Import argon CSS}
\ImportTok{import} \StringTok{"argon-design-system-react/src/assets/css/argon-design-system-react.min.css"}\OperatorTok{;}

\KeywordTok{function} \AttributeTok{ArgonButton}\NormalTok{(}\OperatorTok{\{}\NormalTok{configuration}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ setValue}\OperatorTok{\}}\NormalTok{) }\OperatorTok{\{}
  \ControlFlowTok{return}\NormalTok{ (}
    \FunctionTok{<Button} \OtherTok{color}\OperatorTok{=}\VariableTok{\{configuration}\NormalTok{.}\AttributeTok{status}\VariableTok{\}} \OtherTok{type}\OperatorTok{=}\StringTok{"button"} \OtherTok{onClick}\OperatorTok{=}\VariableTok{\{}\NormalTok{() }\KeywordTok{=>} \AttributeTok{setValue}\NormalTok{(value }\OperatorTok{+} \DecValTok{1}\NormalTok{)}\VariableTok{\}}\FunctionTok{>}
      \VariableTok{\{configuration}\NormalTok{.}\AttributeTok{label}\VariableTok{\}}
    \FunctionTok{</Button>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}

\AttributeTok{reactShinyInput}\NormalTok{(}\StringTok{'.argon_action_button'}\OperatorTok{,} \StringTok{'mypkg.argon_action_button'}\OperatorTok{,}\NormalTok{ ArgonButton)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

On the R side, we remove the \texttt{default} parameter from the external API but keep it internally to
set the initial value to 0, like for \texttt{shiny::actionButton}. Status and label are stored
in the configuration named list. Be careful! Names matter since they are recovered on the JS side
with \texttt{configuration.prop\_name}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{argon_action_button <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, label, }\DataTypeTok{status =} \StringTok{"primary"}\NormalTok{) \{}
\NormalTok{  reactR}\OperatorTok{::}\KeywordTok{createReactShinyInput}\NormalTok{(}
\NormalTok{    inputId,}
    \StringTok{"argon_action_button"}\NormalTok{,}
\NormalTok{    htmltools}\OperatorTok{::}\KeywordTok{htmlDependency}\NormalTok{(}
      \DataTypeTok{name =} \StringTok{"argon_action_button-input"}\NormalTok{,}
      \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{,}
      \DataTypeTok{src =} \StringTok{"www/mypkg/argon_action_button"}\NormalTok{,}
      \DataTypeTok{package =} \StringTok{"mypkg"}\NormalTok{,}
      \DataTypeTok{script =} \StringTok{"argon_action_button.js"}
\NormalTok{    ),}
    \DataTypeTok{default =} \DecValTok{0}\NormalTok{,}
    \DataTypeTok{configuration =} \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{label =}\NormalTok{ label,}
      \DataTypeTok{status =}\NormalTok{ status}
\NormalTok{    ),}
\NormalTok{    htmltools}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\NormalTok{div}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Once everything is up to date, we rebuild the JS, reload/document the package and run the app demo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{theme =}\NormalTok{ bslib}\OperatorTok{::}\KeywordTok{bs_theme}\NormalTok{(}\DataTypeTok{version =} \StringTok{"4"}\NormalTok{),}
  \KeywordTok{argon_action_button}\NormalTok{(}\StringTok{"plop"}\NormalTok{, }\StringTok{"Click me!"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(}\KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{plop))}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

We may also modify the update input boilerplate since we don't change the button value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{update_argon_action_button <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(session, inputId, }\DataTypeTok{configuration =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(configuration)) message}\OperatorTok{$}\NormalTok{configuration <-}\StringTok{ }\NormalTok{configuration}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendInputMessage}\NormalTok{(inputId, message);}
\NormalTok{\}}

\NormalTok{devtools}\OperatorTok{::}\KeywordTok{document}\NormalTok{()}
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load_all}\NormalTok{()}
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{theme =}\NormalTok{ bslib}\OperatorTok{::}\KeywordTok{bs_theme}\NormalTok{(}\DataTypeTok{version =} \StringTok{"4"}\NormalTok{),}
  \KeywordTok{fluidRow}\NormalTok{(}
    \KeywordTok{argon_action_button}\NormalTok{(}\StringTok{"plop"}\NormalTok{, }\StringTok{"Click me!"}\NormalTok{),}
    \KeywordTok{argon_action_button}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Update button 1"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(}\KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{plop))}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
    \KeywordTok{update_argon_action_button}\NormalTok{(}
\NormalTok{      session, }\StringTok{"plop"}\NormalTok{, }
      \DataTypeTok{configuration =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{label =} \StringTok{"New text"}\NormalTok{, }
        \DataTypeTok{status =} \StringTok{"success"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  \}, }\DataTypeTok{ignoreInit =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercise-1}{%
\subsubsection{Exercise}\label{exercise-1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a \texttt{size}, \texttt{outline} and \texttt{icon} (from fontawesome) parameters to the \texttt{ArgonButton} component in the corresponding R script.
  Hint: the \texttt{icon} parameter is the trickiest one. You might find helpful to capture its HTML dependency with \texttt{htmltools::htmlDependencies(iconTag)} so as to properly render it. In HTML \texttt{icon("bicycle")} produces \texttt{\textless{}i\ class="fa\ fa-bicycle"\ role="presentation"\ aria-label="bicycle\ icon"\textgreater{}\textless{}/i\textgreater{}}. However, in React we want \texttt{\textless{}i\ className="fa\ fa-bicycle\ /\textgreater{}}. Therefore, you will have to extract the icon class and send it to JS in the configuration list.
\item
  Implement the logic on the JS side. Hint: you may use the below code:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \OperatorTok{\{}\NormalTok{ reactShinyInput }\OperatorTok{\}} \ImportTok{from} \StringTok{'reactR'}\OperatorTok{;}
\CommentTok{// reactstrap components}
\ImportTok{import} \OperatorTok{\{}\NormalTok{ Button }\OperatorTok{\}} \ImportTok{from} \StringTok{"reactstrap"}\OperatorTok{;}
\CommentTok{// import argon CSS}
\ImportTok{import} \StringTok{"argon-design-system-react/src/assets/css/argon-design-system-react.min.css"}\OperatorTok{;}

\KeywordTok{function} \AttributeTok{ArgonButton}\NormalTok{(}\OperatorTok{\{}\NormalTok{configuration}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ setValue}\OperatorTok{\}}\NormalTok{) }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ iconTag}\OperatorTok{,}\NormalTok{ btnCl}\OperatorTok{,}\NormalTok{ innerTag}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (...) }\OperatorTok{\{}
\NormalTok{    btnCl }\OperatorTok{=} \StringTok{"btn-icon"}\OperatorTok{;}
\NormalTok{    innerTag }\OperatorTok{= }\KeywordTok{<>}
      \KeywordTok{<span} \OtherTok{className}\OperatorTok{=}\StringTok{"btn-inner--icon"}\KeywordTok{>}
        \KeywordTok{<i} \OtherTok{className}\OperatorTok{=}\ErrorTok{...} \KeywordTok{/>}
      \KeywordTok{</span>}
      \KeywordTok{<span} \OtherTok{className}\OperatorTok{=}\StringTok{"btn-inner--text"}\KeywordTok{>}\NormalTok{...}\KeywordTok{</span>}
    \KeywordTok{</>}\OperatorTok{;}
  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    innerTag }\OperatorTok{=} \VariableTok{configuration}\NormalTok{.}\AttributeTok{label}\OperatorTok{;}
  \OperatorTok{\}}

  \KeywordTok{let}\NormalTok{ outlined}\OperatorTok{;}
  \ControlFlowTok{if}\NormalTok{ (...) }\OperatorTok{\{}
\NormalTok{    outlined }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
  \OperatorTok{\}}

  \ControlFlowTok{return}\NormalTok{ (}
    \FunctionTok{<Button}
      \OtherTok{color}\OperatorTok{=}\VariableTok{\{configuration}\NormalTok{.}\AttributeTok{status}\VariableTok{\}}
      \OtherTok{type}\OperatorTok{=}\StringTok{"button"}
      \OtherTok{className}\OperatorTok{=}\ErrorTok{...}
      \ErrorTok{outline=...}
      \ErrorTok{size=...}
      \ErrorTok{onClick=}\VariableTok{\{}\NormalTok{() }\KeywordTok{=>} \AttributeTok{setValue}\NormalTok{(value }\OperatorTok{+} \DecValTok{1}\NormalTok{)}\VariableTok{\}}\FunctionTok{>}
      \VariableTok{\{}\NormalTok{innerTag}\VariableTok{\}}
    \FunctionTok{</Button>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}

\AttributeTok{reactShinyInput}\NormalTok{(}\StringTok{'.argon_action_button'}\OperatorTok{,} \StringTok{'mypkg.argon_action_button'}\OperatorTok{,}\NormalTok{ ArgonButton)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Try your code with:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{library}\NormalTok{(mypkg)}

\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{theme =}\NormalTok{ bslib}\OperatorTok{::}\KeywordTok{bs_theme}\NormalTok{(}\DataTypeTok{version =} \StringTok{"4"}\NormalTok{),}
  \KeywordTok{fluidRow}\NormalTok{(}
    \KeywordTok{argon_action_button}\NormalTok{(}\StringTok{"plop"}\NormalTok{, }\StringTok{"Click me!"}\NormalTok{, }\DataTypeTok{size =} \StringTok{"lg"}\NormalTok{, }\DataTypeTok{outline =} \OtherTok{TRUE}\NormalTok{),}
    \KeywordTok{argon_action_button}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Update button 1"}\NormalTok{, }\DataTypeTok{icon =} \KeywordTok{icon}\NormalTok{(}\StringTok{"bicycle"}\NormalTok{))}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(}\KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{plop))}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
    \KeywordTok{update_argon_action_button}\NormalTok{(}
\NormalTok{      session, }\StringTok{"plop"}\NormalTok{, }
      \DataTypeTok{configuration =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{label =} \StringTok{"New text"}\NormalTok{, }
        \DataTypeTok{status =} \StringTok{"success"}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  \}, }\DataTypeTok{ignoreInit =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

You should get the result shown Figure \ref{fig:react-action-button}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/going-further/react-action-button} \caption{Argon Action button with React}\label{fig:react-action-button}
\end{figure}

\hypertarget{example-2-a-slider-input}{%
\subsubsection{Example 2: a slider input}\label{example-2-a-slider-input}}

Below we propose a preliminary implementation of the Argon slider input. The \href{https://demos.creative-tim.com/argon-design-system-react/?_ga=2.179634850.760978196.1612189904-282783983.1612189904\#/documentation/forms}{documentation} provides a JSX skeleton:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}\CommentTok{/* Simple slider */}\OperatorTok{\}}
\KeywordTok{<div} \OtherTok{className}\OperatorTok{=}\StringTok{"input-slider-container"}\KeywordTok{>}
  \KeywordTok{<div} \OtherTok{className}\OperatorTok{=}\StringTok{"slider"} \OtherTok{ref}\OperatorTok{=}\StringTok{"slider1"} \KeywordTok{/>}
  \FunctionTok{<Row} \OtherTok{className}\OperatorTok{=}\StringTok{"mt-3 d-none"}\FunctionTok{>}
    \FunctionTok{<Col} \OtherTok{xs}\OperatorTok{=}\StringTok{"6"}\FunctionTok{>}
      \KeywordTok{<span} \OtherTok{className}\OperatorTok{=}\StringTok{"range-slider-value"}\KeywordTok{>}
        \VariableTok{\{}\KeywordTok{this}\NormalTok{.}\VariableTok{state}\NormalTok{.}\AttributeTok{simpleValue}\VariableTok{\}}
      \KeywordTok{</span>}
    \FunctionTok{</Col>}
  \FunctionTok{</Row>}
\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

The slider JS API is actually taken from the well known \href{https://refreshless.com/nouislider/}{noUiSlider} library and is already available in the package node modules. Still in the same package as the action button input, we can call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reactR}\OperatorTok{::}\KeywordTok{scaffoldReactShinyInput}\NormalTok{(}\StringTok{"argon_slider"}\NormalTok{, }\DataTypeTok{edit =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

It creates a new \texttt{srcjs/argon\_slider.jsx} script. As Argon uses the pure JS API for noUIslider,
this would be too much work for us mainly because the provided \texttt{reactShinyInput} JS helper does not have a proper initialization method to create the slider instance. We would have to change it as per below:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{initialize}\NormalTok{(el) }\OperatorTok{\{}
  \CommentTok{// Unchanged compared to reactR}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'value'}\OperatorTok{,} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\AttributeTok{$}\NormalTok{(el).}\AttributeTok{next}\NormalTok{().}\AttributeTok{text}\NormalTok{()))}\OperatorTok{;}
  \AttributeTok{$}\NormalTok{(el).}\AttributeTok{data}\NormalTok{(}\StringTok{'configuration'}\OperatorTok{,} \VariableTok{JSON}\NormalTok{.}\AttributeTok{parse}\NormalTok{(}\AttributeTok{$}\NormalTok{(el).}\AttributeTok{next}\NormalTok{().}\AttributeTok{next}\NormalTok{().}\AttributeTok{text}\NormalTok{()))}\OperatorTok{;}
  
  \CommentTok{// Create the slider instance }
\NormalTok{  self }\OperatorTok{=} \KeywordTok{this}\OperatorTok{;}
  \VariableTok{Slider}\NormalTok{.}\AttributeTok{create}\NormalTok{(}\AttributeTok{$}\NormalTok{(el).}\AttributeTok{attr}\NormalTok{(id)}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{start}\OperatorTok{:} \VariableTok{self}\NormalTok{.}\AttributeTok{getInputValue}\NormalTok{(el)}\OperatorTok{,}
    \DataTypeTok{connect}\OperatorTok{:}\NormalTok{ [}\KeywordTok{true}\OperatorTok{,} \KeywordTok{false}\NormalTok{]}\OperatorTok{,}
    \DataTypeTok{step}\OperatorTok{:} \VariableTok{self}\NormalTok{.}\AttributeTok{getInputConfiguration}\NormalTok{(el).}\AttributeTok{step}\OperatorTok{,}
    \DataTypeTok{range}\OperatorTok{:} \OperatorTok{\{} 
      \DataTypeTok{min}\OperatorTok{:} \VariableTok{self}\NormalTok{.}\AttributeTok{getInputConfiguration}\NormalTok{(el).}\AttributeTok{min}\OperatorTok{,} 
      \DataTypeTok{max}\OperatorTok{:} \VariableTok{self}\NormalTok{.}\AttributeTok{getInputConfiguration}\NormalTok{(el).}\AttributeTok{max} 
    \OperatorTok{\}}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

as well as updating methods like \texttt{setInputValue}, \texttt{setInputConfiguration}. Fortunately,
there is already a \href{https://mmarkelov.github.io/react-nouislider/}{nouislider-react} API, which will
makes our job much easier than shown above. To add the new dependency we run:

\begin{verbatim}
yarn add nouislider-react
\end{verbatim}

and replace the import statement inside our JSX file to rely on \texttt{nouislider-react}.
The \texttt{Nouislider} component markup is fairly intuitive. We set the min and max as well as the current value:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \OperatorTok{\{}\NormalTok{ reactShinyInput }\OperatorTok{\}} \ImportTok{from} \StringTok{'reactR'}\OperatorTok{;}
\ImportTok{import}\NormalTok{ Nouislider }\ImportTok{from} \StringTok{"nouislider-react"}\OperatorTok{;}

\KeywordTok{function} \AttributeTok{ArgonSlider}\NormalTok{(}\OperatorTok{\{}\NormalTok{configuration}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ setValue}\OperatorTok{\}}\NormalTok{) }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ rangeOpts }\OperatorTok{=} \OperatorTok{\{}
    \DataTypeTok{min}\OperatorTok{:} \VariableTok{configuration}\NormalTok{.}\AttributeTok{min}\OperatorTok{,}
    \DataTypeTok{max}\OperatorTok{:} \VariableTok{configuration}\NormalTok{.}\AttributeTok{max}
  \OperatorTok{\};}
  \ControlFlowTok{return}\NormalTok{(}
    \FunctionTok{<Nouislider}
      \OtherTok{range}\OperatorTok{=}\VariableTok{\{}\NormalTok{rangeOpts}\VariableTok{\}}
      \OtherTok{start}\OperatorTok{=}\VariableTok{\{}\NormalTok{value}\VariableTok{\}}
      \OtherTok{connect}\OperatorTok{=}\VariableTok{\{}\NormalTok{[}\KeywordTok{true}\OperatorTok{,} \KeywordTok{false}\NormalTok{]}\VariableTok{\}}
    \FunctionTok{/>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}

\AttributeTok{reactShinyInput}\NormalTok{(}\StringTok{'.argon_slider'}\OperatorTok{,} \StringTok{'mypkg.argon_slider'}\OperatorTok{,}\NormalTok{ ArgonSlider)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{connect} property makes the slider bar background filled with the theme color. Figure \ref{fig:react-argon-slider} shows what happens when this parameter is disabled.

At that stage, we modified the \texttt{webpack.config.js} file so that there are multiple entry
points (to compile the action button and the slider) and combined the output in a more generic name:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{entry}\OperatorTok{:}\NormalTok{ [}
  \VariableTok{path}\NormalTok{.}\AttributeTok{join}\NormalTok{(__dirname}\OperatorTok{,} \StringTok{'srcjs'}\OperatorTok{,} \StringTok{'argon_action_button.jsx'}\NormalTok{)}\OperatorTok{,}
  \VariableTok{path}\NormalTok{.}\AttributeTok{join}\NormalTok{(__dirname}\OperatorTok{,} \StringTok{'srcjs'}\OperatorTok{,} \StringTok{'argon_slider.jsx'}\NormalTok{)}
\NormalTok{]}\OperatorTok{,}
\NormalTok{output}\OperatorTok{:} \OperatorTok{\{}
  \DataTypeTok{path}\OperatorTok{:} \VariableTok{path}\NormalTok{.}\AttributeTok{join}\NormalTok{(__dirname}\OperatorTok{,} \StringTok{'inst/www/mypkg/argon'}\NormalTok{)}\OperatorTok{,}
  \DataTypeTok{filename}\OperatorTok{:} \StringTok{'argon.js'}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This means we have to update the HTML dependency on the R side, for instance for
the \texttt{argon\_slider\_input.R}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{argon_slider_input <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, value, }\DataTypeTok{default =}\NormalTok{ value, min, max) \{}
\NormalTok{  reactR}\OperatorTok{::}\KeywordTok{createReactShinyInput}\NormalTok{(}
\NormalTok{    inputId,}
    \StringTok{"argon_slider"}\NormalTok{,}
\NormalTok{    htmltools}\OperatorTok{::}\KeywordTok{htmlDependency}\NormalTok{(}
      \DataTypeTok{name =} \StringTok{"argon"}\NormalTok{,}
      \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{,}
      \DataTypeTok{src =} \StringTok{"www/mypkg/argon"}\NormalTok{,}
      \DataTypeTok{package =} \StringTok{"mypkg"}\NormalTok{,}
      \DataTypeTok{script =} \StringTok{"argon.js"}
\NormalTok{    ),}
\NormalTok{    default,}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{min =}\NormalTok{ min,}
      \DataTypeTok{max =}\NormalTok{ max}
\NormalTok{    ),}
\NormalTok{    htmltools}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\NormalTok{div}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can run the app below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{theme =}\NormalTok{ bslib}\OperatorTok{::}\KeywordTok{bs_theme}\NormalTok{(}\DataTypeTok{version =} \StringTok{"4"}\NormalTok{),}
  \KeywordTok{argon_slider_input}\NormalTok{(}\StringTok{"plop"}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{100}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(}\KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{plop))}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

As shown on Figure \ref{fig:react-argon-slider}, the slider is properly displayed and the value
is recovered from the server. However, nothing happens when the range is dragged.
The reason is quite simple: we did not set the \texttt{setValue} inside our JSX code yet.

\begin{figure}
\includegraphics[width=1\linewidth]{images/going-further/react-argon-slider} \caption{Slider input with Argon React}\label{fig:react-argon-slider}
\end{figure}

The slider API provides many \href{https://refreshless.com/nouislider/events-callbacks/}{events} but not all
are suitable for us. Ideally, we would like an update:

\begin{itemize}
\tightlist
\item
  Each time the range is released after dragging.
\item
  Each time the range is moved by arrow key (keyboard).
\end{itemize}

This seems like a perfect shot for the \texttt{onChange} prop. Let's add it to the \texttt{ArgonSlider} component:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{ArgonSlider}\NormalTok{(}\OperatorTok{\{}\NormalTok{configuration}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ setValue}\OperatorTok{,}\NormalTok{ el}\OperatorTok{\}}\NormalTok{) }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ rangeOpts }\OperatorTok{=} \OperatorTok{\{}
    \DataTypeTok{min}\OperatorTok{:} \VariableTok{configuration}\NormalTok{.}\AttributeTok{min}\OperatorTok{,}
    \DataTypeTok{max}\OperatorTok{:} \VariableTok{configuration}\NormalTok{.}\AttributeTok{max}
  \OperatorTok{\};}

  \ControlFlowTok{return}\NormalTok{(}
    \FunctionTok{<Nouislider}
      \OtherTok{range}\OperatorTok{=}\VariableTok{\{}\NormalTok{rangeOpts}\VariableTok{\}}
      \OtherTok{start}\OperatorTok{=}\VariableTok{\{}\NormalTok{[value]}\VariableTok{\}}
      \OtherTok{connect}\OperatorTok{=}\VariableTok{\{}\NormalTok{[}\KeywordTok{true}\OperatorTok{,} \KeywordTok{false}\NormalTok{]}\VariableTok{\}}
      \OtherTok{onChange}\OperatorTok{=}\VariableTok{\{}\NormalTok{() }\KeywordTok{=>} \AttributeTok{setValue}\NormalTok{()}\VariableTok{\}}
    \FunctionTok{/>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

What value should we pass to \texttt{setValue}? This is quite easy to recover the slider value
directly within the React component. We pass a parameter to the function, which will recover the
latest value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{value }\KeywordTok{=>} \AttributeTok{setValue}\NormalTok{(}\AttributeTok{parseFloat}\NormalTok{(value))}
\end{Highlighting}
\end{Shaded}

The trick is to convert the value to a number since we recover a string by default. You may
use \texttt{parseInt} or \texttt{parseFloat}, depending whether you want a integer or the exact value.
Right now, the slider cannot be moved with the keyboard. Adding the \texttt{keyboardSupport} prop
make it possible. This may correspond to a parameter provided in the \texttt{argon\_slider\_input} configuration.
The \texttt{tooltips} parameter enhances the user experience by showing the current value, on top of the slider, while
\texttt{pips} add a simple grid. Not mentioned in the documentation, we add some CSS properties (top and bottom margins) to improve the display. Importantly, as the update slider function passes a named list to JS, any
missing property is dropped, which can lead to undefined values on the JS side and unexpected behavior.
Therefore, it is good to put default values whenever necessary to avoid this kind of issue. For instance,
assume you passed \texttt{orientation\ =\ "horizontal"} upon slider creation and forgot to
put that parameter in the update list, you can do the following in the JSX code:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\VariableTok{configuration}\NormalTok{.}\AttributeTok{orientation} \OperatorTok{===} \KeywordTok{undefined}\NormalTok{) }\OperatorTok{\{}
  \VariableTok{configuration}\NormalTok{.}\AttributeTok{orientation} \OperatorTok{=} \StringTok{"horizontal"}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The whole component code may be found below:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{ArgonSlider}\NormalTok{(}\OperatorTok{\{}\NormalTok{configuration}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,}\NormalTok{ setValue}\OperatorTok{,}\NormalTok{ el}\OperatorTok{\}}\NormalTok{) }\OperatorTok{\{}
  \KeywordTok{const}\NormalTok{ rangeOpts }\OperatorTok{=} \OperatorTok{\{}
    \DataTypeTok{min}\OperatorTok{:} \VariableTok{configuration}\NormalTok{.}\AttributeTok{min}\OperatorTok{,}
    \DataTypeTok{max}\OperatorTok{:} \VariableTok{configuration}\NormalTok{.}\AttributeTok{max}
  \OperatorTok{\};}
  
  \CommentTok{// Better margins}
  \KeywordTok{const}\NormalTok{ sliderStyle }\OperatorTok{=} \OperatorTok{\{}\DataTypeTok{marginTop}\OperatorTok{:} \StringTok{"50px"}\OperatorTok{,} \DataTypeTok{marginBottom}\OperatorTok{:} \StringTok{"50px"}\OperatorTok{\};}
  
  \CommentTok{// Grid}
  \KeywordTok{const}\NormalTok{ pipOpts }\OperatorTok{=} \OperatorTok{\{}
    \DataTypeTok{mode}\OperatorTok{:} \StringTok{'range'}\OperatorTok{,}
    \DataTypeTok{density}\OperatorTok{:} \DecValTok{3}
  \OperatorTok{\};}
  
  \ControlFlowTok{return}\NormalTok{(}
    \FunctionTok{<Nouislider}
      \OtherTok{style}\OperatorTok{=}\VariableTok{\{}\NormalTok{sliderStyle}\VariableTok{\}}
      \OtherTok{range}\OperatorTok{=}\VariableTok{\{}\NormalTok{rangeOpts}\VariableTok{\}}
      \OtherTok{start}\OperatorTok{=}\VariableTok{\{}\NormalTok{[value]}\VariableTok{\}}
      \OtherTok{connect}\OperatorTok{=}\VariableTok{\{}\NormalTok{[}\KeywordTok{true}\OperatorTok{,} \KeywordTok{false}\NormalTok{]}\VariableTok{\}}
      \OtherTok{onChange}\OperatorTok{=}\VariableTok{\{}\NormalTok{value }\KeywordTok{=>} \AttributeTok{setValue}\NormalTok{(}\AttributeTok{parseFloat}\NormalTok{(value))}\VariableTok{\}}
      \OtherTok{keyboardSupport}\OperatorTok{=}\VariableTok{\{configuration}\NormalTok{.}\AttributeTok{keyboard}\VariableTok{\}}
      \OtherTok{tooltips}\OperatorTok{=}\VariableTok{\{configuration}\NormalTok{.}\AttributeTok{tooltips}\VariableTok{\}}
      \OtherTok{pips}\OperatorTok{=}\VariableTok{\{}\NormalTok{pipOpts}\VariableTok{\}}
    \FunctionTok{/>}
\NormalTok{  )}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{argon\_slider\_input} is given by:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{argon_slider_input <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(inputId, value, }\DataTypeTok{default =}\NormalTok{ value, min, max, }\DataTypeTok{keyboard =} \OtherTok{TRUE}\NormalTok{,}
                               \DataTypeTok{tooltips =} \OtherTok{TRUE}\NormalTok{) \{}
\NormalTok{  reactR}\OperatorTok{::}\KeywordTok{createReactShinyInput}\NormalTok{(}
\NormalTok{    inputId,}
    \StringTok{"argon_slider"}\NormalTok{,}
\NormalTok{    htmltools}\OperatorTok{::}\KeywordTok{htmlDependency}\NormalTok{(}
      \DataTypeTok{name =} \StringTok{"argon"}\NormalTok{,}
      \DataTypeTok{version =} \StringTok{"1.0.0"}\NormalTok{,}
      \DataTypeTok{src =} \StringTok{"www/mypkg/argon"}\NormalTok{,}
      \DataTypeTok{package =} \StringTok{"mypkg"}\NormalTok{,}
      \DataTypeTok{script =} \StringTok{"argon.js"}
\NormalTok{    ),}
\NormalTok{    default,}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{min =}\NormalTok{ min,}
      \DataTypeTok{max =}\NormalTok{ max,}
      \DataTypeTok{keyboardSupport =}\NormalTok{ keyboard,}
      \DataTypeTok{tooltips =}\NormalTok{ tooltips}
\NormalTok{    ),}
\NormalTok{    htmltools}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\NormalTok{div}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There are many more parameters that can be added to the following \href{https://refreshless.com/nouislider/slider-options/}{API}. We leave it as an
exercise for the reader.

Finally, let's see how \texttt{update\_argon\_slider\_input} works:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <-}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \DataTypeTok{theme =}\NormalTok{ bslib}\OperatorTok{::}\KeywordTok{bs_theme}\NormalTok{(}\DataTypeTok{version =} \StringTok{"4"}\NormalTok{),}
  \KeywordTok{argon_slider_input}\NormalTok{(}\StringTok{"plop"}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{100}\NormalTok{),}
  \KeywordTok{br}\NormalTok{(),}
  \KeywordTok{argon_action_button}\NormalTok{(}\StringTok{"update"}\NormalTok{, }\StringTok{"Update button 1"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session) \{}
  \KeywordTok{observe}\NormalTok{(}\KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{plop))}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{update, \{}
    \KeywordTok{update_argon_slider_input}\NormalTok{(}
\NormalTok{      session, }\StringTok{"plop"}\NormalTok{,}
      \DataTypeTok{value =} \DecValTok{100}\NormalTok{,}
      \DataTypeTok{configuration =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{min =} \DecValTok{0}\NormalTok{,}
        \DataTypeTok{max =} \DecValTok{200}\NormalTok{,}
        \DataTypeTok{tooltips =} \OtherTok{FALSE}\NormalTok{,}
        \DataTypeTok{keyboardSupport =} \OtherTok{FALSE}
\NormalTok{      )}
\NormalTok{    )}
\NormalTok{  \}, }\DataTypeTok{ignoreInit =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

The \texttt{keyboardSupport} option does not seem changed, neither is the \texttt{tooltips} option. Actually,
only that \href{https://refreshless.com/nouislider/more/\#section-update}{list} may be modified. Let's address this below.
The \texttt{nouiSlider} React API provides internal access to the slider instance from within the
\href{https://github.com/mmarkelov/react-nouislider\#using-with-ref}{component}. To make it work, we have to leverage the React Hook feature:

\begin{itemize}
\tightlist
\item
  Create a Hook hosting the component reference and a method to update it with \texttt{React.useState}.
\item
  Update the instance option each time the component is re-rendered by Shiny.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ [ref}\OperatorTok{,}\NormalTok{ setRef] }\OperatorTok{=} \VariableTok{React}\NormalTok{.}\AttributeTok{useState}\NormalTok{(}\KeywordTok{null}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ setConfiguration }\OperatorTok{=}\NormalTok{ () }\KeywordTok{=>} \OperatorTok{\{}
  \ControlFlowTok{if}\NormalTok{ (ref }\OperatorTok{&&} \VariableTok{ref}\NormalTok{.}\AttributeTok{noUiSlider}\NormalTok{) }\OperatorTok{\{}
    \VariableTok{ref}\NormalTok{.}\VariableTok{noUiSlider}\NormalTok{.}\AttributeTok{updateOptions}\NormalTok{(configuration)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\};}

\AttributeTok{setConfiguration}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We must specify the \texttt{instanceRef} property which will capture the slider reference when available and update
the local ref:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{<Nouislider}
  \OtherTok{style}\OperatorTok{=}\VariableTok{\{}\NormalTok{sliderStyle}\VariableTok{\}}
  \OtherTok{keyboardSupport}\OperatorTok{=}\VariableTok{\{configuration}\NormalTok{.}\AttributeTok{keyboard}\VariableTok{\}}
  \OtherTok{connect}\OperatorTok{=}\VariableTok{\{}\NormalTok{[}\KeywordTok{true}\OperatorTok{,} \KeywordTok{false}\NormalTok{]}\VariableTok{\}}
  \OtherTok{range}\OperatorTok{=}\VariableTok{\{}\NormalTok{rangeOpts}\VariableTok{\}}
  \OtherTok{start}\OperatorTok{=}\VariableTok{\{}\NormalTok{[value]}\VariableTok{\}}
  \OtherTok{onChange}\OperatorTok{=}\VariableTok{\{}\NormalTok{value }\KeywordTok{=>} \AttributeTok{setValue}\NormalTok{(}\AttributeTok{parseFloat}\NormalTok{(value))}\VariableTok{\}}
  \OtherTok{tooltips}\OperatorTok{=}\VariableTok{\{configuration}\NormalTok{.}\AttributeTok{tooltips}\VariableTok{\}}
  \OtherTok{pips}\OperatorTok{=}\VariableTok{\{}\NormalTok{pipOpts}\VariableTok{\}}
  \OtherTok{instanceRef}\OperatorTok{=}\VariableTok{\{}
\NormalTok{    instance }\KeywordTok{=>} \OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ (instance }\OperatorTok{&&} \OperatorTok{!}\NormalTok{ref) }\OperatorTok{\{}
        \AttributeTok{setRef}\NormalTok{(instance)}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \VariableTok{\}}
\FunctionTok{/>}
\end{Highlighting}
\end{Shaded}

We recompile the code and run the previous example. While the tooltip is gone,
the keyboard interaction is still there. This is not surprising as \texttt{updateOptions} does
not handle all settings. The final result is displayed Figure \ref{fig:react-argon-slider-final}.

\begin{figure}
\includegraphics[width=1\linewidth]{images/going-further/react-argon-slider-final} \caption{Slider input with Argon React with more options}\label{fig:react-argon-slider-final}
\end{figure}

\hypertarget{exercise-2-a-range-slider}{%
\subsubsection{Exercise 2: a range slider}\label{exercise-2-a-range-slider}}

Based on the above example, improve the previous slider widget to handle
the range slider case, that is enable the user to pass a vector of initial values.

\hypertarget{toward-custom-components}{%
\subsection{Toward custom components}\label{toward-custom-components}}

Creating custom components in Shiny is not that easy. If we assume we want to create
a custom text container which color, size and many CSS properties can change dynamically.
This is a bit different from the approach shown in Chapter \ref{beautify-with-bootstraplib} since
the \texttt{\{bslib\}} gives access to Bootstrap \href{https://rstudio.github.io/bslib/articles/bs4-variables.html}{variables} but not basic CSS properties like the color of a \texttt{span} element.

  \bibliography{book.bib,packages.bib}

\backmatter
\printindex

\end{document}
